
mcp794xx_rtc_SAMD21.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000085cc  00000000  00000000  00010000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .got          00000094  000085cc  000085cc  000185cc  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  2 .got.plt      0000000c  00008660  00008660  00018660  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  3 .relocate     00000240  20000000  0000866c  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  4 .bss          000001cc  20000240  000088ac  00020240  2**2
                  ALLOC
  5 .stack        00002004  2000040c  00008a78  00020240  2**0
                  ALLOC
  6 .ARM.attributes 0000002a  00000000  00000000  00020240  2**0
                  CONTENTS, READONLY
  7 .comment      00000059  00000000  00000000  0002026a  2**0
                  CONTENTS, READONLY
  8 .debug_info   0002b85e  00000000  00000000  000202c3  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_abbrev 00003771  00000000  00000000  0004bb21  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00011ecb  00000000  00000000  0004f292  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_aranges 00000ec8  00000000  00000000  0006115d  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000fa0  00000000  00000000  00062025  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_macro  0001a7b5  00000000  00000000  00062fc5  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_line   00010a85  00000000  00000000  0007d77a  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_str    0008aa1a  00000000  00000000  0008e1ff  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_frame  00003290  00000000  00000000  00118c1c  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <exception_table>:
       0:	10 24 00 20 21 01 00 00 1d 01 00 00 1d 01 00 00     .$. !...........
	...
      2c:	1d 01 00 00 00 00 00 00 00 00 00 00 1d 01 00 00     ................
      3c:	1d 01 00 00 1d 01 00 00 1d 01 00 00 1d 01 00 00     ................
      4c:	1d 01 00 00 c1 09 00 00 1d 01 00 00 1d 01 00 00     ................
      5c:	1d 01 00 00 1d 01 00 00 1d 01 00 00 1d 01 00 00     ................
      6c:	1d 01 00 00 1d 01 00 00 1d 01 00 00 1d 01 00 00     ................
      7c:	1d 01 00 00 1d 01 00 00 1d 01 00 00 1d 01 00 00     ................
      8c:	1d 01 00 00 1d 01 00 00 00 00 00 00 00 00 00 00     ................
      9c:	1d 01 00 00 1d 01 00 00 1d 01 00 00 1d 01 00 00     ................
      ac:	1d 01 00 00 00 00 00 00                             ........

000000b4 <__do_global_dtors_aux>:
      b4:	b510      	push	{r4, lr}
      b6:	4c06      	ldr	r4, [pc, #24]	; (d0 <__do_global_dtors_aux+0x1c>)
      b8:	7823      	ldrb	r3, [r4, #0]
      ba:	2b00      	cmp	r3, #0
      bc:	d107      	bne.n	ce <__do_global_dtors_aux+0x1a>
      be:	4b05      	ldr	r3, [pc, #20]	; (d4 <__do_global_dtors_aux+0x20>)
      c0:	2b00      	cmp	r3, #0
      c2:	d002      	beq.n	ca <__do_global_dtors_aux+0x16>
      c4:	4804      	ldr	r0, [pc, #16]	; (d8 <__do_global_dtors_aux+0x24>)
      c6:	e000      	b.n	ca <__do_global_dtors_aux+0x16>
      c8:	bf00      	nop
      ca:	2301      	movs	r3, #1
      cc:	7023      	strb	r3, [r4, #0]
      ce:	bd10      	pop	{r4, pc}
      d0:	20000240 	.word	0x20000240
      d4:	00000000 	.word	0x00000000
      d8:	000085cc 	.word	0x000085cc

000000dc <frame_dummy>:
      dc:	4b08      	ldr	r3, [pc, #32]	; (100 <frame_dummy+0x24>)
      de:	b510      	push	{r4, lr}
      e0:	2b00      	cmp	r3, #0
      e2:	d003      	beq.n	ec <frame_dummy+0x10>
      e4:	4907      	ldr	r1, [pc, #28]	; (104 <frame_dummy+0x28>)
      e6:	4808      	ldr	r0, [pc, #32]	; (108 <frame_dummy+0x2c>)
      e8:	e000      	b.n	ec <frame_dummy+0x10>
      ea:	bf00      	nop
      ec:	4807      	ldr	r0, [pc, #28]	; (10c <frame_dummy+0x30>)
      ee:	6803      	ldr	r3, [r0, #0]
      f0:	2b00      	cmp	r3, #0
      f2:	d100      	bne.n	f6 <frame_dummy+0x1a>
      f4:	bd10      	pop	{r4, pc}
      f6:	4b06      	ldr	r3, [pc, #24]	; (110 <frame_dummy+0x34>)
      f8:	2b00      	cmp	r3, #0
      fa:	d0fb      	beq.n	f4 <frame_dummy+0x18>
      fc:	4798      	blx	r3
      fe:	e7f9      	b.n	f4 <frame_dummy+0x18>
     100:	00000000 	.word	0x00000000
     104:	20000244 	.word	0x20000244
     108:	000085cc 	.word	0x000085cc
     10c:	000085cc 	.word	0x000085cc
     110:	00000000 	.word	0x00000000

00000114 <atmel_start_init>:

/**
 * Initializes MCU, drivers and middleware in the project
 **/
void atmel_start_init(void)
{
     114:	b510      	push	{r4, lr}
	system_init();
     116:	f000 f94d 	bl	3b4 <system_init>
}
     11a:	bd10      	pop	{r4, pc}

0000011c <Dummy_Handler>:

/**
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler(void)
{
     11c:	e7fe      	b.n	11c <Dummy_Handler>
	...

00000120 <Reset_Handler>:
{
     120:	b5f0      	push	{r4, r5, r6, r7, lr}
     122:	b083      	sub	sp, #12
     124:	4b2c      	ldr	r3, [pc, #176]	; (1d8 <Reset_Handler+0xb8>)
     126:	447b      	add	r3, pc
        if (pSrc != pDest) {
     128:	4a2c      	ldr	r2, [pc, #176]	; (1dc <Reset_Handler+0xbc>)
     12a:	589a      	ldr	r2, [r3, r2]
     12c:	9200      	str	r2, [sp, #0]
     12e:	4a2c      	ldr	r2, [pc, #176]	; (1e0 <Reset_Handler+0xc0>)
     130:	589a      	ldr	r2, [r3, r2]
     132:	9201      	str	r2, [sp, #4]
     134:	9a00      	ldr	r2, [sp, #0]
     136:	9901      	ldr	r1, [sp, #4]
     138:	428a      	cmp	r2, r1
     13a:	d00d      	beq.n	158 <Reset_Handler+0x38>
     13c:	4a28      	ldr	r2, [pc, #160]	; (1e0 <Reset_Handler+0xc0>)
     13e:	589a      	ldr	r2, [r3, r2]
     140:	4926      	ldr	r1, [pc, #152]	; (1dc <Reset_Handler+0xbc>)
     142:	5859      	ldr	r1, [r3, r1]
     144:	e003      	b.n	14e <Reset_Handler+0x2e>
                        *pDest++ = *pSrc++;
     146:	6808      	ldr	r0, [r1, #0]
     148:	6010      	str	r0, [r2, #0]
     14a:	3204      	adds	r2, #4
     14c:	3104      	adds	r1, #4
                for (; pDest < &_erelocate;) {
     14e:	4825      	ldr	r0, [pc, #148]	; (1e4 <Reset_Handler+0xc4>)
     150:	5818      	ldr	r0, [r3, r0]
     152:	9000      	str	r0, [sp, #0]
     154:	4282      	cmp	r2, r0
     156:	d3f6      	bcc.n	146 <Reset_Handler+0x26>
                        *pDest++ = *pSrc++;
     158:	4a23      	ldr	r2, [pc, #140]	; (1e8 <Reset_Handler+0xc8>)
     15a:	589a      	ldr	r2, [r3, r2]
     15c:	e002      	b.n	164 <Reset_Handler+0x44>
                *pDest++ = 0;
     15e:	2100      	movs	r1, #0
     160:	6011      	str	r1, [r2, #0]
     162:	3204      	adds	r2, #4
        for (pDest = &_szero; pDest < &_ezero;) {
     164:	4921      	ldr	r1, [pc, #132]	; (1ec <Reset_Handler+0xcc>)
     166:	5859      	ldr	r1, [r3, r1]
     168:	9100      	str	r1, [sp, #0]
     16a:	428a      	cmp	r2, r1
     16c:	d3f7      	bcc.n	15e <Reset_Handler+0x3e>
        SCB->VTOR = ((uint32_t) pSrc & SCB_VTOR_TBLOFF_Msk);
     16e:	4a20      	ldr	r2, [pc, #128]	; (1f0 <Reset_Handler+0xd0>)
     170:	589b      	ldr	r3, [r3, r2]
     172:	9300      	str	r3, [sp, #0]
     174:	23ff      	movs	r3, #255	; 0xff
     176:	9a00      	ldr	r2, [sp, #0]
     178:	439a      	bics	r2, r3
     17a:	0013      	movs	r3, r2
     17c:	4a1d      	ldr	r2, [pc, #116]	; (1f4 <Reset_Handler+0xd4>)
     17e:	6093      	str	r3, [r2, #8]
        SBMATRIX->SFR[SBMATRIX_SLAVE_HMCRAMC0].reg = 2;
     180:	2102      	movs	r1, #2
     182:	2390      	movs	r3, #144	; 0x90
     184:	005b      	lsls	r3, r3, #1
     186:	4a1c      	ldr	r2, [pc, #112]	; (1f8 <Reset_Handler+0xd8>)
     188:	50d1      	str	r1, [r2, r3]
        USB->DEVICE.QOSCTRL.bit.CQOS = 2;
     18a:	4a1c      	ldr	r2, [pc, #112]	; (1fc <Reset_Handler+0xdc>)
     18c:	78d3      	ldrb	r3, [r2, #3]
     18e:	2503      	movs	r5, #3
     190:	43ab      	bics	r3, r5
     192:	2402      	movs	r4, #2
     194:	4323      	orrs	r3, r4
     196:	70d3      	strb	r3, [r2, #3]
        USB->DEVICE.QOSCTRL.bit.DQOS = 2;
     198:	78d3      	ldrb	r3, [r2, #3]
     19a:	270c      	movs	r7, #12
     19c:	43bb      	bics	r3, r7
     19e:	2608      	movs	r6, #8
     1a0:	4333      	orrs	r3, r6
     1a2:	70d3      	strb	r3, [r2, #3]
        DMAC->QOSCTRL.bit.DQOS = 2;
     1a4:	4b16      	ldr	r3, [pc, #88]	; (200 <Reset_Handler+0xe0>)
     1a6:	7b98      	ldrb	r0, [r3, #14]
     1a8:	2230      	movs	r2, #48	; 0x30
     1aa:	4390      	bics	r0, r2
     1ac:	2220      	movs	r2, #32
     1ae:	4310      	orrs	r0, r2
     1b0:	7398      	strb	r0, [r3, #14]
        DMAC->QOSCTRL.bit.FQOS = 2;
     1b2:	7b99      	ldrb	r1, [r3, #14]
     1b4:	43b9      	bics	r1, r7
     1b6:	4331      	orrs	r1, r6
     1b8:	7399      	strb	r1, [r3, #14]
        DMAC->QOSCTRL.bit.WRBQOS = 2;
     1ba:	7b9a      	ldrb	r2, [r3, #14]
     1bc:	43aa      	bics	r2, r5
     1be:	4322      	orrs	r2, r4
     1c0:	739a      	strb	r2, [r3, #14]
        NVMCTRL->CTRLB.bit.MANW = 1;
     1c2:	4a10      	ldr	r2, [pc, #64]	; (204 <Reset_Handler+0xe4>)
     1c4:	6851      	ldr	r1, [r2, #4]
     1c6:	2380      	movs	r3, #128	; 0x80
     1c8:	430b      	orrs	r3, r1
     1ca:	6053      	str	r3, [r2, #4]
        __libc_init_array();
     1cc:	f005 ffba 	bl	6144 <__libc_init_array>
        main();
     1d0:	f001 f94a 	bl	1468 <main>
     1d4:	e7fe      	b.n	1d4 <Reset_Handler+0xb4>
     1d6:	46c0      	nop			; (mov r8, r8)
     1d8:	000084a2 	.word	0x000084a2
     1dc:	00000010 	.word	0x00000010
     1e0:	0000001c 	.word	0x0000001c
     1e4:	00000078 	.word	0x00000078
     1e8:	00000018 	.word	0x00000018
     1ec:	00000060 	.word	0x00000060
     1f0:	0000000c 	.word	0x0000000c
     1f4:	e000ed00 	.word	0xe000ed00
     1f8:	41007000 	.word	0x41007000
     1fc:	41005000 	.word	0x41005000
     200:	41004800 	.word	0x41004800
     204:	41004000 	.word	0x41004000

00000208 <EXTERNAL_IRQ_0_init>:
struct i2c_m_sync_desc I2C_0;

struct usart_sync_descriptor USART_0;

void EXTERNAL_IRQ_0_init(void)
{
     208:	b570      	push	{r4, r5, r6, lr}
}

static inline void hri_gclk_write_CLKCTRL_reg(const void *const hw, hri_gclk_clkctrl_reg_t data)
{
	GCLK_CRITICAL_SECTION_ENTER();
	((Gclk *)hw)->CLKCTRL.reg = data;
     20a:	4a11      	ldr	r2, [pc, #68]	; (250 <EXTERNAL_IRQ_0_init+0x48>)
     20c:	4b11      	ldr	r3, [pc, #68]	; (254 <EXTERNAL_IRQ_0_init+0x4c>)
     20e:	805a      	strh	r2, [r3, #2]
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = ~data;
}

static inline void hri_port_clear_DIR_reg(const void *const hw, uint8_t submodule_index, hri_port_dir_reg_t mask)
{
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
     210:	20c0      	movs	r0, #192	; 0xc0
     212:	05c0      	lsls	r0, r0, #23
     214:	2480      	movs	r4, #128	; 0x80
     216:	0464      	lsls	r4, r4, #17
     218:	6044      	str	r4, [r0, #4]

static inline void hri_port_write_WRCONFIG_reg(const void *const hw, uint8_t submodule_index,
                                               hri_port_wrconfig_reg_t data)
{
	PORT_CRITICAL_SECTION_ENTER();
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     21a:	4b0f      	ldr	r3, [pc, #60]	; (258 <EXTERNAL_IRQ_0_init+0x50>)
     21c:	4a0f      	ldr	r2, [pc, #60]	; (25c <EXTERNAL_IRQ_0_init+0x54>)
     21e:	629a      	str	r2, [r3, #40]	; 0x28
     220:	4a0f      	ldr	r2, [pc, #60]	; (260 <EXTERNAL_IRQ_0_init+0x58>)
     222:	629a      	str	r2, [r3, #40]	; 0x28
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
     224:	6044      	str	r4, [r0, #4]
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg |= PORT_PINCFG_PULLEN;
     226:	2158      	movs	r1, #88	; 0x58
     228:	5c5a      	ldrb	r2, [r3, r1]
     22a:	2504      	movs	r5, #4
     22c:	432a      	orrs	r2, r5
     22e:	b2d2      	uxtb	r2, r2
     230:	545a      	strb	r2, [r3, r1]
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
     232:	6184      	str	r4, [r0, #24]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     234:	5c5a      	ldrb	r2, [r3, r1]
	tmp &= ~PORT_PINCFG_PMUXEN;
     236:	2001      	movs	r0, #1
     238:	4382      	bics	r2, r0
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     23a:	4302      	orrs	r2, r0
     23c:	b2d2      	uxtb	r2, r2
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     23e:	545a      	strb	r2, [r3, r1]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     240:	391c      	subs	r1, #28
     242:	5c5a      	ldrb	r2, [r3, r1]
	tmp &= ~PORT_PMUX_PMUXE_Msk;
     244:	200f      	movs	r0, #15
     246:	4382      	bics	r2, r0
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     248:	545a      	strb	r2, [r3, r1]
	                       // <GPIO_PULL_DOWN"> Pull-down
	                       GPIO_PULL_UP);

	gpio_set_pin_function(PA24, PINMUX_PA24A_EIC_EXTINT12);

	ext_irq_init();
     24a:	f000 f92b 	bl	4a4 <ext_irq_init>
}
     24e:	bd70      	pop	{r4, r5, r6, pc}
     250:	00004005 	.word	0x00004005
     254:	40000c00 	.word	0x40000c00
     258:	41004400 	.word	0x41004400
     25c:	40020000 	.word	0x40020000
     260:	c0020100 	.word	0xc0020100

00000264 <I2C_0_PORT_init>:

void I2C_0_PORT_init(void)
{
     264:	b570      	push	{r4, r5, r6, lr}
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg &= ~PORT_PINCFG_PULLEN;
     266:	4b13      	ldr	r3, [pc, #76]	; (2b4 <I2C_0_PORT_init+0x50>)
     268:	2050      	movs	r0, #80	; 0x50
     26a:	5c19      	ldrb	r1, [r3, r0]
     26c:	2204      	movs	r2, #4
     26e:	4391      	bics	r1, r2
     270:	5419      	strb	r1, [r3, r0]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     272:	5c19      	ldrb	r1, [r3, r0]
	tmp &= ~PORT_PINCFG_PMUXEN;
     274:	2501      	movs	r5, #1
     276:	43a9      	bics	r1, r5
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     278:	2401      	movs	r4, #1
     27a:	4321      	orrs	r1, r4
     27c:	b2c9      	uxtb	r1, r1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     27e:	5419      	strb	r1, [r3, r0]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     280:	3818      	subs	r0, #24
     282:	5c19      	ldrb	r1, [r3, r0]
	tmp &= ~PORT_PMUX_PMUXE_Msk;
     284:	260f      	movs	r6, #15
     286:	43b1      	bics	r1, r6
	tmp |= PORT_PMUX_PMUXE(data);
     288:	2602      	movs	r6, #2
     28a:	4331      	orrs	r1, r6
     28c:	b2c9      	uxtb	r1, r1
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     28e:	5419      	strb	r1, [r3, r0]
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg &= ~PORT_PINCFG_PULLEN;
     290:	2151      	movs	r1, #81	; 0x51
     292:	5c5e      	ldrb	r6, [r3, r1]
     294:	4396      	bics	r6, r2
     296:	545e      	strb	r6, [r3, r1]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     298:	5c5a      	ldrb	r2, [r3, r1]
	tmp &= ~PORT_PINCFG_PMUXEN;
     29a:	43aa      	bics	r2, r5
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     29c:	4322      	orrs	r2, r4
     29e:	b2d2      	uxtb	r2, r2
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     2a0:	545a      	strb	r2, [r3, r1]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     2a2:	5c1a      	ldrb	r2, [r3, r0]
	tmp &= ~PORT_PMUX_PMUXO_Msk;
     2a4:	3942      	subs	r1, #66	; 0x42
     2a6:	400a      	ands	r2, r1
	tmp |= PORT_PMUX_PMUXO(data);
     2a8:	2120      	movs	r1, #32
     2aa:	430a      	orrs	r2, r1
     2ac:	b2d2      	uxtb	r2, r2
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     2ae:	541a      	strb	r2, [r3, r0]
	                       // <GPIO_PULL_UP"> Pull-up
	                       // <GPIO_PULL_DOWN"> Pull-down
	                       GPIO_PULL_OFF);

	gpio_set_pin_function(PA17, PINMUX_PA17C_SERCOM1_PAD1);
}
     2b0:	bd70      	pop	{r4, r5, r6, pc}
     2b2:	46c0      	nop			; (mov r8, r8)
     2b4:	41004400 	.word	0x41004400

000002b8 <I2C_0_CLOCK_init>:
			peripheral = (uint32_t)_pm_get_apbb_index(module);
			PM->APBBMASK.reg |= 1 << peripheral;
		}
		break;
	case PM_BUS_APBC:
		PM->APBCMASK.reg |= 1 << peripheral;
     2b8:	4a05      	ldr	r2, [pc, #20]	; (2d0 <I2C_0_CLOCK_init+0x18>)
     2ba:	6a13      	ldr	r3, [r2, #32]
     2bc:	2108      	movs	r1, #8
     2be:	430b      	orrs	r3, r1
     2c0:	6213      	str	r3, [r2, #32]
     2c2:	4b04      	ldr	r3, [pc, #16]	; (2d4 <I2C_0_CLOCK_init+0x1c>)
     2c4:	4a04      	ldr	r2, [pc, #16]	; (2d8 <I2C_0_CLOCK_init+0x20>)
     2c6:	805a      	strh	r2, [r3, #2]
     2c8:	4a04      	ldr	r2, [pc, #16]	; (2dc <I2C_0_CLOCK_init+0x24>)
     2ca:	805a      	strh	r2, [r3, #2]
void I2C_0_CLOCK_init(void)
{
	_pm_enable_bus_clock(PM_BUS_APBC, SERCOM1);
	_gclk_enable_channel(SERCOM1_GCLK_ID_CORE, CONF_GCLK_SERCOM1_CORE_SRC);
	_gclk_enable_channel(SERCOM1_GCLK_ID_SLOW, CONF_GCLK_SERCOM1_SLOW_SRC);
}
     2cc:	4770      	bx	lr
     2ce:	46c0      	nop			; (mov r8, r8)
     2d0:	40000400 	.word	0x40000400
     2d4:	40000c00 	.word	0x40000c00
     2d8:	00004015 	.word	0x00004015
     2dc:	00004313 	.word	0x00004313

000002e0 <I2C_0_init>:

void I2C_0_init(void)
{
     2e0:	b510      	push	{r4, lr}
     2e2:	b082      	sub	sp, #8
     2e4:	4c07      	ldr	r4, [pc, #28]	; (304 <I2C_0_init+0x24>)
     2e6:	447c      	add	r4, pc
	I2C_0_CLOCK_init();
     2e8:	f7ff ffe6 	bl	2b8 <I2C_0_CLOCK_init>
	i2c_m_sync_init(&I2C_0, SERCOM1);
     2ec:	4b06      	ldr	r3, [pc, #24]	; (308 <I2C_0_init+0x28>)
     2ee:	58e3      	ldr	r3, [r4, r3]
     2f0:	9301      	str	r3, [sp, #4]
     2f2:	4906      	ldr	r1, [pc, #24]	; (30c <I2C_0_init+0x2c>)
     2f4:	0018      	movs	r0, r3
     2f6:	f000 f999 	bl	62c <i2c_m_sync_init>
	I2C_0_PORT_init();
     2fa:	f7ff ffb3 	bl	264 <I2C_0_PORT_init>
}
     2fe:	b002      	add	sp, #8
     300:	bd10      	pop	{r4, pc}
     302:	46c0      	nop			; (mov r8, r8)
     304:	000082e2 	.word	0x000082e2
     308:	00000088 	.word	0x00000088
     30c:	42000c00 	.word	0x42000c00

00000310 <USART_0_PORT_init>:

void USART_0_PORT_init(void)
{
     310:	b530      	push	{r4, r5, lr}
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     312:	4b0f      	ldr	r3, [pc, #60]	; (350 <USART_0_PORT_init+0x40>)
     314:	22c2      	movs	r2, #194	; 0xc2
     316:	5c99      	ldrb	r1, [r3, r2]
	tmp &= ~PORT_PINCFG_PMUXEN;
     318:	2501      	movs	r5, #1
     31a:	43a9      	bics	r1, r5
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     31c:	2401      	movs	r4, #1
     31e:	4321      	orrs	r1, r4
     320:	b2c9      	uxtb	r1, r1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     322:	5499      	strb	r1, [r3, r2]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     324:	20b1      	movs	r0, #177	; 0xb1
     326:	5c19      	ldrb	r1, [r3, r0]
	tmp &= ~PORT_PMUX_PMUXE_Msk;
     328:	3ab3      	subs	r2, #179	; 0xb3
     32a:	4391      	bics	r1, r2
	tmp |= PORT_PMUX_PMUXE(data);
     32c:	2203      	movs	r2, #3
     32e:	4311      	orrs	r1, r2
     330:	b2c9      	uxtb	r1, r1
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     332:	5419      	strb	r1, [r3, r0]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     334:	21c3      	movs	r1, #195	; 0xc3
     336:	5c5a      	ldrb	r2, [r3, r1]
	tmp &= ~PORT_PINCFG_PMUXEN;
     338:	43aa      	bics	r2, r5
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     33a:	4322      	orrs	r2, r4
     33c:	b2d2      	uxtb	r2, r2
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     33e:	545a      	strb	r2, [r3, r1]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     340:	5c1a      	ldrb	r2, [r3, r0]
	tmp &= ~PORT_PMUX_PMUXO_Msk;
     342:	39b4      	subs	r1, #180	; 0xb4
     344:	400a      	ands	r2, r1
	tmp |= PORT_PMUX_PMUXO(data);
     346:	2130      	movs	r1, #48	; 0x30
     348:	430a      	orrs	r2, r1
     34a:	b2d2      	uxtb	r2, r2
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     34c:	541a      	strb	r2, [r3, r0]

	gpio_set_pin_function(PB02, PINMUX_PB02D_SERCOM5_PAD0);

	gpio_set_pin_function(PB03, PINMUX_PB03D_SERCOM5_PAD1);
}
     34e:	bd30      	pop	{r4, r5, pc}
     350:	41004400 	.word	0x41004400

00000354 <USART_0_CLOCK_init>:
     354:	4a04      	ldr	r2, [pc, #16]	; (368 <USART_0_CLOCK_init+0x14>)
     356:	6a13      	ldr	r3, [r2, #32]
     358:	2180      	movs	r1, #128	; 0x80
     35a:	430b      	orrs	r3, r1
     35c:	6213      	str	r3, [r2, #32]
     35e:	4a03      	ldr	r2, [pc, #12]	; (36c <USART_0_CLOCK_init+0x18>)
     360:	4b03      	ldr	r3, [pc, #12]	; (370 <USART_0_CLOCK_init+0x1c>)
     362:	805a      	strh	r2, [r3, #2]

void USART_0_CLOCK_init(void)
{
	_pm_enable_bus_clock(PM_BUS_APBC, SERCOM5);
	_gclk_enable_channel(SERCOM5_GCLK_ID_CORE, CONF_GCLK_SERCOM5_CORE_SRC);
}
     364:	4770      	bx	lr
     366:	46c0      	nop			; (mov r8, r8)
     368:	40000400 	.word	0x40000400
     36c:	00004019 	.word	0x00004019
     370:	40000c00 	.word	0x40000c00

00000374 <USART_0_init>:

void USART_0_init(void)
{
     374:	b510      	push	{r4, lr}
     376:	b082      	sub	sp, #8
     378:	4c07      	ldr	r4, [pc, #28]	; (398 <USART_0_init+0x24>)
     37a:	447c      	add	r4, pc
	USART_0_CLOCK_init();
     37c:	f7ff ffea 	bl	354 <USART_0_CLOCK_init>
	usart_sync_init(&USART_0, SERCOM5, (void *)NULL);
     380:	4b06      	ldr	r3, [pc, #24]	; (39c <USART_0_init+0x28>)
     382:	58e3      	ldr	r3, [r4, r3]
     384:	9301      	str	r3, [sp, #4]
     386:	2200      	movs	r2, #0
     388:	4905      	ldr	r1, [pc, #20]	; (3a0 <USART_0_init+0x2c>)
     38a:	0018      	movs	r0, r3
     38c:	f000 fa18 	bl	7c0 <usart_sync_init>
	USART_0_PORT_init();
     390:	f7ff ffbe 	bl	310 <USART_0_PORT_init>
}
     394:	b002      	add	sp, #8
     396:	bd10      	pop	{r4, pc}
     398:	0000824e 	.word	0x0000824e
     39c:	00000058 	.word	0x00000058
     3a0:	42001c00 	.word	0x42001c00

000003a4 <delay_driver_init>:

void delay_driver_init(void)
{
     3a4:	b510      	push	{r4, lr}
	delay_init(SysTick);
     3a6:	4802      	ldr	r0, [pc, #8]	; (3b0 <delay_driver_init+0xc>)
     3a8:	f000 f83e 	bl	428 <delay_init>
}
     3ac:	bd10      	pop	{r4, pc}
     3ae:	46c0      	nop			; (mov r8, r8)
     3b0:	e000e010 	.word	0xe000e010

000003b4 <system_init>:

void system_init(void)
{
     3b4:	b510      	push	{r4, lr}
 * Currently the following initialization functions are supported:
 *  - System clock initialization
 */
static inline void init_mcu(void)
{
	_init_chip();
     3b6:	f000 fa7d 	bl	8b4 <_init_chip>
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     3ba:	23c0      	movs	r3, #192	; 0xc0
     3bc:	05db      	lsls	r3, r3, #23
     3be:	2280      	movs	r2, #128	; 0x80
     3c0:	0492      	lsls	r2, r2, #18
     3c2:	615a      	str	r2, [r3, #20]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     3c4:	609a      	str	r2, [r3, #8]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     3c6:	4b0a      	ldr	r3, [pc, #40]	; (3f0 <system_init+0x3c>)
     3c8:	2280      	movs	r2, #128	; 0x80
     3ca:	05d2      	lsls	r2, r2, #23
     3cc:	629a      	str	r2, [r3, #40]	; 0x28
     3ce:	4a09      	ldr	r2, [pc, #36]	; (3f4 <system_init+0x40>)
     3d0:	629a      	str	r2, [r3, #40]	; 0x28
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     3d2:	2159      	movs	r1, #89	; 0x59
     3d4:	5c5a      	ldrb	r2, [r3, r1]
	tmp &= ~PORT_PINCFG_PMUXEN;
     3d6:	2001      	movs	r0, #1
     3d8:	4382      	bics	r2, r0
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     3da:	545a      	strb	r2, [r3, r1]
	// Set pin direction to output
	gpio_set_pin_direction(user_led, GPIO_DIRECTION_OUT);

	gpio_set_pin_function(user_led, GPIO_PIN_FUNCTION_OFF);

	EXTERNAL_IRQ_0_init();
     3dc:	f7ff ff14 	bl	208 <EXTERNAL_IRQ_0_init>

	I2C_0_init();
     3e0:	f7ff ff7e 	bl	2e0 <I2C_0_init>

	USART_0_init();
     3e4:	f7ff ffc6 	bl	374 <USART_0_init>

	delay_driver_init();
     3e8:	f7ff ffdc 	bl	3a4 <delay_driver_init>
}
     3ec:	bd10      	pop	{r4, pc}
     3ee:	46c0      	nop			; (mov r8, r8)
     3f0:	41004400 	.word	0x41004400
     3f4:	c0000200 	.word	0xc0000200

000003f8 <button_on_PA24_pressed>:
#include  "mcp794xx_driver/mcp794xx_driver_basic.h"

extern mcp794xx_irq_callback_t mcp794x_irq_cb;

static void button_on_PA24_pressed(void)
{
     3f8:	b510      	push	{r4, lr}
     3fa:	4b04      	ldr	r3, [pc, #16]	; (40c <button_on_PA24_pressed+0x14>)
     3fc:	447b      	add	r3, pc
	mcp794xx_basic_irq_callBack(MCP794XX_ALARM1, mcp794x_irq_cb);
     3fe:	4a04      	ldr	r2, [pc, #16]	; (410 <button_on_PA24_pressed+0x18>)
     400:	589b      	ldr	r3, [r3, r2]
     402:	6819      	ldr	r1, [r3, #0]
     404:	2001      	movs	r0, #1
     406:	f004 f909 	bl	461c <mcp794xx_basic_irq_callBack>
}
     40a:	bd10      	pop	{r4, pc}
     40c:	000081cc 	.word	0x000081cc
     410:	0000005c 	.word	0x0000005c

00000414 <EXTERNAL_IRQ_0_example>:

/**
 * Example of using EXTERNAL_IRQ_0
 */
void EXTERNAL_IRQ_0_example(void)
{
     414:	b510      	push	{r4, lr}

	ext_irq_register(PIN_PA24, button_on_PA24_pressed);
     416:	4903      	ldr	r1, [pc, #12]	; (424 <EXTERNAL_IRQ_0_example+0x10>)
     418:	4479      	add	r1, pc
     41a:	2018      	movs	r0, #24
     41c:	f000 f85c 	bl	4d8 <ext_irq_register>
}
     420:	bd10      	pop	{r4, pc}
     422:	46c0      	nop			; (mov r8, r8)
     424:	ffffffdd 	.word	0xffffffdd

00000428 <delay_init>:

/**
 * \brief Initialize Delay driver
 */
void delay_init(void *const hw)
{
     428:	b510      	push	{r4, lr}
	_delay_init(hardware = hw);
     42a:	4b03      	ldr	r3, [pc, #12]	; (438 <delay_init+0x10>)
     42c:	447b      	add	r3, pc
     42e:	6018      	str	r0, [r3, #0]
     430:	f000 fff6 	bl	1420 <_delay_init>
}
     434:	bd10      	pop	{r4, pc}
     436:	46c0      	nop			; (mov r8, r8)
     438:	1ffffe2c 	.word	0x1ffffe2c

0000043c <delay_ms>:

/**
 * \brief Perform delay in ms
 */
void delay_ms(const uint16_t ms)
{
     43c:	b510      	push	{r4, lr}
	_delay_cycles(hardware, _get_cycles_for_ms(ms));
     43e:	4b05      	ldr	r3, [pc, #20]	; (454 <delay_ms+0x18>)
     440:	447b      	add	r3, pc
     442:	681c      	ldr	r4, [r3, #0]
     444:	f000 fa30 	bl	8a8 <_get_cycles_for_ms>
     448:	0001      	movs	r1, r0
     44a:	0020      	movs	r0, r4
     44c:	f000 ffec 	bl	1428 <_delay_cycles>
}
     450:	bd10      	pop	{r4, pc}
     452:	46c0      	nop			; (mov r8, r8)
     454:	1ffffe18 	.word	0x1ffffe18

00000458 <process_ext_irq>:
 * \brief Interrupt processing routine
 *
 * \param[in] pin The pin which triggered the interrupt
 */
static void process_ext_irq(const uint32_t pin)
{
     458:	b570      	push	{r4, r5, r6, lr}
	uint8_t lower = 0, middle, upper = EXT_IRQ_AMOUNT;
     45a:	2501      	movs	r5, #1
     45c:	2400      	movs	r4, #0

	while (upper >= lower) {
     45e:	e008      	b.n	472 <process_ext_irq+0x1a>
		if (middle >= EXT_IRQ_AMOUNT) {
			return;
		}

		if (ext_irqs[middle].pin == pin) {
			if (ext_irqs[middle].cb) {
     460:	4a0e      	ldr	r2, [pc, #56]	; (49c <process_ext_irq+0x44>)
     462:	447a      	add	r2, pc
     464:	58b3      	ldr	r3, [r6, r2]
     466:	2b00      	cmp	r3, #0
     468:	d000      	beq.n	46c <process_ext_irq+0x14>
				ext_irqs[middle].cb();
     46a:	4798      	blx	r3
			lower = middle + 1;
		} else {
			upper = middle - 1;
		}
	}
}
     46c:	bd70      	pop	{r4, r5, r6, pc}
			upper = middle - 1;
     46e:	3a01      	subs	r2, #1
     470:	b2d5      	uxtb	r5, r2
	while (upper >= lower) {
     472:	42ac      	cmp	r4, r5
     474:	d8fa      	bhi.n	46c <process_ext_irq+0x14>
		middle = (upper + lower) >> 1;
     476:	192b      	adds	r3, r5, r4
     478:	105b      	asrs	r3, r3, #1
     47a:	b2da      	uxtb	r2, r3
		if (middle >= EXT_IRQ_AMOUNT) {
     47c:	2a00      	cmp	r2, #0
     47e:	d1f5      	bne.n	46c <process_ext_irq+0x14>
     480:	21ff      	movs	r1, #255	; 0xff
     482:	400b      	ands	r3, r1
		if (ext_irqs[middle].pin == pin) {
     484:	00de      	lsls	r6, r3, #3
     486:	4906      	ldr	r1, [pc, #24]	; (4a0 <process_ext_irq+0x48>)
     488:	4479      	add	r1, pc
     48a:	1989      	adds	r1, r1, r6
     48c:	6849      	ldr	r1, [r1, #4]
     48e:	4281      	cmp	r1, r0
     490:	d0e6      	beq.n	460 <process_ext_irq+0x8>
		if (ext_irqs[middle].pin < pin) {
     492:	d2ec      	bcs.n	46e <process_ext_irq+0x16>
			lower = middle + 1;
     494:	3201      	adds	r2, #1
     496:	b2d4      	uxtb	r4, r2
     498:	e7eb      	b.n	472 <process_ext_irq+0x1a>
     49a:	46c0      	nop			; (mov r8, r8)
     49c:	1ffffdfa 	.word	0x1ffffdfa
     4a0:	1ffffdd4 	.word	0x1ffffdd4

000004a4 <ext_irq_init>:
{
     4a4:	b510      	push	{r4, lr}
	for (i = 0; i < EXT_IRQ_AMOUNT; i++) {
     4a6:	2300      	movs	r3, #0
     4a8:	2b00      	cmp	r3, #0
     4aa:	d004      	beq.n	4b6 <ext_irq_init+0x12>
	return _ext_irq_init(process_ext_irq);
     4ac:	4808      	ldr	r0, [pc, #32]	; (4d0 <ext_irq_init+0x2c>)
     4ae:	4478      	add	r0, pc
     4b0:	f000 fa14 	bl	8dc <_ext_irq_init>
}
     4b4:	bd10      	pop	{r4, pc}
		ext_irqs[i].pin = 0xFFFFFFFF;
     4b6:	4a07      	ldr	r2, [pc, #28]	; (4d4 <ext_irq_init+0x30>)
     4b8:	447a      	add	r2, pc
     4ba:	00d9      	lsls	r1, r3, #3
     4bc:	1850      	adds	r0, r2, r1
     4be:	2401      	movs	r4, #1
     4c0:	4264      	negs	r4, r4
     4c2:	6044      	str	r4, [r0, #4]
		ext_irqs[i].cb  = NULL;
     4c4:	2000      	movs	r0, #0
     4c6:	5088      	str	r0, [r1, r2]
	for (i = 0; i < EXT_IRQ_AMOUNT; i++) {
     4c8:	3301      	adds	r3, #1
     4ca:	b29b      	uxth	r3, r3
     4cc:	e7ec      	b.n	4a8 <ext_irq_init+0x4>
     4ce:	46c0      	nop			; (mov r8, r8)
     4d0:	ffffffa7 	.word	0xffffffa7
     4d4:	1ffffda4 	.word	0x1ffffda4

000004d8 <ext_irq_register>:
{
     4d8:	b5f0      	push	{r4, r5, r6, r7, lr}
     4da:	46c6      	mov	lr, r8
     4dc:	b500      	push	{lr}
     4de:	b084      	sub	sp, #16
     4e0:	9001      	str	r0, [sp, #4]
	uint8_t i = 0, j = 0;
     4e2:	2300      	movs	r3, #0
	for (; i < EXT_IRQ_AMOUNT; i++) {
     4e4:	2b00      	cmp	r3, #0
     4e6:	d011      	beq.n	50c <ext_irq_register+0x34>
	bool    found = false;
     4e8:	2300      	movs	r3, #0
     4ea:	4698      	mov	r8, r3
	if (NULL == cb) {
     4ec:	2900      	cmp	r1, #0
     4ee:	d01e      	beq.n	52e <ext_irq_register+0x56>
	if (!found) {
     4f0:	4643      	mov	r3, r8
     4f2:	2b00      	cmp	r3, #0
     4f4:	d14c      	bne.n	590 <ext_irq_register+0xb8>
		for (i = 0; i < EXT_IRQ_AMOUNT; i++) {
     4f6:	2b00      	cmp	r3, #0
     4f8:	d129      	bne.n	54e <ext_irq_register+0x76>
			if (NULL == ext_irqs[i].cb) {
     4fa:	00da      	lsls	r2, r3, #3
     4fc:	4c2d      	ldr	r4, [pc, #180]	; (5b4 <ext_irq_register+0xdc>)
     4fe:	447c      	add	r4, pc
     500:	5912      	ldr	r2, [r2, r4]
     502:	2a00      	cmp	r2, #0
     504:	d01a      	beq.n	53c <ext_irq_register+0x64>
		for (i = 0; i < EXT_IRQ_AMOUNT; i++) {
     506:	3301      	adds	r3, #1
     508:	b2db      	uxtb	r3, r3
     50a:	e7f4      	b.n	4f6 <ext_irq_register+0x1e>
		if (ext_irqs[i].pin == pin) {
     50c:	00dc      	lsls	r4, r3, #3
     50e:	4a2a      	ldr	r2, [pc, #168]	; (5b8 <ext_irq_register+0xe0>)
     510:	447a      	add	r2, pc
     512:	1912      	adds	r2, r2, r4
     514:	6852      	ldr	r2, [r2, #4]
     516:	9801      	ldr	r0, [sp, #4]
     518:	4282      	cmp	r2, r0
     51a:	d002      	beq.n	522 <ext_irq_register+0x4a>
	for (; i < EXT_IRQ_AMOUNT; i++) {
     51c:	3301      	adds	r3, #1
     51e:	b2db      	uxtb	r3, r3
     520:	e7e0      	b.n	4e4 <ext_irq_register+0xc>
			ext_irqs[i].cb = cb;
     522:	4b26      	ldr	r3, [pc, #152]	; (5bc <ext_irq_register+0xe4>)
     524:	447b      	add	r3, pc
     526:	50e1      	str	r1, [r4, r3]
			found          = true;
     528:	2301      	movs	r3, #1
     52a:	4698      	mov	r8, r3
			break;
     52c:	e7de      	b.n	4ec <ext_irq_register+0x14>
		if (!found) {
     52e:	4643      	mov	r3, r8
     530:	2b00      	cmp	r3, #0
     532:	d038      	beq.n	5a6 <ext_irq_register+0xce>
		return _ext_irq_enable(pin, false);
     534:	9801      	ldr	r0, [sp, #4]
     536:	f000 fa1d 	bl	974 <_ext_irq_enable>
     53a:	e030      	b.n	59e <ext_irq_register+0xc6>
				ext_irqs[i].cb  = cb;
     53c:	4a20      	ldr	r2, [pc, #128]	; (5c0 <ext_irq_register+0xe8>)
     53e:	447a      	add	r2, pc
     540:	00dd      	lsls	r5, r3, #3
     542:	50a9      	str	r1, [r5, r2]
				ext_irqs[i].pin = pin;
     544:	1955      	adds	r5, r2, r5
     546:	9a01      	ldr	r2, [sp, #4]
     548:	606a      	str	r2, [r5, #4]
				found           = true;
     54a:	2201      	movs	r2, #1
     54c:	4690      	mov	r8, r2
     54e:	2200      	movs	r2, #0
     550:	e001      	b.n	556 <ext_irq_register+0x7e>
		for (; (j < EXT_IRQ_AMOUNT) && (i < EXT_IRQ_AMOUNT); j++) {
     552:	3201      	adds	r2, #1
     554:	b2d2      	uxtb	r2, r2
     556:	0019      	movs	r1, r3
     558:	4311      	orrs	r1, r2
     55a:	d119      	bne.n	590 <ext_irq_register+0xb8>
			if ((ext_irqs[i].pin < ext_irqs[j].pin) && (ext_irqs[j].pin != 0xFFFFFFFF)) {
     55c:	4919      	ldr	r1, [pc, #100]	; (5c4 <ext_irq_register+0xec>)
     55e:	4479      	add	r1, pc
     560:	00dc      	lsls	r4, r3, #3
     562:	190c      	adds	r4, r1, r4
     564:	6867      	ldr	r7, [r4, #4]
     566:	00d4      	lsls	r4, r2, #3
     568:	1909      	adds	r1, r1, r4
     56a:	6849      	ldr	r1, [r1, #4]
     56c:	428f      	cmp	r7, r1
     56e:	d2f0      	bcs.n	552 <ext_irq_register+0x7a>
     570:	1c4c      	adds	r4, r1, #1
     572:	d0ee      	beq.n	552 <ext_irq_register+0x7a>
				struct ext_irq tmp = ext_irqs[j];
     574:	4f14      	ldr	r7, [pc, #80]	; (5c8 <ext_irq_register+0xf0>)
     576:	447f      	add	r7, pc
     578:	00d1      	lsls	r1, r2, #3
     57a:	46bc      	mov	ip, r7
     57c:	4461      	add	r1, ip
     57e:	af02      	add	r7, sp, #8
     580:	003e      	movs	r6, r7
     582:	c911      	ldmia	r1!, {r0, r4}
     584:	c611      	stmia	r6!, {r0, r4}
				ext_irqs[i] = tmp;
     586:	00dd      	lsls	r5, r3, #3
     588:	4465      	add	r5, ip
     58a:	cf03      	ldmia	r7!, {r0, r1}
     58c:	c503      	stmia	r5!, {r0, r1}
     58e:	e7e0      	b.n	552 <ext_irq_register+0x7a>
	if (!found) {
     590:	4643      	mov	r3, r8
     592:	2b00      	cmp	r3, #0
     594:	d00a      	beq.n	5ac <ext_irq_register+0xd4>
	return _ext_irq_enable(pin, true);
     596:	2101      	movs	r1, #1
     598:	9801      	ldr	r0, [sp, #4]
     59a:	f000 f9eb 	bl	974 <_ext_irq_enable>
}
     59e:	b004      	add	sp, #16
     5a0:	bc04      	pop	{r2}
     5a2:	4690      	mov	r8, r2
     5a4:	bdf0      	pop	{r4, r5, r6, r7, pc}
			return ERR_INVALID_ARG;
     5a6:	200d      	movs	r0, #13
     5a8:	4240      	negs	r0, r0
     5aa:	e7f8      	b.n	59e <ext_irq_register+0xc6>
		return ERR_INVALID_ARG;
     5ac:	200d      	movs	r0, #13
     5ae:	4240      	negs	r0, r0
     5b0:	e7f5      	b.n	59e <ext_irq_register+0xc6>
     5b2:	46c0      	nop			; (mov r8, r8)
     5b4:	1ffffd5e 	.word	0x1ffffd5e
     5b8:	1ffffd4c 	.word	0x1ffffd4c
     5bc:	1ffffd38 	.word	0x1ffffd38
     5c0:	1ffffd1e 	.word	0x1ffffd1e
     5c4:	1ffffcfe 	.word	0x1ffffcfe
     5c8:	1ffffce6 	.word	0x1ffffce6

000005cc <i2c_m_sync_write>:

/**
 * \brief Sync version of I2C I/O write
 */
static int32_t i2c_m_sync_write(struct io_descriptor *io, const uint8_t *buf, const uint16_t n)
{
     5cc:	b510      	push	{r4, lr}
     5ce:	b084      	sub	sp, #16
	struct i2c_m_sync_desc *i2c = CONTAINER_OF(io, struct i2c_m_sync_desc, io);
	struct _i2c_m_msg       msg;
	int32_t                 ret;

	msg.addr   = i2c->slave_addr;
     5d0:	3814      	subs	r0, #20
     5d2:	8b84      	ldrh	r4, [r0, #28]
     5d4:	ab01      	add	r3, sp, #4
     5d6:	801c      	strh	r4, [r3, #0]
	msg.len    = n;
     5d8:	0014      	movs	r4, r2
     5da:	9202      	str	r2, [sp, #8]
	msg.flags  = I2C_M_STOP;
     5dc:	4a06      	ldr	r2, [pc, #24]	; (5f8 <i2c_m_sync_write+0x2c>)
     5de:	805a      	strh	r2, [r3, #2]
	msg.buffer = (uint8_t *)buf;
     5e0:	9103      	str	r1, [sp, #12]

	ret = _i2c_m_sync_transfer(&i2c->device, &msg);
     5e2:	0019      	movs	r1, r3
     5e4:	f000 fd84 	bl	10f0 <_i2c_m_sync_transfer>

	if (ret) {
     5e8:	2800      	cmp	r0, #0
     5ea:	d102      	bne.n	5f2 <i2c_m_sync_write+0x26>
		return ret;
	}

	return n;
}
     5ec:	0020      	movs	r0, r4
     5ee:	b004      	add	sp, #16
     5f0:	bd10      	pop	{r4, pc}
		return ret;
     5f2:	0004      	movs	r4, r0
     5f4:	e7fa      	b.n	5ec <i2c_m_sync_write+0x20>
     5f6:	46c0      	nop			; (mov r8, r8)
     5f8:	ffff8000 	.word	0xffff8000

000005fc <i2c_m_sync_read>:
{
     5fc:	b510      	push	{r4, lr}
     5fe:	b084      	sub	sp, #16
	msg.addr   = i2c->slave_addr;
     600:	3814      	subs	r0, #20
     602:	8b84      	ldrh	r4, [r0, #28]
     604:	ab01      	add	r3, sp, #4
     606:	801c      	strh	r4, [r3, #0]
	msg.len    = n;
     608:	0014      	movs	r4, r2
     60a:	9202      	str	r2, [sp, #8]
	msg.flags  = I2C_M_STOP | I2C_M_RD;
     60c:	4a06      	ldr	r2, [pc, #24]	; (628 <i2c_m_sync_read+0x2c>)
     60e:	805a      	strh	r2, [r3, #2]
	msg.buffer = buf;
     610:	9103      	str	r1, [sp, #12]
	ret = _i2c_m_sync_transfer(&i2c->device, &msg);
     612:	0019      	movs	r1, r3
     614:	f000 fd6c 	bl	10f0 <_i2c_m_sync_transfer>
	if (ret) {
     618:	2800      	cmp	r0, #0
     61a:	d102      	bne.n	622 <i2c_m_sync_read+0x26>
}
     61c:	0020      	movs	r0, r4
     61e:	b004      	add	sp, #16
     620:	bd10      	pop	{r4, pc}
		return ret;
     622:	0004      	movs	r4, r0
     624:	e7fa      	b.n	61c <i2c_m_sync_read+0x20>
     626:	46c0      	nop			; (mov r8, r8)
     628:	ffff8001 	.word	0xffff8001

0000062c <i2c_m_sync_init>:

/**
 * \brief Sync version of i2c initialize
 */
int32_t i2c_m_sync_init(struct i2c_m_sync_desc *i2c, void *hw)
{
     62c:	b570      	push	{r4, r5, r6, lr}
     62e:	0004      	movs	r4, r0
     630:	000d      	movs	r5, r1
	int32_t init_status;
	ASSERT(i2c);
     632:	1e43      	subs	r3, r0, #1
     634:	4198      	sbcs	r0, r3
     636:	b2c0      	uxtb	r0, r0
     638:	225e      	movs	r2, #94	; 0x5e
     63a:	4908      	ldr	r1, [pc, #32]	; (65c <i2c_m_sync_init+0x30>)
     63c:	4479      	add	r1, pc
     63e:	f000 f90d 	bl	85c <assert>

	init_status = _i2c_m_sync_init(&i2c->device, hw);
     642:	0029      	movs	r1, r5
     644:	0020      	movs	r0, r4
     646:	f000 fcfd 	bl	1044 <_i2c_m_sync_init>
	if (init_status) {
     64a:	2800      	cmp	r0, #0
     64c:	d105      	bne.n	65a <i2c_m_sync_init+0x2e>
		return init_status;
	}

	/* Init I/O */
	i2c->io.read  = i2c_m_sync_read;
     64e:	4b04      	ldr	r3, [pc, #16]	; (660 <i2c_m_sync_init+0x34>)
     650:	447b      	add	r3, pc
     652:	61a3      	str	r3, [r4, #24]
	i2c->io.write = i2c_m_sync_write;
     654:	4b03      	ldr	r3, [pc, #12]	; (664 <i2c_m_sync_init+0x38>)
     656:	447b      	add	r3, pc
     658:	6163      	str	r3, [r4, #20]

	return ERR_NONE;
}
     65a:	bd70      	pop	{r4, r5, r6, pc}
     65c:	000065ac 	.word	0x000065ac
     660:	ffffffa9 	.word	0xffffffa9
     664:	ffffff73 	.word	0xffffff73

00000668 <i2c_m_sync_enable>:

/**
 * \brief Sync version of i2c enable
 */
int32_t i2c_m_sync_enable(struct i2c_m_sync_desc *i2c)
{
     668:	b510      	push	{r4, lr}
	return _i2c_m_sync_enable(&i2c->device);
     66a:	f000 fd01 	bl	1070 <_i2c_m_sync_enable>
}
     66e:	bd10      	pop	{r4, pc}

00000670 <i2c_m_sync_set_slaveaddr>:
/**
 * \brief Sync version of i2c set slave address
 */
int32_t i2c_m_sync_set_slaveaddr(struct i2c_m_sync_desc *i2c, int16_t addr, int32_t addr_len)
{
	return i2c->slave_addr = (addr & 0x3ff) | (addr_len & I2C_M_TEN);
     670:	0589      	lsls	r1, r1, #22
     672:	0d89      	lsrs	r1, r1, #22
     674:	2380      	movs	r3, #128	; 0x80
     676:	00db      	lsls	r3, r3, #3
     678:	401a      	ands	r2, r3
     67a:	430a      	orrs	r2, r1
     67c:	8382      	strh	r2, [r0, #28]
}
     67e:	0010      	movs	r0, r2
     680:	4770      	bx	lr

00000682 <i2c_m_sync_get_io_descriptor>:
/**
 * \brief Retrieve I/O descriptor
 */
int32_t i2c_m_sync_get_io_descriptor(struct i2c_m_sync_desc *const i2c, struct io_descriptor **io)
{
	*io = &i2c->io;
     682:	3014      	adds	r0, #20
     684:	6008      	str	r0, [r1, #0]
	return ERR_NONE;
}
     686:	2000      	movs	r0, #0
     688:	4770      	bx	lr
	...

0000068c <io_write>:

/**
 * \brief I/O write interface
 */
int32_t io_write(struct io_descriptor *const io_descr, const uint8_t *const buf, const uint16_t length)
{
     68c:	b570      	push	{r4, r5, r6, lr}
     68e:	0004      	movs	r4, r0
     690:	000d      	movs	r5, r1
     692:	0016      	movs	r6, r2
	ASSERT(io_descr && buf);
     694:	2800      	cmp	r0, #0
     696:	d00f      	beq.n	6b8 <io_write+0x2c>
     698:	2900      	cmp	r1, #0
     69a:	d00b      	beq.n	6b4 <io_write+0x28>
     69c:	2001      	movs	r0, #1
     69e:	2234      	movs	r2, #52	; 0x34
     6a0:	4906      	ldr	r1, [pc, #24]	; (6bc <io_write+0x30>)
     6a2:	4479      	add	r1, pc
     6a4:	f000 f8da 	bl	85c <assert>
	return io_descr->write(io_descr, buf, length);
     6a8:	6823      	ldr	r3, [r4, #0]
     6aa:	0032      	movs	r2, r6
     6ac:	0029      	movs	r1, r5
     6ae:	0020      	movs	r0, r4
     6b0:	4798      	blx	r3
}
     6b2:	bd70      	pop	{r4, r5, r6, pc}
	ASSERT(io_descr && buf);
     6b4:	2000      	movs	r0, #0
     6b6:	e7f2      	b.n	69e <io_write+0x12>
     6b8:	2000      	movs	r0, #0
     6ba:	e7f0      	b.n	69e <io_write+0x12>
     6bc:	00006562 	.word	0x00006562

000006c0 <io_read>:

/**
 * \brief I/O read interface
 */
int32_t io_read(struct io_descriptor *const io_descr, uint8_t *const buf, const uint16_t length)
{
     6c0:	b570      	push	{r4, r5, r6, lr}
     6c2:	0004      	movs	r4, r0
     6c4:	000d      	movs	r5, r1
     6c6:	0016      	movs	r6, r2
	ASSERT(io_descr && buf);
     6c8:	2800      	cmp	r0, #0
     6ca:	d00f      	beq.n	6ec <io_read+0x2c>
     6cc:	2900      	cmp	r1, #0
     6ce:	d00b      	beq.n	6e8 <io_read+0x28>
     6d0:	2001      	movs	r0, #1
     6d2:	223d      	movs	r2, #61	; 0x3d
     6d4:	4906      	ldr	r1, [pc, #24]	; (6f0 <io_read+0x30>)
     6d6:	4479      	add	r1, pc
     6d8:	f000 f8c0 	bl	85c <assert>
	return io_descr->read(io_descr, buf, length);
     6dc:	6863      	ldr	r3, [r4, #4]
     6de:	0032      	movs	r2, r6
     6e0:	0029      	movs	r1, r5
     6e2:	0020      	movs	r0, r4
     6e4:	4798      	blx	r3
}
     6e6:	bd70      	pop	{r4, r5, r6, pc}
	ASSERT(io_descr && buf);
     6e8:	2000      	movs	r0, #0
     6ea:	e7f2      	b.n	6d2 <io_read+0x12>
     6ec:	2000      	movs	r0, #0
     6ee:	e7f0      	b.n	6d2 <io_read+0x12>
     6f0:	0000652e 	.word	0x0000652e

000006f4 <usart_sync_write>:
 * \param[in] length The number of bytes to write
 *
 * \return The number of bytes written.
 */
static int32_t usart_sync_write(struct io_descriptor *const io_descr, const uint8_t *const buf, const uint16_t length)
{
     6f4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
     6f6:	0005      	movs	r5, r0
     6f8:	000e      	movs	r6, r1
     6fa:	0017      	movs	r7, r2
	uint32_t                      offset = 0;
	struct usart_sync_descriptor *descr  = CONTAINER_OF(io_descr, struct usart_sync_descriptor, io);

	ASSERT(io_descr && buf && length);
     6fc:	2800      	cmp	r0, #0
     6fe:	d024      	beq.n	74a <usart_sync_write+0x56>
     700:	2900      	cmp	r1, #0
     702:	d024      	beq.n	74e <usart_sync_write+0x5a>
     704:	2a00      	cmp	r2, #0
     706:	d124      	bne.n	752 <usart_sync_write+0x5e>
     708:	2000      	movs	r0, #0
     70a:	22f1      	movs	r2, #241	; 0xf1
     70c:	4912      	ldr	r1, [pc, #72]	; (758 <usart_sync_write+0x64>)
     70e:	4479      	add	r1, pc
     710:	f000 f8a4 	bl	85c <assert>
	while (!_usart_sync_is_ready_to_send(&descr->device))
     714:	002c      	movs	r4, r5
     716:	3408      	adds	r4, #8
     718:	0020      	movs	r0, r4
     71a:	f000 fc82 	bl	1022 <_usart_sync_is_ready_to_send>
     71e:	2800      	cmp	r0, #0
     720:	d0f8      	beq.n	714 <usart_sync_write+0x20>
     722:	2500      	movs	r5, #0
		;
	do {
		_usart_sync_write_byte(&descr->device, buf[offset]);
     724:	5d71      	ldrb	r1, [r6, r5]
     726:	0020      	movs	r0, r4
     728:	f000 fc73 	bl	1012 <_usart_sync_write_byte>
		while (!_usart_sync_is_ready_to_send(&descr->device))
     72c:	0020      	movs	r0, r4
     72e:	f000 fc78 	bl	1022 <_usart_sync_is_ready_to_send>
     732:	2800      	cmp	r0, #0
     734:	d0fa      	beq.n	72c <usart_sync_write+0x38>
			;
	} while (++offset < length);
     736:	3501      	adds	r5, #1
     738:	42bd      	cmp	r5, r7
     73a:	d3f3      	bcc.n	724 <usart_sync_write+0x30>
	while (!_usart_sync_is_transmit_done(&descr->device))
     73c:	0020      	movs	r0, r4
     73e:	f000 fc75 	bl	102c <_usart_sync_is_transmit_done>
     742:	2800      	cmp	r0, #0
     744:	d0fa      	beq.n	73c <usart_sync_write+0x48>
		;
	return (int32_t)offset;
}
     746:	0028      	movs	r0, r5
     748:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	ASSERT(io_descr && buf && length);
     74a:	2000      	movs	r0, #0
     74c:	e7dd      	b.n	70a <usart_sync_write+0x16>
     74e:	2000      	movs	r0, #0
     750:	e7db      	b.n	70a <usart_sync_write+0x16>
     752:	2001      	movs	r0, #1
     754:	e7d9      	b.n	70a <usart_sync_write+0x16>
     756:	46c0      	nop			; (mov r8, r8)
     758:	0000650a 	.word	0x0000650a

0000075c <usart_sync_read>:
 * \param[in] length The size of a buffer
 *
 * \return The number of bytes read.
 */
static int32_t usart_sync_read(struct io_descriptor *const io_descr, uint8_t *const buf, const uint16_t length)
{
     75c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
     75e:	46ce      	mov	lr, r9
     760:	4647      	mov	r7, r8
     762:	b580      	push	{r7, lr}
     764:	1e05      	subs	r5, r0, #0
     766:	4688      	mov	r8, r1
     768:	4691      	mov	r9, r2
	uint32_t                      offset = 0;
	struct usart_sync_descriptor *descr  = CONTAINER_OF(io_descr, struct usart_sync_descriptor, io);

	ASSERT(io_descr && buf && length);
     76a:	d020      	beq.n	7ae <usart_sync_read+0x52>
     76c:	2900      	cmp	r1, #0
     76e:	d020      	beq.n	7b2 <usart_sync_read+0x56>
     770:	2a00      	cmp	r2, #0
     772:	d120      	bne.n	7b6 <usart_sync_read+0x5a>
     774:	2000      	movs	r0, #0
     776:	2286      	movs	r2, #134	; 0x86
     778:	0052      	lsls	r2, r2, #1
     77a:	4910      	ldr	r1, [pc, #64]	; (7bc <usart_sync_read+0x60>)
     77c:	4479      	add	r1, pc
     77e:	f000 f86d 	bl	85c <assert>
	uint32_t                      offset = 0;
     782:	2600      	movs	r6, #0
	do {
		while (!_usart_sync_is_byte_received(&descr->device))
     784:	002c      	movs	r4, r5
     786:	3408      	adds	r4, #8
     788:	0020      	movs	r0, r4
     78a:	f000 fc55 	bl	1038 <_usart_sync_is_byte_received>
     78e:	2800      	cmp	r0, #0
     790:	d0f8      	beq.n	784 <usart_sync_read+0x28>
			;
		buf[offset] = _usart_sync_read_byte(&descr->device);
     792:	4643      	mov	r3, r8
     794:	199f      	adds	r7, r3, r6
     796:	0020      	movs	r0, r4
     798:	f000 fc3f 	bl	101a <_usart_sync_read_byte>
     79c:	7038      	strb	r0, [r7, #0]
	} while (++offset < length);
     79e:	3601      	adds	r6, #1
     7a0:	454e      	cmp	r6, r9
     7a2:	d3ef      	bcc.n	784 <usart_sync_read+0x28>

	return (int32_t)offset;
}
     7a4:	0030      	movs	r0, r6
     7a6:	bc0c      	pop	{r2, r3}
     7a8:	4690      	mov	r8, r2
     7aa:	4699      	mov	r9, r3
     7ac:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	ASSERT(io_descr && buf && length);
     7ae:	2000      	movs	r0, #0
     7b0:	e7e1      	b.n	776 <usart_sync_read+0x1a>
     7b2:	2000      	movs	r0, #0
     7b4:	e7df      	b.n	776 <usart_sync_read+0x1a>
     7b6:	2001      	movs	r0, #1
     7b8:	e7dd      	b.n	776 <usart_sync_read+0x1a>
     7ba:	46c0      	nop			; (mov r8, r8)
     7bc:	0000649c 	.word	0x0000649c

000007c0 <usart_sync_init>:
{
     7c0:	b570      	push	{r4, r5, r6, lr}
     7c2:	0004      	movs	r4, r0
     7c4:	000d      	movs	r5, r1
	ASSERT(descr && hw);
     7c6:	2800      	cmp	r0, #0
     7c8:	d017      	beq.n	7fa <usart_sync_init+0x3a>
     7ca:	2900      	cmp	r1, #0
     7cc:	d013      	beq.n	7f6 <usart_sync_init+0x36>
     7ce:	2001      	movs	r0, #1
     7d0:	2234      	movs	r2, #52	; 0x34
     7d2:	490b      	ldr	r1, [pc, #44]	; (800 <usart_sync_init+0x40>)
     7d4:	4479      	add	r1, pc
     7d6:	f000 f841 	bl	85c <assert>
	init_status = _usart_sync_init(&descr->device, hw);
     7da:	0020      	movs	r0, r4
     7dc:	3008      	adds	r0, #8
     7de:	0029      	movs	r1, r5
     7e0:	f000 fbfc 	bl	fdc <_usart_sync_init>
	if (init_status) {
     7e4:	2800      	cmp	r0, #0
     7e6:	d105      	bne.n	7f4 <usart_sync_init+0x34>
	descr->io.read  = usart_sync_read;
     7e8:	4b06      	ldr	r3, [pc, #24]	; (804 <usart_sync_init+0x44>)
     7ea:	447b      	add	r3, pc
     7ec:	6063      	str	r3, [r4, #4]
	descr->io.write = usart_sync_write;
     7ee:	4b06      	ldr	r3, [pc, #24]	; (808 <usart_sync_init+0x48>)
     7f0:	447b      	add	r3, pc
     7f2:	6023      	str	r3, [r4, #0]
}
     7f4:	bd70      	pop	{r4, r5, r6, pc}
	ASSERT(descr && hw);
     7f6:	2000      	movs	r0, #0
     7f8:	e7ea      	b.n	7d0 <usart_sync_init+0x10>
     7fa:	2000      	movs	r0, #0
     7fc:	e7e8      	b.n	7d0 <usart_sync_init+0x10>
     7fe:	46c0      	nop			; (mov r8, r8)
     800:	00006444 	.word	0x00006444
     804:	ffffff6f 	.word	0xffffff6f
     808:	ffffff01 	.word	0xffffff01

0000080c <usart_sync_enable>:
{
     80c:	b510      	push	{r4, lr}
     80e:	0004      	movs	r4, r0
	ASSERT(descr);
     810:	1e43      	subs	r3, r0, #1
     812:	4198      	sbcs	r0, r3
     814:	b2c0      	uxtb	r0, r0
     816:	2253      	movs	r2, #83	; 0x53
     818:	4904      	ldr	r1, [pc, #16]	; (82c <usart_sync_enable+0x20>)
     81a:	4479      	add	r1, pc
     81c:	f000 f81e 	bl	85c <assert>
	_usart_sync_enable(&descr->device);
     820:	0020      	movs	r0, r4
     822:	3008      	adds	r0, #8
     824:	f000 fbec 	bl	1000 <_usart_sync_enable>
}
     828:	2000      	movs	r0, #0
     82a:	bd10      	pop	{r4, pc}
     82c:	000063fe 	.word	0x000063fe

00000830 <usart_sync_get_io_descriptor>:
{
     830:	b570      	push	{r4, r5, r6, lr}
     832:	0004      	movs	r4, r0
     834:	000d      	movs	r5, r1
	ASSERT(descr && io);
     836:	2800      	cmp	r0, #0
     838:	d00c      	beq.n	854 <usart_sync_get_io_descriptor+0x24>
     83a:	2900      	cmp	r1, #0
     83c:	d008      	beq.n	850 <usart_sync_get_io_descriptor+0x20>
     83e:	2001      	movs	r0, #1
     840:	2269      	movs	r2, #105	; 0x69
     842:	4905      	ldr	r1, [pc, #20]	; (858 <usart_sync_get_io_descriptor+0x28>)
     844:	4479      	add	r1, pc
     846:	f000 f809 	bl	85c <assert>
	*io = &descr->io;
     84a:	602c      	str	r4, [r5, #0]
}
     84c:	2000      	movs	r0, #0
     84e:	bd70      	pop	{r4, r5, r6, pc}
	ASSERT(descr && io);
     850:	2000      	movs	r0, #0
     852:	e7f5      	b.n	840 <usart_sync_get_io_descriptor+0x10>
     854:	2000      	movs	r0, #0
     856:	e7f3      	b.n	840 <usart_sync_get_io_descriptor+0x10>
     858:	000063d4 	.word	0x000063d4

0000085c <assert>:
/**
 * \brief Assert function
 */
void assert(const bool condition, const char *const file, const int line)
{
	if (!(condition)) {
     85c:	2800      	cmp	r0, #0
     85e:	d100      	bne.n	862 <assert+0x6>
		__asm("BKPT #0");
     860:	be00      	bkpt	0x0000
	}
	(void)file;
	(void)line;
}
     862:	4770      	bx	lr

00000864 <_sbrk>:

/**
 * \brief Replacement of C library of _sbrk
 */
extern caddr_t _sbrk(int incr)
{
     864:	b082      	sub	sp, #8
     866:	0003      	movs	r3, r0
     868:	4a0a      	ldr	r2, [pc, #40]	; (894 <_sbrk+0x30>)
     86a:	447a      	add	r2, pc
	static unsigned char *heap = NULL;
	unsigned char *       prev_heap;

	if (heap == NULL) {
     86c:	490a      	ldr	r1, [pc, #40]	; (898 <_sbrk+0x34>)
     86e:	4479      	add	r1, pc
     870:	6809      	ldr	r1, [r1, #0]
     872:	2900      	cmp	r1, #0
     874:	d006      	beq.n	884 <_sbrk+0x20>
		heap = (unsigned char *)&_end;
	}
	prev_heap = heap;
     876:	4a09      	ldr	r2, [pc, #36]	; (89c <_sbrk+0x38>)
     878:	447a      	add	r2, pc
     87a:	6810      	ldr	r0, [r2, #0]

	heap += incr;
     87c:	18c3      	adds	r3, r0, r3
     87e:	6013      	str	r3, [r2, #0]

	return (caddr_t)prev_heap;
}
     880:	b002      	add	sp, #8
     882:	4770      	bx	lr
		heap = (unsigned char *)&_end;
     884:	4906      	ldr	r1, [pc, #24]	; (8a0 <_sbrk+0x3c>)
     886:	5852      	ldr	r2, [r2, r1]
     888:	9201      	str	r2, [sp, #4]
     88a:	4a06      	ldr	r2, [pc, #24]	; (8a4 <_sbrk+0x40>)
     88c:	447a      	add	r2, pc
     88e:	9901      	ldr	r1, [sp, #4]
     890:	6011      	str	r1, [r2, #0]
     892:	e7f0      	b.n	876 <_sbrk+0x12>
     894:	00007d5e 	.word	0x00007d5e
     898:	1ffff9f6 	.word	0x1ffff9f6
     89c:	1ffff9ec 	.word	0x1ffff9ec
     8a0:	0000007c 	.word	0x0000007c
     8a4:	1ffff9d8 	.word	0x1ffff9d8

000008a8 <_get_cycles_for_ms>:
 */
static inline uint32_t _get_cycles_for_ms_internal(const uint16_t ms, const uint32_t freq, const uint8_t power)
{
	switch (power) {
	case 8:
		return (ms * (freq / 100000)) * 100;
     8a8:	0103      	lsls	r3, r0, #4
     8aa:	1a1b      	subs	r3, r3, r0
     8ac:	011a      	lsls	r2, r3, #4
     8ae:	2064      	movs	r0, #100	; 0x64
     8b0:	4350      	muls	r0, r2
 * \brief Retrieve the amount of cycles to delay for the given amount of ms
 */
uint32_t _get_cycles_for_ms(const uint16_t ms)
{
	return _get_cycles_for_ms_internal(ms, CONF_CPU_FREQUENCY, CPU_FREQ_POWER);
}
     8b2:	4770      	bx	lr

000008b4 <_init_chip>:

/**
 * \brief Initialize the hardware abstraction layer
 */
void _init_chip(void)
{
     8b4:	b510      	push	{r4, lr}
}

static inline void hri_nvmctrl_set_CTRLB_RWS_bf(const void *const hw, hri_nvmctrl_ctrlb_reg_t mask)
{
	NVMCTRL_CRITICAL_SECTION_ENTER();
	((Nvmctrl *)hw)->CTRLB.reg |= NVMCTRL_CTRLB_RWS(mask);
     8b6:	4b08      	ldr	r3, [pc, #32]	; (8d8 <_init_chip+0x24>)
     8b8:	685a      	ldr	r2, [r3, #4]
     8ba:	605a      	str	r2, [r3, #4]
	hri_nvmctrl_set_CTRLB_RWS_bf(NVMCTRL, CONF_NVM_WAIT_STATE);

	_pm_init();
     8bc:	f000 f8fe 	bl	abc <_pm_init>
	_sysctrl_init_sources();
     8c0:	f000 fd54 	bl	136c <_sysctrl_init_sources>
#if _GCLK_INIT_1ST
	_gclk_init_generators_by_fref(_GCLK_INIT_1ST);
     8c4:	2002      	movs	r0, #2
     8c6:	f000 f8d9 	bl	a7c <_gclk_init_generators_by_fref>
#endif
	_sysctrl_init_referenced_generators();
     8ca:	f000 fd5b 	bl	1384 <_sysctrl_init_referenced_generators>
	_gclk_init_generators_by_fref(_GCLK_INIT_LAST);
     8ce:	20fd      	movs	r0, #253	; 0xfd
     8d0:	f000 f8d4 	bl	a7c <_gclk_init_generators_by_fref>
#if CONF_DMAC_ENABLE
	_pm_enable_bus_clock(PM_BUS_AHB, DMAC);
	_pm_enable_bus_clock(PM_BUS_APBB, DMAC);
	_dma_init();
#endif
}
     8d4:	bd10      	pop	{r4, pc}
     8d6:	46c0      	nop			; (mov r8, r8)
     8d8:	41004000 	.word	0x41004000

000008dc <_ext_irq_init>:
typedef uint8_t  hri_eic_nmiflag_reg_t;
typedef uint8_t  hri_eic_status_reg_t;

static inline void hri_eic_wait_for_sync(const void *const hw)
{
	while (((const Eic *)hw)->STATUS.bit.SYNCBUSY)
     8dc:	4b22      	ldr	r3, [pc, #136]	; (968 <_ext_irq_init+0x8c>)
     8de:	785b      	ldrb	r3, [r3, #1]
     8e0:	09db      	lsrs	r3, r3, #7
     8e2:	d1fb      	bne.n	8dc <_ext_irq_init>
     8e4:	4b20      	ldr	r3, [pc, #128]	; (968 <_ext_irq_init+0x8c>)
     8e6:	785b      	ldrb	r3, [r3, #1]
     8e8:	09db      	lsrs	r3, r3, #7
     8ea:	d1fb      	bne.n	8e4 <_ext_irq_init+0x8>

static inline hri_eic_ctrl_reg_t hri_eic_get_CTRL_reg(const void *const hw, hri_eic_ctrl_reg_t mask)
{
	uint8_t tmp;
	hri_eic_wait_for_sync(hw);
	tmp = ((Eic *)hw)->CTRL.reg;
     8ec:	4b1e      	ldr	r3, [pc, #120]	; (968 <_ext_irq_init+0x8c>)
     8ee:	781b      	ldrb	r3, [r3, #0]
 * \brief Initialize external interrupt module
 */
int32_t _ext_irq_init(void (*cb)(const uint32_t pin))
{
	hri_eic_wait_for_sync(EIC);
	if (hri_eic_get_CTRL_reg(EIC, EIC_CTRL_ENABLE)) {
     8f0:	079b      	lsls	r3, r3, #30
     8f2:	d50a      	bpl.n	90a <_ext_irq_init+0x2e>
}

static inline void hri_eic_write_CTRL_reg(const void *const hw, hri_eic_ctrl_reg_t data)
{
	EIC_CRITICAL_SECTION_ENTER();
	((Eic *)hw)->CTRL.reg = data;
     8f4:	2200      	movs	r2, #0
     8f6:	4b1c      	ldr	r3, [pc, #112]	; (968 <_ext_irq_init+0x8c>)
     8f8:	701a      	strb	r2, [r3, #0]
	while (((const Eic *)hw)->STATUS.bit.SYNCBUSY)
     8fa:	4b1b      	ldr	r3, [pc, #108]	; (968 <_ext_irq_init+0x8c>)
     8fc:	785b      	ldrb	r3, [r3, #1]
     8fe:	09db      	lsrs	r3, r3, #7
     900:	d1fb      	bne.n	8fa <_ext_irq_init+0x1e>
     902:	4b19      	ldr	r3, [pc, #100]	; (968 <_ext_irq_init+0x8c>)
     904:	785b      	ldrb	r3, [r3, #1]
     906:	09db      	lsrs	r3, r3, #7
     908:	d1fb      	bne.n	902 <_ext_irq_init+0x26>
	((Eic *)hw)->CTRL.reg = data;
     90a:	2201      	movs	r2, #1
     90c:	4b16      	ldr	r3, [pc, #88]	; (968 <_ext_irq_init+0x8c>)
     90e:	701a      	strb	r2, [r3, #0]
	while (((const Eic *)hw)->STATUS.bit.SYNCBUSY)
     910:	4b15      	ldr	r3, [pc, #84]	; (968 <_ext_irq_init+0x8c>)
     912:	785b      	ldrb	r3, [r3, #1]
     914:	09db      	lsrs	r3, r3, #7
     916:	d1fb      	bne.n	910 <_ext_irq_init+0x34>
     918:	4b13      	ldr	r3, [pc, #76]	; (968 <_ext_irq_init+0x8c>)
     91a:	785b      	ldrb	r3, [r3, #1]
     91c:	09db      	lsrs	r3, r3, #7
     91e:	d1fb      	bne.n	918 <_ext_irq_init+0x3c>
}

static inline void hri_eic_write_NMICTRL_reg(const void *const hw, hri_eic_nmictrl_reg_t data)
{
	EIC_CRITICAL_SECTION_ENTER();
	((Eic *)hw)->NMICTRL.reg = data;
     920:	4b11      	ldr	r3, [pc, #68]	; (968 <_ext_irq_init+0x8c>)
     922:	2200      	movs	r2, #0
     924:	709a      	strb	r2, [r3, #2]
}

static inline void hri_eic_write_EVCTRL_reg(const void *const hw, hri_eic_evctrl_reg_t data)
{
	EIC_CRITICAL_SECTION_ENTER();
	((Eic *)hw)->EVCTRL.reg = data;
     926:	605a      	str	r2, [r3, #4]
}

static inline void hri_eic_write_WAKEUP_reg(const void *const hw, hri_eic_wakeup_reg_t data)
{
	EIC_CRITICAL_SECTION_ENTER();
	((Eic *)hw)->WAKEUP.reg = data;
     928:	615a      	str	r2, [r3, #20]
}

static inline void hri_eic_write_CONFIG_reg(const void *const hw, uint8_t index, hri_eic_config_reg_t data)
{
	EIC_CRITICAL_SECTION_ENTER();
	((Eic *)hw)->CONFIG[index].reg = data;
     92a:	619a      	str	r2, [r3, #24]
     92c:	2280      	movs	r2, #128	; 0x80
     92e:	0292      	lsls	r2, r2, #10
     930:	61da      	str	r2, [r3, #28]
	((Eic *)hw)->CTRL.reg |= EIC_CTRL_ENABLE;
     932:	781a      	ldrb	r2, [r3, #0]
     934:	2102      	movs	r1, #2
     936:	430a      	orrs	r2, r1
     938:	b2d2      	uxtb	r2, r2
     93a:	701a      	strb	r2, [r3, #0]
	while (((const Eic *)hw)->STATUS.bit.SYNCBUSY)
     93c:	4b0a      	ldr	r3, [pc, #40]	; (968 <_ext_irq_init+0x8c>)
     93e:	785b      	ldrb	r3, [r3, #1]
     940:	09db      	lsrs	r3, r3, #7
     942:	d1fb      	bne.n	93c <_ext_irq_init+0x60>
 */
__STATIC_INLINE void __NVIC_DisableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->ICER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
     944:	4b09      	ldr	r3, [pc, #36]	; (96c <_ext_irq_init+0x90>)
     946:	2210      	movs	r2, #16
     948:	2180      	movs	r1, #128	; 0x80
     94a:	505a      	str	r2, [r3, r1]
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
     94c:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
     950:	f3bf 8f6f 	isb	sy
 */
__STATIC_INLINE void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->ICPR[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
     954:	3101      	adds	r1, #1
     956:	31ff      	adds	r1, #255	; 0xff
     958:	505a      	str	r2, [r3, r1]
    NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
     95a:	601a      	str	r2, [r3, #0]

	NVIC_DisableIRQ(EIC_IRQn);
	NVIC_ClearPendingIRQ(EIC_IRQn);
	NVIC_EnableIRQ(EIC_IRQn);

	callback = cb;
     95c:	4b04      	ldr	r3, [pc, #16]	; (970 <_ext_irq_init+0x94>)
     95e:	447b      	add	r3, pc
     960:	6018      	str	r0, [r3, #0]

	return ERR_NONE;
}
     962:	2000      	movs	r0, #0
     964:	4770      	bx	lr
     966:	46c0      	nop			; (mov r8, r8)
     968:	40001800 	.word	0x40001800
     96c:	e000e100 	.word	0xe000e100
     970:	1ffff90a 	.word	0x1ffff90a

00000974 <_ext_irq_enable>:
 * \brief Enable / disable external irq
 */
int32_t _ext_irq_enable(const uint32_t pin, const bool enable)
{
	uint8_t extint = INVALID_EXTINT_NUMBER;
	uint8_t i      = 0;
     974:	2300      	movs	r3, #0

	for (; i < ARRAY_SIZE(_map); i++) {
     976:	2b00      	cmp	r3, #0
     978:	d00b      	beq.n	992 <_ext_irq_enable+0x1e>
	uint8_t extint = INVALID_EXTINT_NUMBER;
     97a:	22ff      	movs	r2, #255	; 0xff
		if (_map[i].pin == pin) {
			extint = _map[i].extint;
			break;
		}
	}
	if (INVALID_EXTINT_NUMBER == extint) {
     97c:	2aff      	cmp	r2, #255	; 0xff
     97e:	d018      	beq.n	9b2 <_ext_irq_enable+0x3e>
		return ERR_INVALID_ARG;
	}

	if (enable) {
     980:	2900      	cmp	r1, #0
     982:	d110      	bne.n	9a6 <_ext_irq_enable+0x32>
		hri_eic_set_INTEN_reg(EIC, 1ul << extint);
	} else {
		hri_eic_clear_INTEN_reg(EIC, 1ul << extint);
     984:	2301      	movs	r3, #1
     986:	4093      	lsls	r3, r2
	((Eic *)hw)->INTENCLR.reg = mask;
     988:	4a0b      	ldr	r2, [pc, #44]	; (9b8 <_ext_irq_enable+0x44>)
     98a:	6093      	str	r3, [r2, #8]
	((Eic *)hw)->INTFLAG.reg = mask;
     98c:	6113      	str	r3, [r2, #16]
		hri_eic_clear_INTFLAG_reg(EIC, 1ul << extint);
	}

	return ERR_NONE;
     98e:	2000      	movs	r0, #0
}
     990:	4770      	bx	lr
		if (_map[i].pin == pin) {
     992:	2818      	cmp	r0, #24
     994:	d002      	beq.n	99c <_ext_irq_enable+0x28>
	for (; i < ARRAY_SIZE(_map); i++) {
     996:	3301      	adds	r3, #1
     998:	b2db      	uxtb	r3, r3
     99a:	e7ec      	b.n	976 <_ext_irq_enable+0x2>
			extint = _map[i].extint;
     99c:	00da      	lsls	r2, r3, #3
     99e:	4b07      	ldr	r3, [pc, #28]	; (9bc <_ext_irq_enable+0x48>)
     9a0:	447b      	add	r3, pc
     9a2:	5cd2      	ldrb	r2, [r2, r3]
			break;
     9a4:	e7ea      	b.n	97c <_ext_irq_enable+0x8>
		hri_eic_set_INTEN_reg(EIC, 1ul << extint);
     9a6:	2301      	movs	r3, #1
     9a8:	4093      	lsls	r3, r2
	((Eic *)hw)->INTENSET.reg = mask;
     9aa:	4a03      	ldr	r2, [pc, #12]	; (9b8 <_ext_irq_enable+0x44>)
     9ac:	60d3      	str	r3, [r2, #12]
	return ERR_NONE;
     9ae:	2000      	movs	r0, #0
     9b0:	e7ee      	b.n	990 <_ext_irq_enable+0x1c>
		return ERR_INVALID_ARG;
     9b2:	200d      	movs	r0, #13
     9b4:	4240      	negs	r0, r0
     9b6:	e7eb      	b.n	990 <_ext_irq_enable+0x1c>
     9b8:	40001800 	.word	0x40001800
     9bc:	00006294 	.word	0x00006294

000009c0 <EIC_Handler>:

/**
 * \brief EIC interrupt handler
 */
void EIC_Handler(void)
{
     9c0:	b570      	push	{r4, r5, r6, lr}
     9c2:	b082      	sub	sp, #8
	return ((Eic *)hw)->INTFLAG.reg;
     9c4:	4b28      	ldr	r3, [pc, #160]	; (a68 <EIC_Handler+0xa8>)
     9c6:	691a      	ldr	r2, [r3, #16]
	return ((Eic *)hw)->INTENSET.reg;
     9c8:	68d9      	ldr	r1, [r3, #12]
	volatile uint32_t flags = hri_eic_read_INTFLAG_reg(EIC) & hri_eic_read_INTEN_reg(EIC);
     9ca:	400a      	ands	r2, r1
     9cc:	9201      	str	r2, [sp, #4]
	int8_t            pos;
	uint32_t          pin = INVALID_PIN_NUMBER;

	hri_eic_clear_INTFLAG_reg(EIC, flags);
     9ce:	9a01      	ldr	r2, [sp, #4]
	((Eic *)hw)->INTFLAG.reg = mask;
     9d0:	611a      	str	r2, [r3, #16]

	ASSERT(callback);
     9d2:	4b26      	ldr	r3, [pc, #152]	; (a6c <EIC_Handler+0xac>)
     9d4:	447b      	add	r3, pc
     9d6:	6818      	ldr	r0, [r3, #0]
     9d8:	1e43      	subs	r3, r0, #1
     9da:	4198      	sbcs	r0, r3
     9dc:	b2c0      	uxtb	r0, r0
     9de:	22d2      	movs	r2, #210	; 0xd2
     9e0:	4923      	ldr	r1, [pc, #140]	; (a70 <EIC_Handler+0xb0>)
     9e2:	4479      	add	r1, pc
     9e4:	f7ff ff3a 	bl	85c <assert>
	uint32_t          pin = INVALID_PIN_NUMBER;
     9e8:	2501      	movs	r5, #1
     9ea:	426d      	negs	r5, r5

	while (flags) {
     9ec:	e030      	b.n	a50 <EIC_Handler+0x90>
					break;
				}
				if (_map[middle].extint < pos) {
					lower = middle + 1;
				} else {
					upper = middle - 1;
     9ee:	3901      	subs	r1, #1
     9f0:	b2ce      	uxtb	r6, r1
			while (upper >= lower) {
     9f2:	42b0      	cmp	r0, r6
     9f4:	d80f      	bhi.n	a16 <EIC_Handler+0x56>
				middle = (upper + lower) >> 1;
     9f6:	1832      	adds	r2, r6, r0
     9f8:	1052      	asrs	r2, r2, #1
     9fa:	b2d1      	uxtb	r1, r2
				if (_map[middle].extint == pos) {
     9fc:	23ff      	movs	r3, #255	; 0xff
     9fe:	4013      	ands	r3, r2
     a00:	00db      	lsls	r3, r3, #3
     a02:	4a1c      	ldr	r2, [pc, #112]	; (a74 <EIC_Handler+0xb4>)
     a04:	447a      	add	r2, pc
     a06:	5c9b      	ldrb	r3, [r3, r2]
     a08:	42a3      	cmp	r3, r4
     a0a:	d003      	beq.n	a14 <EIC_Handler+0x54>
				if (_map[middle].extint < pos) {
     a0c:	daef      	bge.n	9ee <EIC_Handler+0x2e>
					lower = middle + 1;
     a0e:	3101      	adds	r1, #1
     a10:	b2c8      	uxtb	r0, r1
     a12:	e7ee      	b.n	9f2 <EIC_Handler+0x32>
					pin = _map[middle].pin;
     a14:	2518      	movs	r5, #24
				}
			}

			if (INVALID_PIN_NUMBER != pin) {
     a16:	1c6b      	adds	r3, r5, #1
     a18:	d004      	beq.n	a24 <EIC_Handler+0x64>
				callback(pin);
     a1a:	4b17      	ldr	r3, [pc, #92]	; (a78 <EIC_Handler+0xb8>)
     a1c:	447b      	add	r3, pc
     a1e:	681b      	ldr	r3, [r3, #0]
     a20:	0028      	movs	r0, r5
     a22:	4798      	blx	r3
			}
			flags &= ~(1ul << pos);
     a24:	2201      	movs	r2, #1
     a26:	40a2      	lsls	r2, r4
     a28:	9b01      	ldr	r3, [sp, #4]
     a2a:	4393      	bics	r3, r2
     a2c:	9301      	str	r3, [sp, #4]
			pos = ffs(flags) - 1;
     a2e:	9801      	ldr	r0, [sp, #4]
     a30:	f004 fa74 	bl	4f1c <__ffssi2>
     a34:	3801      	subs	r0, #1
     a36:	b244      	sxtb	r4, r0
		while (-1 != pos) {
     a38:	1c63      	adds	r3, r4, #1
     a3a:	d002      	beq.n	a42 <EIC_Handler+0x82>
     a3c:	2601      	movs	r6, #1
     a3e:	2000      	movs	r0, #0
     a40:	e7d7      	b.n	9f2 <EIC_Handler+0x32>
	return ((Eic *)hw)->INTFLAG.reg;
     a42:	4b09      	ldr	r3, [pc, #36]	; (a68 <EIC_Handler+0xa8>)
     a44:	691a      	ldr	r2, [r3, #16]
	return ((Eic *)hw)->INTENSET.reg;
     a46:	68d9      	ldr	r1, [r3, #12]
		}
		flags = hri_eic_read_INTFLAG_reg(EIC) & hri_eic_read_INTEN_reg(EIC);
     a48:	400a      	ands	r2, r1
     a4a:	9201      	str	r2, [sp, #4]
		hri_eic_clear_INTFLAG_reg(EIC, flags);
     a4c:	9a01      	ldr	r2, [sp, #4]
	((Eic *)hw)->INTFLAG.reg = mask;
     a4e:	611a      	str	r2, [r3, #16]
	while (flags) {
     a50:	9b01      	ldr	r3, [sp, #4]
     a52:	2b00      	cmp	r3, #0
     a54:	d005      	beq.n	a62 <EIC_Handler+0xa2>
		pos = ffs(flags) - 1;
     a56:	9801      	ldr	r0, [sp, #4]
     a58:	f004 fa60 	bl	4f1c <__ffssi2>
     a5c:	3801      	subs	r0, #1
     a5e:	b244      	sxtb	r4, r0
		while (-1 != pos) {
     a60:	e7ea      	b.n	a38 <EIC_Handler+0x78>
	}
}
     a62:	b002      	add	sp, #8
     a64:	bd70      	pop	{r4, r5, r6, pc}
     a66:	46c0      	nop			; (mov r8, r8)
     a68:	40001800 	.word	0x40001800
     a6c:	1ffff894 	.word	0x1ffff894
     a70:	0000625a 	.word	0x0000625a
     a74:	00006230 	.word	0x00006230
     a78:	1ffff84c 	.word	0x1ffff84c

00000a7c <_gclk_init_generators_by_fref>:

void _gclk_init_generators_by_fref(uint32_t bm)
{

#if CONF_GCLK_GENERATOR_0_CONFIG == 1
	if (bm & (1ul << 0)) {
     a7c:	07c3      	lsls	r3, r0, #31
     a7e:	d509      	bpl.n	a94 <_gclk_init_generators_by_fref+0x18>
}

static inline void hri_gclk_write_GENDIV_reg(const void *const hw, hri_gclk_gendiv_reg_t data)
{
	GCLK_CRITICAL_SECTION_ENTER();
	((Gclk *)hw)->GENDIV.reg = data;
     a80:	4b0b      	ldr	r3, [pc, #44]	; (ab0 <_gclk_init_generators_by_fref+0x34>)
     a82:	2280      	movs	r2, #128	; 0x80
     a84:	0052      	lsls	r2, r2, #1
     a86:	609a      	str	r2, [r3, #8]
	((Gclk *)hw)->GENCTRL.reg = data;
     a88:	4a0a      	ldr	r2, [pc, #40]	; (ab4 <_gclk_init_generators_by_fref+0x38>)
     a8a:	605a      	str	r2, [r3, #4]
	while (((const Gclk *)hw)->STATUS.bit.SYNCBUSY)
     a8c:	4b08      	ldr	r3, [pc, #32]	; (ab0 <_gclk_init_generators_by_fref+0x34>)
     a8e:	785b      	ldrb	r3, [r3, #1]
     a90:	09db      	lsrs	r3, r3, #7
     a92:	d1fb      	bne.n	a8c <_gclk_init_generators_by_fref+0x10>
		        | (CONF_GCLK_GENERATOR_0_CONFIG << GCLK_GENCTRL_GENEN_Pos) | CONF_GCLK_GEN_0_SRC | GCLK_GENCTRL_ID(0));
	}
#endif

#if CONF_GCLK_GENERATOR_1_CONFIG == 1
	if (bm & (1ul << 1)) {
     a94:	0783      	lsls	r3, r0, #30
     a96:	d509      	bpl.n	aac <_gclk_init_generators_by_fref+0x30>
	((Gclk *)hw)->GENDIV.reg = data;
     a98:	4b05      	ldr	r3, [pc, #20]	; (ab0 <_gclk_init_generators_by_fref+0x34>)
     a9a:	2202      	movs	r2, #2
     a9c:	32ff      	adds	r2, #255	; 0xff
     a9e:	609a      	str	r2, [r3, #8]
	((Gclk *)hw)->GENCTRL.reg = data;
     aa0:	4a05      	ldr	r2, [pc, #20]	; (ab8 <_gclk_init_generators_by_fref+0x3c>)
     aa2:	605a      	str	r2, [r3, #4]
	while (((const Gclk *)hw)->STATUS.bit.SYNCBUSY)
     aa4:	4b02      	ldr	r3, [pc, #8]	; (ab0 <_gclk_init_generators_by_fref+0x34>)
     aa6:	785b      	ldrb	r3, [r3, #1]
     aa8:	09db      	lsrs	r3, r3, #7
     aaa:	d1fb      	bne.n	aa4 <_gclk_init_generators_by_fref+0x28>
		        | (CONF_GCLK_GEN_8_DIVSEL << GCLK_GENCTRL_DIVSEL_Pos) | (CONF_GCLK_GEN_8_OE << GCLK_GENCTRL_OE_Pos)
		        | (CONF_GCLK_GEN_8_OOV << GCLK_GENCTRL_OOV_Pos) | (CONF_GCLK_GEN_8_IDC << GCLK_GENCTRL_IDC_Pos)
		        | (CONF_GCLK_GENERATOR_8_CONFIG << GCLK_GENCTRL_GENEN_Pos) | CONF_GCLK_GEN_8_SRC | GCLK_GENCTRL_ID(8));
	}
#endif
}
     aac:	4770      	bx	lr
     aae:	46c0      	nop			; (mov r8, r8)
     ab0:	40000c00 	.word	0x40000c00
     ab4:	00010700 	.word	0x00010700
     ab8:	00010301 	.word	0x00010301

00000abc <_pm_init>:
}

static inline void hri_pm_set_CPUSEL_CPUDIV_bf(const void *const hw, hri_pm_cpusel_reg_t mask)
{
	PM_CRITICAL_SECTION_ENTER();
	((Pm *)hw)->CPUSEL.reg |= PM_CPUSEL_CPUDIV(mask);
     abc:	4b07      	ldr	r3, [pc, #28]	; (adc <_pm_init+0x20>)
     abe:	7a1a      	ldrb	r2, [r3, #8]
     ac0:	2101      	movs	r1, #1
     ac2:	430a      	orrs	r2, r1
     ac4:	b2d2      	uxtb	r2, r2
     ac6:	721a      	strb	r2, [r3, #8]
}

static inline void hri_pm_set_APBASEL_APBADIV_bf(const void *const hw, hri_pm_apbasel_reg_t mask)
{
	PM_CRITICAL_SECTION_ENTER();
	((Pm *)hw)->APBASEL.reg |= PM_APBASEL_APBADIV(mask);
     ac8:	7a5a      	ldrb	r2, [r3, #9]
     aca:	b2d2      	uxtb	r2, r2
     acc:	725a      	strb	r2, [r3, #9]
}

static inline void hri_pm_set_APBBSEL_APBBDIV_bf(const void *const hw, hri_pm_apbbsel_reg_t mask)
{
	PM_CRITICAL_SECTION_ENTER();
	((Pm *)hw)->APBBSEL.reg |= PM_APBBSEL_APBBDIV(mask);
     ace:	7a9a      	ldrb	r2, [r3, #10]
     ad0:	b2d2      	uxtb	r2, r2
     ad2:	729a      	strb	r2, [r3, #10]
}

static inline void hri_pm_set_APBCSEL_APBCDIV_bf(const void *const hw, hri_pm_apbcsel_reg_t mask)
{
	PM_CRITICAL_SECTION_ENTER();
	((Pm *)hw)->APBCSEL.reg |= PM_APBCSEL_APBCDIV(mask);
     ad4:	7ada      	ldrb	r2, [r3, #11]
     ad6:	b2d2      	uxtb	r2, r2
     ad8:	72da      	strb	r2, [r3, #11]
{
	hri_pm_set_CPUSEL_CPUDIV_bf(PM, CONF_CPU_DIV);
	hri_pm_set_APBASEL_APBADIV_bf(PM, CONF_APBA_DIV);
	hri_pm_set_APBBSEL_APBBDIV_bf(PM, CONF_APBB_DIV);
	hri_pm_set_APBCSEL_APBCDIV_bf(PM, CONF_APBC_DIV);
}
     ada:	4770      	bx	lr
     adc:	40000400 	.word	0x40000400

00000ae0 <_sercom_get_hardware_index>:
{
#ifdef _UNIT_TEST_
	return ((uint32_t)hw - (uint32_t)SERCOM0) / sizeof(Sercom);
#endif

	return ((uint32_t)hw - (uint32_t)SERCOM0) >> 10;
     ae0:	4b02      	ldr	r3, [pc, #8]	; (aec <_sercom_get_hardware_index+0xc>)
     ae2:	469c      	mov	ip, r3
     ae4:	4460      	add	r0, ip
     ae6:	0a80      	lsrs	r0, r0, #10
     ae8:	b2c0      	uxtb	r0, r0
}
     aea:	4770      	bx	lr
     aec:	bdfff800 	.word	0xbdfff800

00000af0 <_get_sercom_index>:
 * \param[in] hw The pointer to hardware instance

 * \return The ordinal number of the given sercom hardware instance
 */
static uint8_t _get_sercom_index(const void *const hw)
{
     af0:	b510      	push	{r4, lr}
	uint8_t sercom_offset = _sercom_get_hardware_index(hw);
     af2:	f7ff fff5 	bl	ae0 <_sercom_get_hardware_index>
     af6:	0002      	movs	r2, r0
	uint8_t i;

	for (i = 0; i < ARRAY_SIZE(_usarts); i++) {
     af8:	2000      	movs	r0, #0
     afa:	2800      	cmp	r0, #0
     afc:	d007      	beq.n	b0e <_get_sercom_index+0x1e>
		if (_usarts[i].number == sercom_offset) {
			return i;
		}
	}

	ASSERT(false);
     afe:	4a09      	ldr	r2, [pc, #36]	; (b24 <_get_sercom_index+0x34>)
     b00:	4909      	ldr	r1, [pc, #36]	; (b28 <_get_sercom_index+0x38>)
     b02:	4479      	add	r1, pc
     b04:	2000      	movs	r0, #0
     b06:	f7ff fea9 	bl	85c <assert>
	return 0;
     b0a:	2000      	movs	r0, #0
}
     b0c:	bd10      	pop	{r4, pc}
		if (_usarts[i].number == sercom_offset) {
     b0e:	0083      	lsls	r3, r0, #2
     b10:	181b      	adds	r3, r3, r0
     b12:	0099      	lsls	r1, r3, #2
     b14:	4b05      	ldr	r3, [pc, #20]	; (b2c <_get_sercom_index+0x3c>)
     b16:	447b      	add	r3, pc
     b18:	5ccb      	ldrb	r3, [r1, r3]
     b1a:	429a      	cmp	r2, r3
     b1c:	d0f6      	beq.n	b0c <_get_sercom_index+0x1c>
	for (i = 0; i < ARRAY_SIZE(_usarts); i++) {
     b1e:	3001      	adds	r0, #1
     b20:	b2c0      	uxtb	r0, r0
     b22:	e7ea      	b.n	afa <_get_sercom_index+0xa>
     b24:	0000023a 	.word	0x0000023a
     b28:	000061a2 	.word	0x000061a2
     b2c:	0000613e 	.word	0x0000613e

00000b30 <_usart_init>:
 * \param[in] hw The pointer to hardware instance
 *
 * \return The status of initialization
 */
static int32_t _usart_init(void *const hw)
{
     b30:	b570      	push	{r4, r5, r6, lr}
     b32:	0004      	movs	r4, r0
	uint8_t i = _get_sercom_index(hw);
     b34:	f7ff ffdc 	bl	af0 <_get_sercom_index>
	};
}

static inline bool hri_sercomusart_is_syncing(const void *const hw, hri_sercomusart_syncbusy_reg_t reg)
{
	return ((Sercom *)hw)->USART.SYNCBUSY.reg & reg;
     b38:	69e3      	ldr	r3, [r4, #28]

	if (!hri_sercomusart_is_syncing(hw, SERCOM_USART_SYNCBUSY_SWRST)) {
     b3a:	07db      	lsls	r3, r3, #31
     b3c:	d41e      	bmi.n	b7c <_usart_init+0x4c>
		uint32_t mode = _usarts[i].ctrl_a & SERCOM_USART_CTRLA_MODE_Msk;
     b3e:	0083      	lsls	r3, r0, #2
     b40:	181b      	adds	r3, r3, r0
     b42:	009a      	lsls	r2, r3, #2
     b44:	4b38      	ldr	r3, [pc, #224]	; (c28 <_usart_init+0xf8>)
     b46:	447b      	add	r3, pc
     b48:	189b      	adds	r3, r3, r2
     b4a:	685a      	ldr	r2, [r3, #4]
     b4c:	231c      	movs	r3, #28
     b4e:	401a      	ands	r2, r3
	while (((Sercom *)hw)->USART.SYNCBUSY.reg & reg) {
     b50:	69e3      	ldr	r3, [r4, #28]
     b52:	079b      	lsls	r3, r3, #30
     b54:	d1fc      	bne.n	b50 <_usart_init+0x20>
static inline hri_sercomusart_ctrla_reg_t hri_sercomusart_get_CTRLA_reg(const void *const           hw,
                                                                        hri_sercomusart_ctrla_reg_t mask)
{
	uint32_t tmp;
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_SWRST | SERCOM_USART_SYNCBUSY_ENABLE);
	tmp = ((Sercom *)hw)->USART.CTRLA.reg;
     b56:	6823      	ldr	r3, [r4, #0]
		if (hri_sercomusart_get_CTRLA_reg(hw, SERCOM_USART_CTRLA_ENABLE)) {
     b58:	079b      	lsls	r3, r3, #30
     b5a:	d509      	bpl.n	b70 <_usart_init+0x40>
	((Sercom *)hw)->USART.CTRLA.reg &= ~SERCOM_USART_CTRLA_ENABLE;
     b5c:	6823      	ldr	r3, [r4, #0]
     b5e:	2102      	movs	r1, #2
     b60:	438b      	bics	r3, r1
     b62:	6023      	str	r3, [r4, #0]
	while (((Sercom *)hw)->USART.SYNCBUSY.reg & reg) {
     b64:	69e3      	ldr	r3, [r4, #28]
     b66:	079b      	lsls	r3, r3, #30
     b68:	d1fc      	bne.n	b64 <_usart_init+0x34>
     b6a:	69e3      	ldr	r3, [r4, #28]
     b6c:	079b      	lsls	r3, r3, #30
     b6e:	d4fc      	bmi.n	b6a <_usart_init+0x3a>
			hri_sercomusart_clear_CTRLA_ENABLE_bit(hw);
			hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_ENABLE);
		}
		hri_sercomusart_write_CTRLA_reg(hw, SERCOM_USART_CTRLA_SWRST | mode);
     b70:	2301      	movs	r3, #1
     b72:	4313      	orrs	r3, r2
}

static inline void hri_sercomusart_write_CTRLA_reg(const void *const hw, hri_sercomusart_ctrla_reg_t data)
{
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->USART.CTRLA.reg = data;
     b74:	6023      	str	r3, [r4, #0]
	while (((Sercom *)hw)->USART.SYNCBUSY.reg & reg) {
     b76:	69e3      	ldr	r3, [r4, #28]
     b78:	079b      	lsls	r3, r3, #30
     b7a:	d1fc      	bne.n	b76 <_usart_init+0x46>
     b7c:	69e3      	ldr	r3, [r4, #28]
     b7e:	07db      	lsls	r3, r3, #31
     b80:	d4fc      	bmi.n	b7c <_usart_init+0x4c>
	}
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_SWRST);

	hri_sercomusart_write_CTRLA_reg(hw, _usarts[i].ctrl_a);
     b82:	0083      	lsls	r3, r0, #2
     b84:	181b      	adds	r3, r3, r0
     b86:	009a      	lsls	r2, r3, #2
     b88:	4b28      	ldr	r3, [pc, #160]	; (c2c <_usart_init+0xfc>)
     b8a:	447b      	add	r3, pc
     b8c:	189b      	adds	r3, r3, r2
     b8e:	685b      	ldr	r3, [r3, #4]
	((Sercom *)hw)->USART.CTRLA.reg = data;
     b90:	6023      	str	r3, [r4, #0]
	while (((Sercom *)hw)->USART.SYNCBUSY.reg & reg) {
     b92:	69e3      	ldr	r3, [r4, #28]
     b94:	079b      	lsls	r3, r3, #30
     b96:	d1fc      	bne.n	b92 <_usart_init+0x62>
	hri_sercomusart_write_CTRLB_reg(hw, _usarts[i].ctrl_b);
     b98:	0083      	lsls	r3, r0, #2
     b9a:	181b      	adds	r3, r3, r0
     b9c:	009a      	lsls	r2, r3, #2
     b9e:	4b24      	ldr	r3, [pc, #144]	; (c30 <_usart_init+0x100>)
     ba0:	447b      	add	r3, pc
     ba2:	189b      	adds	r3, r3, r2
     ba4:	689b      	ldr	r3, [r3, #8]
}

static inline void hri_sercomusart_write_CTRLB_reg(const void *const hw, hri_sercomusart_ctrlb_reg_t data)
{
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->USART.CTRLB.reg = data;
     ba6:	6063      	str	r3, [r4, #4]
	while (((Sercom *)hw)->USART.SYNCBUSY.reg & reg) {
     ba8:	69e3      	ldr	r3, [r4, #28]
     baa:	075b      	lsls	r3, r3, #29
     bac:	d1fc      	bne.n	ba8 <_usart_init+0x78>
	if ((_usarts[i].ctrl_a & SERCOM_USART_CTRLA_SAMPR(0x1)) || (_usarts[i].ctrl_a & SERCOM_USART_CTRLA_SAMPR(0x3))) {
     bae:	0083      	lsls	r3, r0, #2
     bb0:	181b      	adds	r3, r3, r0
     bb2:	009a      	lsls	r2, r3, #2
     bb4:	4b1f      	ldr	r3, [pc, #124]	; (c34 <_usart_init+0x104>)
     bb6:	447b      	add	r3, pc
     bb8:	189b      	adds	r3, r3, r2
     bba:	685b      	ldr	r3, [r3, #4]
     bbc:	049a      	lsls	r2, r3, #18
     bbe:	d40c      	bmi.n	bda <_usart_init+0xaa>
     bc0:	22c0      	movs	r2, #192	; 0xc0
     bc2:	01d2      	lsls	r2, r2, #7
     bc4:	4213      	tst	r3, r2
     bc6:	d108      	bne.n	bda <_usart_init+0xaa>
		((Sercom *)hw)->USART.BAUD.FRAC.BAUD = _usarts[i].baud;
		((Sercom *)hw)->USART.BAUD.FRAC.FP   = _usarts[i].fractional;
	} else {
		hri_sercomusart_write_BAUD_reg(hw, _usarts[i].baud);
     bc8:	0083      	lsls	r3, r0, #2
     bca:	181b      	adds	r3, r3, r0
     bcc:	009a      	lsls	r2, r3, #2
     bce:	4b1a      	ldr	r3, [pc, #104]	; (c38 <_usart_init+0x108>)
     bd0:	447b      	add	r3, pc
     bd2:	189b      	adds	r3, r3, r2
     bd4:	899b      	ldrh	r3, [r3, #12]
}

static inline void hri_sercomusart_write_BAUD_reg(const void *const hw, hri_sercomusart_baud_reg_t data)
{
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->USART.BAUD.reg = data;
     bd6:	81a3      	strh	r3, [r4, #12]
     bd8:	e016      	b.n	c08 <_usart_init+0xd8>
		((Sercom *)hw)->USART.BAUD.FRAC.BAUD = _usarts[i].baud;
     bda:	0083      	lsls	r3, r0, #2
     bdc:	181b      	adds	r3, r3, r0
     bde:	009a      	lsls	r2, r3, #2
     be0:	4916      	ldr	r1, [pc, #88]	; (c3c <_usart_init+0x10c>)
     be2:	4479      	add	r1, pc
     be4:	1889      	adds	r1, r1, r2
     be6:	898a      	ldrh	r2, [r1, #12]
     be8:	89a3      	ldrh	r3, [r4, #12]
     bea:	04d2      	lsls	r2, r2, #19
     bec:	0cd2      	lsrs	r2, r2, #19
     bee:	0b5b      	lsrs	r3, r3, #13
     bf0:	035b      	lsls	r3, r3, #13
     bf2:	4313      	orrs	r3, r2
     bf4:	81a3      	strh	r3, [r4, #12]
		((Sercom *)hw)->USART.BAUD.FRAC.FP   = _usarts[i].fractional;
     bf6:	7b8b      	ldrb	r3, [r1, #14]
     bf8:	2207      	movs	r2, #7
     bfa:	401a      	ands	r2, r3
     bfc:	89a3      	ldrh	r3, [r4, #12]
     bfe:	0352      	lsls	r2, r2, #13
     c00:	04db      	lsls	r3, r3, #19
     c02:	0cdb      	lsrs	r3, r3, #19
     c04:	4313      	orrs	r3, r2
     c06:	81a3      	strh	r3, [r4, #12]
	}

	hri_sercomusart_write_RXPL_reg(hw, _usarts[i].rxpl);
     c08:	4b0d      	ldr	r3, [pc, #52]	; (c40 <_usart_init+0x110>)
     c0a:	447b      	add	r3, pc
     c0c:	0082      	lsls	r2, r0, #2
     c0e:	1815      	adds	r5, r2, r0
     c10:	00a9      	lsls	r1, r5, #2
     c12:	000d      	movs	r5, r1
     c14:	1859      	adds	r1, r3, r1
     c16:	7bc9      	ldrb	r1, [r1, #15]
}

static inline void hri_sercomusart_write_RXPL_reg(const void *const hw, hri_sercomusart_rxpl_reg_t data)
{
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->USART.RXPL.reg = data;
     c18:	73a1      	strb	r1, [r4, #14]
	hri_sercomusart_write_DBGCTRL_reg(hw, _usarts[i].debug_ctrl);
     c1a:	195b      	adds	r3, r3, r5
     c1c:	7c1a      	ldrb	r2, [r3, #16]
}

static inline void hri_sercomusart_write_DBGCTRL_reg(const void *const hw, hri_sercomusart_dbgctrl_reg_t data)
{
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->USART.DBGCTRL.reg = data;
     c1e:	2330      	movs	r3, #48	; 0x30
     c20:	54e2      	strb	r2, [r4, r3]

	return ERR_NONE;
}
     c22:	2000      	movs	r0, #0
     c24:	bd70      	pop	{r4, r5, r6, pc}
     c26:	46c0      	nop			; (mov r8, r8)
     c28:	0000610e 	.word	0x0000610e
     c2c:	000060ca 	.word	0x000060ca
     c30:	000060b4 	.word	0x000060b4
     c34:	0000609e 	.word	0x0000609e
     c38:	00006084 	.word	0x00006084
     c3c:	00006072 	.word	0x00006072
     c40:	0000604a 	.word	0x0000604a

00000c44 <_get_i2cm_index>:
 * \param[in] hw The pointer to hardware instance

 * \return The ordinal number of the given sercom hardware instance
 */
static int8_t _get_i2cm_index(const void *const hw)
{
     c44:	b510      	push	{r4, lr}
	uint8_t sercom_offset = _sercom_get_hardware_index(hw);
     c46:	f7ff ff4b 	bl	ae0 <_sercom_get_hardware_index>
	uint8_t i;

	for (i = 0; i < ARRAY_SIZE(_i2cms); i++) {
     c4a:	2300      	movs	r3, #0
     c4c:	2b00      	cmp	r3, #0
     c4e:	d009      	beq.n	c64 <_get_i2cm_index+0x20>
		if (_i2cms[i].number == sercom_offset) {
			return i;
		}
	}

	ASSERT(false);
     c50:	22e6      	movs	r2, #230	; 0xe6
     c52:	0092      	lsls	r2, r2, #2
     c54:	490a      	ldr	r1, [pc, #40]	; (c80 <_get_i2cm_index+0x3c>)
     c56:	4479      	add	r1, pc
     c58:	2000      	movs	r0, #0
     c5a:	f7ff fdff 	bl	85c <assert>
	return -1;
     c5e:	2001      	movs	r0, #1
     c60:	4240      	negs	r0, r0
}
     c62:	bd10      	pop	{r4, pc}
		if (_i2cms[i].number == sercom_offset) {
     c64:	005a      	lsls	r2, r3, #1
     c66:	18d2      	adds	r2, r2, r3
     c68:	00d1      	lsls	r1, r2, #3
     c6a:	4a06      	ldr	r2, [pc, #24]	; (c84 <_get_i2cm_index+0x40>)
     c6c:	447a      	add	r2, pc
     c6e:	1852      	adds	r2, r2, r1
     c70:	7d12      	ldrb	r2, [r2, #20]
     c72:	4290      	cmp	r0, r2
     c74:	d002      	beq.n	c7c <_get_i2cm_index+0x38>
	for (i = 0; i < ARRAY_SIZE(_i2cms); i++) {
     c76:	3301      	adds	r3, #1
     c78:	b2db      	uxtb	r3, r3
     c7a:	e7e7      	b.n	c4c <_get_i2cm_index+0x8>
			return i;
     c7c:	b258      	sxtb	r0, r3
     c7e:	e7f0      	b.n	c62 <_get_i2cm_index+0x1e>
     c80:	0000604e 	.word	0x0000604e
     c84:	00005fe8 	.word	0x00005fe8

00000c88 <_i2c_m_sync_init_impl>:
	}
	return ERR_NONE;
}

static int32_t _i2c_m_sync_init_impl(struct _i2c_m_service *const service, void *const hw)
{
     c88:	b570      	push	{r4, r5, r6, lr}
     c8a:	0005      	movs	r5, r0
     c8c:	000c      	movs	r4, r1
	uint8_t i = _get_i2cm_index(hw);
     c8e:	0008      	movs	r0, r1
     c90:	f7ff ffd8 	bl	c44 <_get_i2cm_index>
     c94:	b2c0      	uxtb	r0, r0
	return ((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg;
     c96:	69e3      	ldr	r3, [r4, #28]

	if (!hri_sercomi2cm_is_syncing(hw, SERCOM_I2CM_SYNCBUSY_SWRST)) {
     c98:	07db      	lsls	r3, r3, #31
     c9a:	d41e      	bmi.n	cda <_i2c_m_sync_init_impl+0x52>
		uint32_t mode = _i2cms[i].ctrl_a & SERCOM_I2CM_CTRLA_MODE_Msk;
     c9c:	0043      	lsls	r3, r0, #1
     c9e:	181b      	adds	r3, r3, r0
     ca0:	00da      	lsls	r2, r3, #3
     ca2:	4b2c      	ldr	r3, [pc, #176]	; (d54 <_i2c_m_sync_init_impl+0xcc>)
     ca4:	447b      	add	r3, pc
     ca6:	189b      	adds	r3, r3, r2
     ca8:	699a      	ldr	r2, [r3, #24]
     caa:	231c      	movs	r3, #28
     cac:	401a      	ands	r2, r3
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
     cae:	69e3      	ldr	r3, [r4, #28]
     cb0:	079b      	lsls	r3, r3, #30
     cb2:	d1fc      	bne.n	cae <_i2c_m_sync_init_impl+0x26>
	tmp = ((Sercom *)hw)->I2CM.CTRLA.reg;
     cb4:	6823      	ldr	r3, [r4, #0]
		if (hri_sercomi2cm_get_CTRLA_reg(hw, SERCOM_I2CM_CTRLA_ENABLE)) {
     cb6:	079b      	lsls	r3, r3, #30
     cb8:	d509      	bpl.n	cce <_i2c_m_sync_init_impl+0x46>
	((Sercom *)hw)->I2CM.CTRLA.reg &= ~SERCOM_I2CM_CTRLA_ENABLE;
     cba:	6823      	ldr	r3, [r4, #0]
     cbc:	2102      	movs	r1, #2
     cbe:	438b      	bics	r3, r1
     cc0:	6023      	str	r3, [r4, #0]
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
     cc2:	69e3      	ldr	r3, [r4, #28]
     cc4:	079b      	lsls	r3, r3, #30
     cc6:	d1fc      	bne.n	cc2 <_i2c_m_sync_init_impl+0x3a>
     cc8:	69e3      	ldr	r3, [r4, #28]
     cca:	079b      	lsls	r3, r3, #30
     ccc:	d4fc      	bmi.n	cc8 <_i2c_m_sync_init_impl+0x40>
			hri_sercomi2cm_clear_CTRLA_ENABLE_bit(hw);
			hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_ENABLE);
		}
		hri_sercomi2cm_write_CTRLA_reg(hw, SERCOM_I2CM_CTRLA_SWRST | mode);
     cce:	2301      	movs	r3, #1
     cd0:	4313      	orrs	r3, r2
	((Sercom *)hw)->I2CM.CTRLA.reg = data;
     cd2:	6023      	str	r3, [r4, #0]
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
     cd4:	69e3      	ldr	r3, [r4, #28]
     cd6:	079b      	lsls	r3, r3, #30
     cd8:	d1fc      	bne.n	cd4 <_i2c_m_sync_init_impl+0x4c>
     cda:	69e3      	ldr	r3, [r4, #28]
     cdc:	07db      	lsls	r3, r3, #31
     cde:	d4fc      	bmi.n	cda <_i2c_m_sync_init_impl+0x52>
	}
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SWRST);

	hri_sercomi2cm_write_CTRLA_reg(hw, _i2cms[i].ctrl_a);
     ce0:	0043      	lsls	r3, r0, #1
     ce2:	181b      	adds	r3, r3, r0
     ce4:	00da      	lsls	r2, r3, #3
     ce6:	4b1c      	ldr	r3, [pc, #112]	; (d58 <_i2c_m_sync_init_impl+0xd0>)
     ce8:	447b      	add	r3, pc
     cea:	189b      	adds	r3, r3, r2
     cec:	699b      	ldr	r3, [r3, #24]
	((Sercom *)hw)->I2CM.CTRLA.reg = data;
     cee:	6023      	str	r3, [r4, #0]
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
     cf0:	69e3      	ldr	r3, [r4, #28]
     cf2:	079b      	lsls	r3, r3, #30
     cf4:	d1fc      	bne.n	cf0 <_i2c_m_sync_init_impl+0x68>
	hri_sercomi2cm_write_CTRLB_reg(hw, _i2cms[i].ctrl_b);
     cf6:	0043      	lsls	r3, r0, #1
     cf8:	181b      	adds	r3, r3, r0
     cfa:	00da      	lsls	r2, r3, #3
     cfc:	4b17      	ldr	r3, [pc, #92]	; (d5c <_i2c_m_sync_init_impl+0xd4>)
     cfe:	447b      	add	r3, pc
     d00:	189b      	adds	r3, r3, r2
     d02:	69db      	ldr	r3, [r3, #28]
	((Sercom *)hw)->I2CM.CTRLB.reg = data;
     d04:	6063      	str	r3, [r4, #4]
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
     d06:	69e3      	ldr	r3, [r4, #28]
     d08:	075b      	lsls	r3, r3, #29
     d0a:	d4fc      	bmi.n	d06 <_i2c_m_sync_init_impl+0x7e>
	hri_sercomi2cm_write_BAUD_reg(hw, _i2cms[i].baud);
     d0c:	0042      	lsls	r2, r0, #1
     d0e:	1812      	adds	r2, r2, r0
     d10:	00d1      	lsls	r1, r2, #3
     d12:	4b13      	ldr	r3, [pc, #76]	; (d60 <_i2c_m_sync_init_impl+0xd8>)
     d14:	447b      	add	r3, pc
     d16:	185b      	adds	r3, r3, r1
	((Sercom *)hw)->I2CM.BAUD.reg = data;
     d18:	6a1a      	ldr	r2, [r3, #32]
     d1a:	60e2      	str	r2, [r4, #12]

	service->mode = (_i2cms[i].ctrl_a & SERCOM_I2CM_CTRLA_SPEED_Msk) >> SERCOM_I2CM_CTRLA_SPEED_Pos;
     d1c:	7eda      	ldrb	r2, [r3, #27]
     d1e:	2303      	movs	r3, #3
     d20:	401a      	ands	r2, r3
     d22:	81aa      	strh	r2, [r5, #12]
	hri_sercomi2cm_write_ADDR_HS_bit(hw, service->mode < I2C_HS ? 0 : 1);
     d24:	3b02      	subs	r3, #2
     d26:	4293      	cmp	r3, r2
     d28:	419b      	sbcs	r3, r3
     d2a:	425b      	negs	r3, r3
	tmp = ((Sercom *)hw)->I2CM.ADDR.reg;
     d2c:	6a62      	ldr	r2, [r4, #36]	; 0x24
	tmp &= ~SERCOM_I2CM_ADDR_HS;
     d2e:	490d      	ldr	r1, [pc, #52]	; (d64 <_i2c_m_sync_init_impl+0xdc>)
     d30:	400a      	ands	r2, r1
	tmp |= value << SERCOM_I2CM_ADDR_HS_Pos;
     d32:	039b      	lsls	r3, r3, #14
     d34:	4313      	orrs	r3, r2
	((Sercom *)hw)->I2CM.ADDR.reg = tmp;
     d36:	6263      	str	r3, [r4, #36]	; 0x24
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
     d38:	69e3      	ldr	r3, [r4, #28]
     d3a:	075b      	lsls	r3, r3, #29
     d3c:	d4fc      	bmi.n	d38 <_i2c_m_sync_init_impl+0xb0>

	service->trise = _i2cms[i].trise;
     d3e:	0043      	lsls	r3, r0, #1
     d40:	1818      	adds	r0, r3, r0
     d42:	00c2      	lsls	r2, r0, #3
     d44:	4b08      	ldr	r3, [pc, #32]	; (d68 <_i2c_m_sync_init_impl+0xe0>)
     d46:	447b      	add	r3, pc
     d48:	189b      	adds	r3, r3, r2
     d4a:	8cdb      	ldrh	r3, [r3, #38]	; 0x26
     d4c:	81eb      	strh	r3, [r5, #14]

	return ERR_NONE;
}
     d4e:	2000      	movs	r0, #0
     d50:	bd70      	pop	{r4, r5, r6, pc}
     d52:	46c0      	nop			; (mov r8, r8)
     d54:	00005fb0 	.word	0x00005fb0
     d58:	00005f6c 	.word	0x00005f6c
     d5c:	00005f56 	.word	0x00005f56
     d60:	00005f40 	.word	0x00005f40
     d64:	ffffbfff 	.word	0xffffbfff
     d68:	00005f0e 	.word	0x00005f0e

00000d6c <_sercom_i2c_sync_send_address>:
{
     d6c:	b570      	push	{r4, r5, r6, lr}
     d6e:	0005      	movs	r5, r0
	void *             hw    = i2c_dev->hw;
     d70:	6904      	ldr	r4, [r0, #16]
	tmp = ((Sercom *)hw)->I2CM.CTRLA.reg;
     d72:	6823      	ldr	r3, [r4, #0]
	tmp = (tmp & SERCOM_I2CM_CTRLA_SCLSM) >> SERCOM_I2CM_CTRLA_SCLSM_Pos;
     d74:	0edb      	lsrs	r3, r3, #27
     d76:	2601      	movs	r6, #1
     d78:	401e      	ands	r6, r3
	ASSERT(i2c_dev);
     d7a:	1e43      	subs	r3, r0, #1
     d7c:	4198      	sbcs	r0, r3
     d7e:	b2c0      	uxtb	r0, r0
     d80:	4a8f      	ldr	r2, [pc, #572]	; (fc0 <_sercom_i2c_sync_send_address+0x254>)
     d82:	4990      	ldr	r1, [pc, #576]	; (fc4 <_sercom_i2c_sync_send_address+0x258>)
     d84:	4479      	add	r1, pc
     d86:	f7ff fd69 	bl	85c <assert>
	if (msg->len == 1 && sclsm) {
     d8a:	686b      	ldr	r3, [r5, #4]
     d8c:	2b01      	cmp	r3, #1
     d8e:	d04d      	beq.n	e2c <_sercom_i2c_sync_send_address+0xc0>
	((Sercom *)hw)->I2CM.CTRLB.reg &= ~SERCOM_I2CM_CTRLB_ACKACT;
     d90:	6863      	ldr	r3, [r4, #4]
     d92:	4a8d      	ldr	r2, [pc, #564]	; (fc8 <_sercom_i2c_sync_send_address+0x25c>)
     d94:	4013      	ands	r3, r2
     d96:	6063      	str	r3, [r4, #4]
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
     d98:	69e3      	ldr	r3, [r4, #28]
     d9a:	075b      	lsls	r3, r3, #29
     d9c:	d4fc      	bmi.n	d98 <_sercom_i2c_sync_send_address+0x2c>
	if (msg->addr & I2C_M_TEN) {
     d9e:	882b      	ldrh	r3, [r5, #0]
     da0:	055a      	lsls	r2, r3, #21
     da2:	d54e      	bpl.n	e42 <_sercom_i2c_sync_send_address+0xd6>
		if (msg->flags & I2C_M_RD) {
     da4:	886a      	ldrh	r2, [r5, #2]
     da6:	07d2      	lsls	r2, r2, #31
     da8:	d504      	bpl.n	db4 <_sercom_i2c_sync_send_address+0x48>
			msg->flags |= I2C_M_TEN;
     daa:	886a      	ldrh	r2, [r5, #2]
     dac:	2180      	movs	r1, #128	; 0x80
     dae:	00c9      	lsls	r1, r1, #3
     db0:	430a      	orrs	r2, r1
     db2:	806a      	strh	r2, [r5, #2]
		                              ((msg->addr & TEN_ADDR_MASK) << 1) | SERCOM_I2CM_ADDR_TENBITEN
     db4:	005b      	lsls	r3, r3, #1
		                                  | (hri_sercomi2cm_read_ADDR_reg(hw) & SERCOM_I2CM_ADDR_HS));
     db6:	4a85      	ldr	r2, [pc, #532]	; (fcc <_sercom_i2c_sync_send_address+0x260>)
     db8:	401a      	ands	r2, r3
     dba:	69e3      	ldr	r3, [r4, #28]
     dbc:	075b      	lsls	r3, r3, #29
     dbe:	d4fc      	bmi.n	dba <_sercom_i2c_sync_send_address+0x4e>
	return ((Sercom *)hw)->I2CM.ADDR.reg;
     dc0:	6a63      	ldr	r3, [r4, #36]	; 0x24
     dc2:	2180      	movs	r1, #128	; 0x80
     dc4:	01c9      	lsls	r1, r1, #7
     dc6:	400b      	ands	r3, r1
     dc8:	4313      	orrs	r3, r2
		hri_sercomi2cm_write_ADDR_reg(hw,
     dca:	2280      	movs	r2, #128	; 0x80
     dcc:	0212      	lsls	r2, r2, #8
     dce:	4313      	orrs	r3, r2
	((Sercom *)hw)->I2CM.ADDR.reg = data;
     dd0:	6263      	str	r3, [r4, #36]	; 0x24
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
     dd2:	69e3      	ldr	r3, [r4, #28]
     dd4:	075b      	lsls	r3, r3, #29
     dd6:	d4fc      	bmi.n	dd2 <_sercom_i2c_sync_send_address+0x66>
	void *   hw      = i2c_dev->hw;
     dd8:	692e      	ldr	r6, [r5, #16]
	uint32_t timeout = 65535;
     dda:	4a7d      	ldr	r2, [pc, #500]	; (fd0 <_sercom_i2c_sync_send_address+0x264>)
	return ((Sercom *)hw)->I2CM.INTFLAG.reg;
     ddc:	7e33      	ldrb	r3, [r6, #24]
     dde:	b2db      	uxtb	r3, r3
		*flags = hri_sercomi2cm_read_INTFLAG_reg(hw);
     de0:	0018      	movs	r0, r3
		if (timeout-- == 0) {
     de2:	1e51      	subs	r1, r2, #1
     de4:	2a00      	cmp	r2, #0
     de6:	d002      	beq.n	dee <_sercom_i2c_sync_send_address+0x82>
     de8:	000a      	movs	r2, r1
	} while (!(*flags & MB_FLAG) && !(*flags & SB_FLAG));
     dea:	079b      	lsls	r3, r3, #30
     dec:	d0f6      	beq.n	ddc <_sercom_i2c_sync_send_address+0x70>
	tmp = ((Sercom *)hw)->I2CM.CTRLA.reg;
     dee:	6823      	ldr	r3, [r4, #0]
	tmp = (tmp & SERCOM_I2CM_CTRLA_SCLSM) >> SERCOM_I2CM_CTRLA_SCLSM_Pos;
     df0:	0edb      	lsrs	r3, r3, #27
     df2:	2201      	movs	r2, #1
     df4:	401a      	ands	r2, r3
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
     df6:	69e3      	ldr	r3, [r4, #28]
     df8:	075b      	lsls	r3, r3, #29
     dfa:	d4fc      	bmi.n	df6 <_sercom_i2c_sync_send_address+0x8a>
}

static inline hri_sercomi2cm_status_reg_t hri_sercomi2cm_read_STATUS_reg(const void *const hw)
{
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
	return ((Sercom *)hw)->I2CM.STATUS.reg;
     dfc:	8b63      	ldrh	r3, [r4, #26]
     dfe:	b29b      	uxth	r3, r3
	if (flags & MB_FLAG) {
     e00:	07c1      	lsls	r1, r0, #31
     e02:	d400      	bmi.n	e06 <_sercom_i2c_sync_send_address+0x9a>
     e04:	e08f      	b.n	f26 <_sercom_i2c_sync_send_address+0x1ba>
		if (status & SERCOM_I2CM_STATUS_ARBLOST) {
     e06:	079a      	lsls	r2, r3, #30
     e08:	d52f      	bpl.n	e6a <_sercom_i2c_sync_send_address+0xfe>
	((Sercom *)hw)->I2CM.INTFLAG.reg = SERCOM_I2CM_INTFLAG_MB;
     e0a:	2201      	movs	r2, #1
     e0c:	7622      	strb	r2, [r4, #24]
			msg->flags |= I2C_M_FAIL;
     e0e:	886a      	ldrh	r2, [r5, #2]
     e10:	2180      	movs	r1, #128	; 0x80
     e12:	0149      	lsls	r1, r1, #5
     e14:	430a      	orrs	r2, r1
     e16:	806a      	strh	r2, [r5, #2]
			msg->flags &= ~I2C_M_BUSY;
     e18:	886a      	ldrh	r2, [r5, #2]
     e1a:	496e      	ldr	r1, [pc, #440]	; (fd4 <_sercom_i2c_sync_send_address+0x268>)
     e1c:	400a      	ands	r2, r1
     e1e:	806a      	strh	r2, [r5, #2]
			if (status & SERCOM_I2CM_STATUS_BUSERR) {
     e20:	07db      	lsls	r3, r3, #31
     e22:	d400      	bmi.n	e26 <_sercom_i2c_sync_send_address+0xba>
     e24:	e0c6      	b.n	fb4 <_sercom_i2c_sync_send_address+0x248>
				return I2C_ERR_BUS;
     e26:	2005      	movs	r0, #5
     e28:	4240      	negs	r0, r0
     e2a:	e0a2      	b.n	f72 <_sercom_i2c_sync_send_address+0x206>
	if (msg->len == 1 && sclsm) {
     e2c:	2e00      	cmp	r6, #0
     e2e:	d0af      	beq.n	d90 <_sercom_i2c_sync_send_address+0x24>
	((Sercom *)hw)->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_ACKACT;
     e30:	6862      	ldr	r2, [r4, #4]
     e32:	2380      	movs	r3, #128	; 0x80
     e34:	02db      	lsls	r3, r3, #11
     e36:	4313      	orrs	r3, r2
     e38:	6063      	str	r3, [r4, #4]
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
     e3a:	69e3      	ldr	r3, [r4, #28]
     e3c:	075b      	lsls	r3, r3, #29
     e3e:	d4fc      	bmi.n	e3a <_sercom_i2c_sync_send_address+0xce>
     e40:	e7ad      	b.n	d9e <_sercom_i2c_sync_send_address+0x32>
		                              ((msg->addr & SEVEN_ADDR_MASK) << 1) | (msg->flags & I2C_M_RD ? I2C_M_RD : 0x0)
     e42:	005b      	lsls	r3, r3, #1
     e44:	22ff      	movs	r2, #255	; 0xff
     e46:	4013      	ands	r3, r2
     e48:	886a      	ldrh	r2, [r5, #2]
     e4a:	2101      	movs	r1, #1
     e4c:	400a      	ands	r2, r1
     e4e:	431a      	orrs	r2, r3
     e50:	69e3      	ldr	r3, [r4, #28]
     e52:	075b      	lsls	r3, r3, #29
     e54:	d4fc      	bmi.n	e50 <_sercom_i2c_sync_send_address+0xe4>
	return ((Sercom *)hw)->I2CM.ADDR.reg;
     e56:	6a63      	ldr	r3, [r4, #36]	; 0x24
		                                  | (hri_sercomi2cm_read_ADDR_reg(hw) & SERCOM_I2CM_ADDR_HS));
     e58:	2180      	movs	r1, #128	; 0x80
     e5a:	01c9      	lsls	r1, r1, #7
     e5c:	400b      	ands	r3, r1
		hri_sercomi2cm_write_ADDR_reg(hw,
     e5e:	4313      	orrs	r3, r2
	((Sercom *)hw)->I2CM.ADDR.reg = data;
     e60:	6263      	str	r3, [r4, #36]	; 0x24
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
     e62:	69e3      	ldr	r3, [r4, #28]
     e64:	075b      	lsls	r3, r3, #29
     e66:	d4fc      	bmi.n	e62 <_sercom_i2c_sync_send_address+0xf6>
     e68:	e7b6      	b.n	dd8 <_sercom_i2c_sync_send_address+0x6c>
			if (status & SERCOM_I2CM_STATUS_RXNACK) {
     e6a:	075b      	lsls	r3, r3, #29
     e6c:	d41b      	bmi.n	ea6 <_sercom_i2c_sync_send_address+0x13a>
			if (msg->flags & I2C_M_TEN) {
     e6e:	886b      	ldrh	r3, [r5, #2]
     e70:	055b      	lsls	r3, r3, #21
     e72:	d534      	bpl.n	ede <_sercom_i2c_sync_send_address+0x172>
				                              ((((msg->addr & TEN_ADDR_MASK) >> 8) | TEN_ADDR_FRAME) << 1) | I2C_M_RD
     e74:	882a      	ldrh	r2, [r5, #0]
     e76:	1212      	asrs	r2, r2, #8
     e78:	0052      	lsls	r2, r2, #1
				                                  | (hri_sercomi2cm_read_ADDR_reg(hw) & SERCOM_I2CM_ADDR_HS));
     e7a:	2306      	movs	r3, #6
     e7c:	401a      	ands	r2, r3
     e7e:	69e3      	ldr	r3, [r4, #28]
     e80:	075b      	lsls	r3, r3, #29
     e82:	d4fc      	bmi.n	e7e <_sercom_i2c_sync_send_address+0x112>
	return ((Sercom *)hw)->I2CM.ADDR.reg;
     e84:	6a63      	ldr	r3, [r4, #36]	; 0x24
     e86:	2180      	movs	r1, #128	; 0x80
     e88:	01c9      	lsls	r1, r1, #7
     e8a:	400b      	ands	r3, r1
     e8c:	4313      	orrs	r3, r2
				hri_sercomi2cm_write_ADDR_reg(hw,
     e8e:	22f1      	movs	r2, #241	; 0xf1
     e90:	4313      	orrs	r3, r2
	((Sercom *)hw)->I2CM.ADDR.reg = data;
     e92:	6263      	str	r3, [r4, #36]	; 0x24
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
     e94:	69e3      	ldr	r3, [r4, #28]
     e96:	075b      	lsls	r3, r3, #29
     e98:	d4fc      	bmi.n	e94 <_sercom_i2c_sync_send_address+0x128>
				msg->flags &= ~I2C_M_TEN;
     e9a:	886b      	ldrh	r3, [r5, #2]
     e9c:	4a4e      	ldr	r2, [pc, #312]	; (fd8 <_sercom_i2c_sync_send_address+0x26c>)
     e9e:	4013      	ands	r3, r2
     ea0:	806b      	strh	r3, [r5, #2]
				return I2C_OK;
     ea2:	2000      	movs	r0, #0
     ea4:	e065      	b.n	f72 <_sercom_i2c_sync_send_address+0x206>
				if (msg->len > 0) {
     ea6:	686b      	ldr	r3, [r5, #4]
     ea8:	2b00      	cmp	r3, #0
     eaa:	dd04      	ble.n	eb6 <_sercom_i2c_sync_send_address+0x14a>
					msg->flags |= I2C_M_FAIL;
     eac:	886b      	ldrh	r3, [r5, #2]
     eae:	2280      	movs	r2, #128	; 0x80
     eb0:	0152      	lsls	r2, r2, #5
     eb2:	4313      	orrs	r3, r2
     eb4:	806b      	strh	r3, [r5, #2]
				if (msg->flags & I2C_M_STOP) {
     eb6:	886b      	ldrh	r3, [r5, #2]
     eb8:	b21b      	sxth	r3, r3
     eba:	2b00      	cmp	r3, #0
     ebc:	db06      	blt.n	ecc <_sercom_i2c_sync_send_address+0x160>
				msg->flags &= ~I2C_M_BUSY;
     ebe:	886b      	ldrh	r3, [r5, #2]
     ec0:	4a44      	ldr	r2, [pc, #272]	; (fd4 <_sercom_i2c_sync_send_address+0x268>)
     ec2:	4013      	ands	r3, r2
     ec4:	806b      	strh	r3, [r5, #2]
				return I2C_NACK;
     ec6:	2002      	movs	r0, #2
     ec8:	4240      	negs	r0, r0
     eca:	e052      	b.n	f72 <_sercom_i2c_sync_send_address+0x206>
	((Sercom *)hw)->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_CMD(mask);
     ecc:	6862      	ldr	r2, [r4, #4]
     ece:	23c0      	movs	r3, #192	; 0xc0
     ed0:	029b      	lsls	r3, r3, #10
     ed2:	4313      	orrs	r3, r2
     ed4:	6063      	str	r3, [r4, #4]
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
     ed6:	69e3      	ldr	r3, [r4, #28]
     ed8:	075b      	lsls	r3, r3, #29
     eda:	d4fc      	bmi.n	ed6 <_sercom_i2c_sync_send_address+0x16a>
     edc:	e7ef      	b.n	ebe <_sercom_i2c_sync_send_address+0x152>
			if (msg->len == 0) {
     ede:	6868      	ldr	r0, [r5, #4]
     ee0:	2800      	cmp	r0, #0
     ee2:	d111      	bne.n	f08 <_sercom_i2c_sync_send_address+0x19c>
				if (msg->flags & I2C_M_STOP) {
     ee4:	886b      	ldrh	r3, [r5, #2]
     ee6:	b21b      	sxth	r3, r3
     ee8:	2b00      	cmp	r3, #0
     eea:	db04      	blt.n	ef6 <_sercom_i2c_sync_send_address+0x18a>
				msg->flags &= ~I2C_M_BUSY;
     eec:	886b      	ldrh	r3, [r5, #2]
     eee:	4a39      	ldr	r2, [pc, #228]	; (fd4 <_sercom_i2c_sync_send_address+0x268>)
     ef0:	4013      	ands	r3, r2
     ef2:	806b      	strh	r3, [r5, #2]
     ef4:	e03d      	b.n	f72 <_sercom_i2c_sync_send_address+0x206>
	((Sercom *)hw)->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_CMD(mask);
     ef6:	6862      	ldr	r2, [r4, #4]
     ef8:	23c0      	movs	r3, #192	; 0xc0
     efa:	029b      	lsls	r3, r3, #10
     efc:	4313      	orrs	r3, r2
     efe:	6063      	str	r3, [r4, #4]
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
     f00:	69e3      	ldr	r3, [r4, #28]
     f02:	075b      	lsls	r3, r3, #29
     f04:	d4fc      	bmi.n	f00 <_sercom_i2c_sync_send_address+0x194>
     f06:	e7f1      	b.n	eec <_sercom_i2c_sync_send_address+0x180>
				hri_sercomi2cm_write_DATA_reg(hw, *msg->buffer);
     f08:	68ab      	ldr	r3, [r5, #8]
     f0a:	781a      	ldrb	r2, [r3, #0]
	((Sercom *)hw)->I2CM.DATA.reg = data;
     f0c:	2328      	movs	r3, #40	; 0x28
     f0e:	54e2      	strb	r2, [r4, r3]
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
     f10:	69e3      	ldr	r3, [r4, #28]
     f12:	075b      	lsls	r3, r3, #29
     f14:	d4fc      	bmi.n	f10 <_sercom_i2c_sync_send_address+0x1a4>
				msg->buffer++;
     f16:	68ab      	ldr	r3, [r5, #8]
     f18:	3301      	adds	r3, #1
     f1a:	60ab      	str	r3, [r5, #8]
				msg->len--;
     f1c:	686b      	ldr	r3, [r5, #4]
     f1e:	3b01      	subs	r3, #1
     f20:	606b      	str	r3, [r5, #4]
			return I2C_OK;
     f22:	2000      	movs	r0, #0
     f24:	e025      	b.n	f72 <_sercom_i2c_sync_send_address+0x206>
	} else if (flags & SB_FLAG) {
     f26:	0781      	lsls	r1, r0, #30
     f28:	d547      	bpl.n	fba <_sercom_i2c_sync_send_address+0x24e>
		if ((msg->len) && !(status & SERCOM_I2CM_STATUS_RXNACK)) {
     f2a:	6869      	ldr	r1, [r5, #4]
     f2c:	2900      	cmp	r1, #0
     f2e:	d03c      	beq.n	faa <_sercom_i2c_sync_send_address+0x23e>
     f30:	075b      	lsls	r3, r3, #29
     f32:	d43a      	bmi.n	faa <_sercom_i2c_sync_send_address+0x23e>
			msg->len--;
     f34:	3901      	subs	r1, #1
     f36:	6069      	str	r1, [r5, #4]
			if ((msg->len == 0 && !sclsm) || (msg->len == 1 && sclsm)) {
     f38:	2900      	cmp	r1, #0
     f3a:	d101      	bne.n	f40 <_sercom_i2c_sync_send_address+0x1d4>
     f3c:	2a00      	cmp	r2, #0
     f3e:	d01b      	beq.n	f78 <_sercom_i2c_sync_send_address+0x20c>
     f40:	2901      	cmp	r1, #1
     f42:	d017      	beq.n	f74 <_sercom_i2c_sync_send_address+0x208>
			if (msg->len == 0) {
     f44:	686b      	ldr	r3, [r5, #4]
     f46:	2b00      	cmp	r3, #0
     f48:	d107      	bne.n	f5a <_sercom_i2c_sync_send_address+0x1ee>
				if (msg->flags & I2C_M_STOP) {
     f4a:	886b      	ldrh	r3, [r5, #2]
     f4c:	b21b      	sxth	r3, r3
     f4e:	2b00      	cmp	r3, #0
     f50:	db1b      	blt.n	f8a <_sercom_i2c_sync_send_address+0x21e>
				msg->flags &= ~I2C_M_BUSY;
     f52:	886b      	ldrh	r3, [r5, #2]
     f54:	4a1f      	ldr	r2, [pc, #124]	; (fd4 <_sercom_i2c_sync_send_address+0x268>)
     f56:	4013      	ands	r3, r2
     f58:	806b      	strh	r3, [r5, #2]
			*msg->buffer++ = hri_sercomi2cm_read_DATA_reg(hw);
     f5a:	68aa      	ldr	r2, [r5, #8]
     f5c:	1c53      	adds	r3, r2, #1
     f5e:	60ab      	str	r3, [r5, #8]
     f60:	69e3      	ldr	r3, [r4, #28]
     f62:	075b      	lsls	r3, r3, #29
     f64:	d4fc      	bmi.n	f60 <_sercom_i2c_sync_send_address+0x1f4>
	return ((Sercom *)hw)->I2CM.DATA.reg;
     f66:	2328      	movs	r3, #40	; 0x28
     f68:	5ce3      	ldrb	r3, [r4, r3]
     f6a:	7013      	strb	r3, [r2, #0]
	((Sercom *)hw)->I2CM.INTFLAG.reg = SERCOM_I2CM_INTFLAG_SB;
     f6c:	2302      	movs	r3, #2
     f6e:	7623      	strb	r3, [r4, #24]
	return I2C_OK;
     f70:	2000      	movs	r0, #0
}
     f72:	bd70      	pop	{r4, r5, r6, pc}
			if ((msg->len == 0 && !sclsm) || (msg->len == 1 && sclsm)) {
     f74:	2a00      	cmp	r2, #0
     f76:	d0e5      	beq.n	f44 <_sercom_i2c_sync_send_address+0x1d8>
	((Sercom *)hw)->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_ACKACT;
     f78:	6862      	ldr	r2, [r4, #4]
     f7a:	2380      	movs	r3, #128	; 0x80
     f7c:	02db      	lsls	r3, r3, #11
     f7e:	4313      	orrs	r3, r2
     f80:	6063      	str	r3, [r4, #4]
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
     f82:	69e3      	ldr	r3, [r4, #28]
     f84:	075b      	lsls	r3, r3, #29
     f86:	d4fc      	bmi.n	f82 <_sercom_i2c_sync_send_address+0x216>
     f88:	e7dc      	b.n	f44 <_sercom_i2c_sync_send_address+0x1d8>
	((Sercom *)hw)->I2CM.CTRLB.reg &= ~SERCOM_I2CM_CTRLB_SMEN;
     f8a:	6863      	ldr	r3, [r4, #4]
     f8c:	4a11      	ldr	r2, [pc, #68]	; (fd4 <_sercom_i2c_sync_send_address+0x268>)
     f8e:	4013      	ands	r3, r2
     f90:	6063      	str	r3, [r4, #4]
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
     f92:	69e3      	ldr	r3, [r4, #28]
     f94:	075b      	lsls	r3, r3, #29
     f96:	d4fc      	bmi.n	f92 <_sercom_i2c_sync_send_address+0x226>
	((Sercom *)hw)->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_CMD(mask);
     f98:	6862      	ldr	r2, [r4, #4]
     f9a:	23c0      	movs	r3, #192	; 0xc0
     f9c:	029b      	lsls	r3, r3, #10
     f9e:	4313      	orrs	r3, r2
     fa0:	6063      	str	r3, [r4, #4]
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
     fa2:	69e3      	ldr	r3, [r4, #28]
     fa4:	075b      	lsls	r3, r3, #29
     fa6:	d4fc      	bmi.n	fa2 <_sercom_i2c_sync_send_address+0x236>
     fa8:	e7d3      	b.n	f52 <_sercom_i2c_sync_send_address+0x1e6>
	((Sercom *)hw)->I2CM.INTFLAG.reg = SERCOM_I2CM_INTFLAG_SB;
     faa:	2302      	movs	r3, #2
     fac:	7623      	strb	r3, [r4, #24]
			return I2C_NACK;
     fae:	2002      	movs	r0, #2
     fb0:	4240      	negs	r0, r0
     fb2:	e7de      	b.n	f72 <_sercom_i2c_sync_send_address+0x206>
			return I2C_ERR_BAD_ADDRESS;
     fb4:	2004      	movs	r0, #4
     fb6:	4240      	negs	r0, r0
     fb8:	e7db      	b.n	f72 <_sercom_i2c_sync_send_address+0x206>
	return I2C_OK;
     fba:	2000      	movs	r0, #0
	return _sercom_i2c_sync_analyse_flags(hw, flags, msg);
     fbc:	e7d9      	b.n	f72 <_sercom_i2c_sync_send_address+0x206>
     fbe:	46c0      	nop			; (mov r8, r8)
     fc0:	00000594 	.word	0x00000594
     fc4:	00005f20 	.word	0x00005f20
     fc8:	fffbffff 	.word	0xfffbffff
     fcc:	000007fe 	.word	0x000007fe
     fd0:	0000ffff 	.word	0x0000ffff
     fd4:	fffffeff 	.word	0xfffffeff
     fd8:	fffffbff 	.word	0xfffffbff

00000fdc <_usart_sync_init>:
{
     fdc:	b570      	push	{r4, r5, r6, lr}
     fde:	0005      	movs	r5, r0
     fe0:	000c      	movs	r4, r1
	ASSERT(device);
     fe2:	1e43      	subs	r3, r0, #1
     fe4:	4198      	sbcs	r0, r3
     fe6:	b2c0      	uxtb	r0, r0
     fe8:	22b4      	movs	r2, #180	; 0xb4
     fea:	4904      	ldr	r1, [pc, #16]	; (ffc <_usart_sync_init+0x20>)
     fec:	4479      	add	r1, pc
     fee:	f7ff fc35 	bl	85c <assert>
	device->hw = hw;
     ff2:	602c      	str	r4, [r5, #0]
	return _usart_init(hw);
     ff4:	0020      	movs	r0, r4
     ff6:	f7ff fd9b 	bl	b30 <_usart_init>
}
     ffa:	bd70      	pop	{r4, r5, r6, pc}
     ffc:	00005cb8 	.word	0x00005cb8

00001000 <_usart_sync_enable>:
	hri_sercomusart_set_CTRLA_ENABLE_bit(device->hw);
    1000:	6802      	ldr	r2, [r0, #0]
	((Sercom *)hw)->USART.CTRLA.reg |= SERCOM_USART_CTRLA_ENABLE;
    1002:	6813      	ldr	r3, [r2, #0]
    1004:	2102      	movs	r1, #2
    1006:	430b      	orrs	r3, r1
    1008:	6013      	str	r3, [r2, #0]
	while (((Sercom *)hw)->USART.SYNCBUSY.reg & reg) {
    100a:	69d3      	ldr	r3, [r2, #28]
    100c:	079b      	lsls	r3, r3, #30
    100e:	d1fc      	bne.n	100a <_usart_sync_enable+0xa>
}
    1010:	4770      	bx	lr

00001012 <_usart_sync_write_byte>:
	hri_sercomusart_write_DATA_reg(device->hw, data);
    1012:	6803      	ldr	r3, [r0, #0]
    1014:	b289      	uxth	r1, r1
	((Sercom *)hw)->USART.DATA.reg = data;
    1016:	8519      	strh	r1, [r3, #40]	; 0x28
}
    1018:	4770      	bx	lr

0000101a <_usart_sync_read_byte>:
	return hri_sercomusart_read_DATA_reg(device->hw);
    101a:	6803      	ldr	r3, [r0, #0]
	return ((Sercom *)hw)->USART.DATA.reg;
    101c:	8d18      	ldrh	r0, [r3, #40]	; 0x28
    101e:	b2c0      	uxtb	r0, r0
}
    1020:	4770      	bx	lr

00001022 <_usart_sync_is_ready_to_send>:
	return hri_sercomusart_get_interrupt_DRE_bit(device->hw);
    1022:	6803      	ldr	r3, [r0, #0]
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_DRE) >> SERCOM_USART_INTFLAG_DRE_Pos;
    1024:	7e18      	ldrb	r0, [r3, #24]
    1026:	2301      	movs	r3, #1
    1028:	4018      	ands	r0, r3
}
    102a:	4770      	bx	lr

0000102c <_usart_sync_is_transmit_done>:
	return hri_sercomusart_get_interrupt_TXC_bit(device->hw);
    102c:	6803      	ldr	r3, [r0, #0]
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_TXC) >> SERCOM_USART_INTFLAG_TXC_Pos;
    102e:	7e1b      	ldrb	r3, [r3, #24]
    1030:	085b      	lsrs	r3, r3, #1
    1032:	2001      	movs	r0, #1
    1034:	4018      	ands	r0, r3
}
    1036:	4770      	bx	lr

00001038 <_usart_sync_is_byte_received>:
	return hri_sercomusart_get_interrupt_RXC_bit(device->hw);
    1038:	6803      	ldr	r3, [r0, #0]
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_RXC) >> SERCOM_USART_INTFLAG_RXC_Pos;
    103a:	7e1b      	ldrb	r3, [r3, #24]
    103c:	089b      	lsrs	r3, r3, #2
    103e:	2001      	movs	r0, #1
    1040:	4018      	ands	r0, r3
}
    1042:	4770      	bx	lr

00001044 <_i2c_m_sync_init>:
{
    1044:	b570      	push	{r4, r5, r6, lr}
    1046:	0004      	movs	r4, r0
    1048:	000d      	movs	r5, r1
	ASSERT(i2c_dev);
    104a:	1e43      	subs	r3, r0, #1
    104c:	4198      	sbcs	r0, r3
    104e:	b2c0      	uxtb	r0, r0
    1050:	4a05      	ldr	r2, [pc, #20]	; (1068 <_i2c_m_sync_init+0x24>)
    1052:	4906      	ldr	r1, [pc, #24]	; (106c <_i2c_m_sync_init+0x28>)
    1054:	4479      	add	r1, pc
    1056:	f7ff fc01 	bl	85c <assert>
	i2c_dev->hw = hw;
    105a:	6125      	str	r5, [r4, #16]
	return _i2c_m_sync_init_impl(&i2c_dev->service, hw);
    105c:	0029      	movs	r1, r5
    105e:	0020      	movs	r0, r4
    1060:	f7ff fe12 	bl	c88 <_i2c_m_sync_init_impl>
}
    1064:	bd70      	pop	{r4, r5, r6, pc}
    1066:	46c0      	nop			; (mov r8, r8)
    1068:	00000507 	.word	0x00000507
    106c:	00005c50 	.word	0x00005c50

00001070 <_i2c_m_sync_enable>:
{
    1070:	b570      	push	{r4, r5, r6, lr}
    1072:	0004      	movs	r4, r0
	ASSERT(i2c_dev);
    1074:	4d1a      	ldr	r5, [pc, #104]	; (10e0 <_i2c_m_sync_enable+0x70>)
    1076:	447d      	add	r5, pc
    1078:	1e43      	subs	r3, r0, #1
    107a:	4198      	sbcs	r0, r3
    107c:	b2c0      	uxtb	r0, r0
    107e:	4a19      	ldr	r2, [pc, #100]	; (10e4 <_i2c_m_sync_enable+0x74>)
    1080:	0029      	movs	r1, r5
    1082:	f7ff fbeb 	bl	85c <assert>
	return _i2c_m_enable_implementation(i2c_dev->hw);
    1086:	6924      	ldr	r4, [r4, #16]
	ASSERT(hw);
    1088:	0020      	movs	r0, r4
    108a:	1e43      	subs	r3, r0, #1
    108c:	4198      	sbcs	r0, r3
    108e:	b2c0      	uxtb	r0, r0
    1090:	4a15      	ldr	r2, [pc, #84]	; (10e8 <_i2c_m_sync_enable+0x78>)
    1092:	0029      	movs	r1, r5
    1094:	f7ff fbe2 	bl	85c <assert>
	((Sercom *)hw)->I2CM.CTRLA.reg |= SERCOM_I2CM_CTRLA_ENABLE;
    1098:	6823      	ldr	r3, [r4, #0]
    109a:	2202      	movs	r2, #2
    109c:	4313      	orrs	r3, r2
    109e:	6023      	str	r3, [r4, #0]
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    10a0:	69e3      	ldr	r3, [r4, #28]
    10a2:	079b      	lsls	r3, r3, #30
    10a4:	d1fc      	bne.n	10a0 <_i2c_m_sync_enable+0x30>
    10a6:	2004      	movs	r0, #4
    10a8:	4910      	ldr	r1, [pc, #64]	; (10ec <_i2c_m_sync_enable+0x7c>)
    10aa:	69e3      	ldr	r3, [r4, #28]
    10ac:	075b      	lsls	r3, r3, #29
    10ae:	d4fc      	bmi.n	10aa <_i2c_m_sync_enable+0x3a>
	return (((Sercom *)hw)->I2CM.STATUS.reg & SERCOM_I2CM_STATUS_BUSSTATE_Msk) >> SERCOM_I2CM_STATUS_BUSSTATE_Pos;
    10b0:	8b62      	ldrh	r2, [r4, #26]
    10b2:	0912      	lsrs	r2, r2, #4
    10b4:	2303      	movs	r3, #3
    10b6:	4013      	ands	r3, r2
	while (hri_sercomi2cm_read_STATUS_BUSSTATE_bf(hw) != I2C_IDLE) {
    10b8:	2b01      	cmp	r3, #1
    10ba:	d00b      	beq.n	10d4 <_i2c_m_sync_enable+0x64>
		timeout--;
    10bc:	3901      	subs	r1, #1
		if (timeout <= 0) {
    10be:	2900      	cmp	r1, #0
    10c0:	dcf3      	bgt.n	10aa <_i2c_m_sync_enable+0x3a>
			if (--timeout_attempt)
    10c2:	3801      	subs	r0, #1
    10c4:	2800      	cmp	r0, #0
    10c6:	d007      	beq.n	10d8 <_i2c_m_sync_enable+0x68>
}

static inline void hri_sercomi2cm_clear_STATUS_reg(const void *const hw, hri_sercomi2cm_status_reg_t mask)
{
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->I2CM.STATUS.reg = mask;
    10c8:	2310      	movs	r3, #16
    10ca:	8363      	strh	r3, [r4, #26]
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    10cc:	69e3      	ldr	r3, [r4, #28]
    10ce:	075b      	lsls	r3, r3, #29
    10d0:	d4fc      	bmi.n	10cc <_i2c_m_sync_enable+0x5c>
    10d2:	e7e9      	b.n	10a8 <_i2c_m_sync_enable+0x38>
	return ERR_NONE;
    10d4:	2000      	movs	r0, #0
}
    10d6:	bd70      	pop	{r4, r5, r6, pc}
				return I2C_ERR_BUSY;
    10d8:	2006      	movs	r0, #6
    10da:	4240      	negs	r0, r0
	return _i2c_m_enable_implementation(i2c_dev->hw);
    10dc:	e7fb      	b.n	10d6 <_i2c_m_sync_enable+0x66>
    10de:	46c0      	nop			; (mov r8, r8)
    10e0:	00005c2e 	.word	0x00005c2e
    10e4:	00000524 	.word	0x00000524
    10e8:	000005f4 	.word	0x000005f4
    10ec:	0000ffff 	.word	0x0000ffff

000010f0 <_i2c_m_sync_transfer>:
{
    10f0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    10f2:	0005      	movs	r5, r0
    10f4:	000e      	movs	r6, r1
	void *   hw = i2c_dev->hw;
    10f6:	6904      	ldr	r4, [r0, #16]
	ASSERT(i2c_dev);
    10f8:	4f96      	ldr	r7, [pc, #600]	; (1354 <_i2c_m_sync_transfer+0x264>)
    10fa:	447f      	add	r7, pc
    10fc:	1e43      	subs	r3, r0, #1
    10fe:	4198      	sbcs	r0, r3
    1100:	b2c0      	uxtb	r0, r0
    1102:	4a95      	ldr	r2, [pc, #596]	; (1358 <_i2c_m_sync_transfer+0x268>)
    1104:	0039      	movs	r1, r7
    1106:	f7ff fba9 	bl	85c <assert>
	ASSERT(i2c_dev->hw);
    110a:	6928      	ldr	r0, [r5, #16]
    110c:	1e43      	subs	r3, r0, #1
    110e:	4198      	sbcs	r0, r3
    1110:	b2c0      	uxtb	r0, r0
    1112:	22b8      	movs	r2, #184	; 0xb8
    1114:	00d2      	lsls	r2, r2, #3
    1116:	0039      	movs	r1, r7
    1118:	f7ff fba0 	bl	85c <assert>
	ASSERT(msg);
    111c:	0030      	movs	r0, r6
    111e:	1e43      	subs	r3, r0, #1
    1120:	4198      	sbcs	r0, r3
    1122:	b2c0      	uxtb	r0, r0
    1124:	4a8d      	ldr	r2, [pc, #564]	; (135c <_i2c_m_sync_transfer+0x26c>)
    1126:	0039      	movs	r1, r7
    1128:	f7ff fb98 	bl	85c <assert>
	if (i2c_dev->service.msg.flags & I2C_M_BUSY) {
    112c:	886b      	ldrh	r3, [r5, #2]
    112e:	05db      	lsls	r3, r3, #23
    1130:	d500      	bpl.n	1134 <_i2c_m_sync_transfer+0x44>
    1132:	e10b      	b.n	134c <_i2c_m_sync_transfer+0x25c>
	msg->flags |= I2C_M_BUSY;
    1134:	8872      	ldrh	r2, [r6, #2]
    1136:	2380      	movs	r3, #128	; 0x80
    1138:	005b      	lsls	r3, r3, #1
    113a:	469c      	mov	ip, r3
    113c:	431a      	orrs	r2, r3
    113e:	8072      	strh	r2, [r6, #2]
	i2c_dev->service.msg = *msg;
    1140:	002a      	movs	r2, r5
    1142:	0031      	movs	r1, r6
    1144:	c989      	ldmia	r1!, {r0, r3, r7}
    1146:	c289      	stmia	r2!, {r0, r3, r7}
	((Sercom *)hw)->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_SMEN;
    1148:	6862      	ldr	r2, [r4, #4]
    114a:	4663      	mov	r3, ip
    114c:	4313      	orrs	r3, r2
    114e:	6063      	str	r3, [r4, #4]
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    1150:	69e3      	ldr	r3, [r4, #28]
    1152:	075b      	lsls	r3, r3, #29
    1154:	d4fc      	bmi.n	1150 <_i2c_m_sync_transfer+0x60>
	ret = _sercom_i2c_sync_send_address(i2c_dev);
    1156:	0028      	movs	r0, r5
    1158:	f7ff fe08 	bl	d6c <_sercom_i2c_sync_send_address>
	if (ret) {
    115c:	2800      	cmp	r0, #0
    115e:	d100      	bne.n	1162 <_i2c_m_sync_transfer+0x72>
    1160:	e09d      	b.n	129e <_i2c_m_sync_transfer+0x1ae>
		i2c_dev->service.msg.flags &= ~I2C_M_BUSY;
    1162:	886b      	ldrh	r3, [r5, #2]
    1164:	4a7e      	ldr	r2, [pc, #504]	; (1360 <_i2c_m_sync_transfer+0x270>)
    1166:	4013      	ands	r3, r2
    1168:	806b      	strh	r3, [r5, #2]
}
    116a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			return I2C_ERR_BUS;
    116c:	2005      	movs	r0, #5
    116e:	4240      	negs	r0, r0
    1170:	e0a6      	b.n	12c0 <_i2c_m_sync_transfer+0x1d0>
			if (msg->flags & I2C_M_STOP) {
    1172:	8873      	ldrh	r3, [r6, #2]
    1174:	b21b      	sxth	r3, r3
    1176:	2b00      	cmp	r3, #0
    1178:	db04      	blt.n	1184 <_i2c_m_sync_transfer+0x94>
			i2c_dev->service.msg.flags &= ~I2C_M_BUSY;
    117a:	886b      	ldrh	r3, [r5, #2]
    117c:	4a78      	ldr	r2, [pc, #480]	; (1360 <_i2c_m_sync_transfer+0x270>)
    117e:	4013      	ands	r3, r2
    1180:	806b      	strh	r3, [r5, #2]
			return ret;
    1182:	e7f2      	b.n	116a <_i2c_m_sync_transfer+0x7a>
	((Sercom *)hw)->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_CMD(mask);
    1184:	6862      	ldr	r2, [r4, #4]
    1186:	23c0      	movs	r3, #192	; 0xc0
    1188:	029b      	lsls	r3, r3, #10
    118a:	4313      	orrs	r3, r2
    118c:	6063      	str	r3, [r4, #4]
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    118e:	69e3      	ldr	r3, [r4, #28]
    1190:	075b      	lsls	r3, r3, #29
    1192:	d4fc      	bmi.n	118e <_i2c_m_sync_transfer+0x9e>
    1194:	e7f1      	b.n	117a <_i2c_m_sync_transfer+0x8a>
			if (status & SERCOM_I2CM_STATUS_RXNACK) {
    1196:	0753      	lsls	r3, r2, #29
    1198:	d41b      	bmi.n	11d2 <_i2c_m_sync_transfer+0xe2>
			if (msg->flags & I2C_M_TEN) {
    119a:	886b      	ldrh	r3, [r5, #2]
    119c:	055b      	lsls	r3, r3, #21
    119e:	d534      	bpl.n	120a <_i2c_m_sync_transfer+0x11a>
				                              ((((msg->addr & TEN_ADDR_MASK) >> 8) | TEN_ADDR_FRAME) << 1) | I2C_M_RD
    11a0:	882a      	ldrh	r2, [r5, #0]
    11a2:	1212      	asrs	r2, r2, #8
    11a4:	0052      	lsls	r2, r2, #1
				                                  | (hri_sercomi2cm_read_ADDR_reg(hw) & SERCOM_I2CM_ADDR_HS));
    11a6:	2306      	movs	r3, #6
    11a8:	401a      	ands	r2, r3
    11aa:	69e3      	ldr	r3, [r4, #28]
    11ac:	075b      	lsls	r3, r3, #29
    11ae:	d4fc      	bmi.n	11aa <_i2c_m_sync_transfer+0xba>
	return ((Sercom *)hw)->I2CM.ADDR.reg;
    11b0:	6a63      	ldr	r3, [r4, #36]	; 0x24
    11b2:	2180      	movs	r1, #128	; 0x80
    11b4:	01c9      	lsls	r1, r1, #7
    11b6:	400b      	ands	r3, r1
    11b8:	4313      	orrs	r3, r2
				hri_sercomi2cm_write_ADDR_reg(hw,
    11ba:	22f1      	movs	r2, #241	; 0xf1
    11bc:	4313      	orrs	r3, r2
	((Sercom *)hw)->I2CM.ADDR.reg = data;
    11be:	6263      	str	r3, [r4, #36]	; 0x24
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    11c0:	69e3      	ldr	r3, [r4, #28]
    11c2:	075b      	lsls	r3, r3, #29
    11c4:	d4fc      	bmi.n	11c0 <_i2c_m_sync_transfer+0xd0>
				msg->flags &= ~I2C_M_TEN;
    11c6:	886b      	ldrh	r3, [r5, #2]
    11c8:	4a66      	ldr	r2, [pc, #408]	; (1364 <_i2c_m_sync_transfer+0x274>)
    11ca:	4013      	ands	r3, r2
    11cc:	806b      	strh	r3, [r5, #2]
				return I2C_OK;
    11ce:	2000      	movs	r0, #0
    11d0:	e065      	b.n	129e <_i2c_m_sync_transfer+0x1ae>
				if (msg->len > 0) {
    11d2:	686b      	ldr	r3, [r5, #4]
    11d4:	2b00      	cmp	r3, #0
    11d6:	dd04      	ble.n	11e2 <_i2c_m_sync_transfer+0xf2>
					msg->flags |= I2C_M_FAIL;
    11d8:	886b      	ldrh	r3, [r5, #2]
    11da:	2280      	movs	r2, #128	; 0x80
    11dc:	0152      	lsls	r2, r2, #5
    11de:	4313      	orrs	r3, r2
    11e0:	806b      	strh	r3, [r5, #2]
				if (msg->flags & I2C_M_STOP) {
    11e2:	886b      	ldrh	r3, [r5, #2]
    11e4:	b21b      	sxth	r3, r3
    11e6:	2b00      	cmp	r3, #0
    11e8:	db06      	blt.n	11f8 <_i2c_m_sync_transfer+0x108>
				msg->flags &= ~I2C_M_BUSY;
    11ea:	886b      	ldrh	r3, [r5, #2]
    11ec:	4a5c      	ldr	r2, [pc, #368]	; (1360 <_i2c_m_sync_transfer+0x270>)
    11ee:	4013      	ands	r3, r2
    11f0:	806b      	strh	r3, [r5, #2]
				return I2C_NACK;
    11f2:	2002      	movs	r0, #2
    11f4:	4240      	negs	r0, r0
    11f6:	e052      	b.n	129e <_i2c_m_sync_transfer+0x1ae>
	((Sercom *)hw)->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_CMD(mask);
    11f8:	6862      	ldr	r2, [r4, #4]
    11fa:	23c0      	movs	r3, #192	; 0xc0
    11fc:	029b      	lsls	r3, r3, #10
    11fe:	4313      	orrs	r3, r2
    1200:	6063      	str	r3, [r4, #4]
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    1202:	69e3      	ldr	r3, [r4, #28]
    1204:	075b      	lsls	r3, r3, #29
    1206:	d4fc      	bmi.n	1202 <_i2c_m_sync_transfer+0x112>
    1208:	e7ef      	b.n	11ea <_i2c_m_sync_transfer+0xfa>
			if (msg->len == 0) {
    120a:	6868      	ldr	r0, [r5, #4]
    120c:	2800      	cmp	r0, #0
    120e:	d111      	bne.n	1234 <_i2c_m_sync_transfer+0x144>
				if (msg->flags & I2C_M_STOP) {
    1210:	886b      	ldrh	r3, [r5, #2]
    1212:	b21b      	sxth	r3, r3
    1214:	2b00      	cmp	r3, #0
    1216:	db04      	blt.n	1222 <_i2c_m_sync_transfer+0x132>
				msg->flags &= ~I2C_M_BUSY;
    1218:	886b      	ldrh	r3, [r5, #2]
    121a:	4a51      	ldr	r2, [pc, #324]	; (1360 <_i2c_m_sync_transfer+0x270>)
    121c:	4013      	ands	r3, r2
    121e:	806b      	strh	r3, [r5, #2]
    1220:	e03d      	b.n	129e <_i2c_m_sync_transfer+0x1ae>
	((Sercom *)hw)->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_CMD(mask);
    1222:	6862      	ldr	r2, [r4, #4]
    1224:	23c0      	movs	r3, #192	; 0xc0
    1226:	029b      	lsls	r3, r3, #10
    1228:	4313      	orrs	r3, r2
    122a:	6063      	str	r3, [r4, #4]
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    122c:	69e3      	ldr	r3, [r4, #28]
    122e:	075b      	lsls	r3, r3, #29
    1230:	d4fc      	bmi.n	122c <_i2c_m_sync_transfer+0x13c>
    1232:	e7f1      	b.n	1218 <_i2c_m_sync_transfer+0x128>
				hri_sercomi2cm_write_DATA_reg(hw, *msg->buffer);
    1234:	68ab      	ldr	r3, [r5, #8]
    1236:	781a      	ldrb	r2, [r3, #0]
	((Sercom *)hw)->I2CM.DATA.reg = data;
    1238:	2328      	movs	r3, #40	; 0x28
    123a:	54e2      	strb	r2, [r4, r3]
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    123c:	69e3      	ldr	r3, [r4, #28]
    123e:	075b      	lsls	r3, r3, #29
    1240:	d4fc      	bmi.n	123c <_i2c_m_sync_transfer+0x14c>
				msg->buffer++;
    1242:	68ab      	ldr	r3, [r5, #8]
    1244:	3301      	adds	r3, #1
    1246:	60ab      	str	r3, [r5, #8]
				msg->len--;
    1248:	686b      	ldr	r3, [r5, #4]
    124a:	3b01      	subs	r3, #1
    124c:	606b      	str	r3, [r5, #4]
			return I2C_OK;
    124e:	2000      	movs	r0, #0
    1250:	e025      	b.n	129e <_i2c_m_sync_transfer+0x1ae>
	} else if (flags & SB_FLAG) {
    1252:	07bb      	lsls	r3, r7, #30
    1254:	d578      	bpl.n	1348 <_i2c_m_sync_transfer+0x258>
		if ((msg->len) && !(status & SERCOM_I2CM_STATUS_RXNACK)) {
    1256:	686b      	ldr	r3, [r5, #4]
    1258:	2b00      	cmp	r3, #0
    125a:	d06d      	beq.n	1338 <_i2c_m_sync_transfer+0x248>
    125c:	0752      	lsls	r2, r2, #29
    125e:	d46b      	bmi.n	1338 <_i2c_m_sync_transfer+0x248>
			msg->len--;
    1260:	3b01      	subs	r3, #1
    1262:	606b      	str	r3, [r5, #4]
			if ((msg->len == 0 && !sclsm) || (msg->len == 1 && sclsm)) {
    1264:	2b00      	cmp	r3, #0
    1266:	d101      	bne.n	126c <_i2c_m_sync_transfer+0x17c>
    1268:	2900      	cmp	r1, #0
    126a:	d04c      	beq.n	1306 <_i2c_m_sync_transfer+0x216>
    126c:	2b01      	cmp	r3, #1
    126e:	d048      	beq.n	1302 <_i2c_m_sync_transfer+0x212>
			if (msg->len == 0) {
    1270:	686b      	ldr	r3, [r5, #4]
    1272:	2b00      	cmp	r3, #0
    1274:	d107      	bne.n	1286 <_i2c_m_sync_transfer+0x196>
				if (msg->flags & I2C_M_STOP) {
    1276:	886b      	ldrh	r3, [r5, #2]
    1278:	b21b      	sxth	r3, r3
    127a:	2b00      	cmp	r3, #0
    127c:	db4c      	blt.n	1318 <_i2c_m_sync_transfer+0x228>
				msg->flags &= ~I2C_M_BUSY;
    127e:	886b      	ldrh	r3, [r5, #2]
    1280:	4a37      	ldr	r2, [pc, #220]	; (1360 <_i2c_m_sync_transfer+0x270>)
    1282:	4013      	ands	r3, r2
    1284:	806b      	strh	r3, [r5, #2]
			*msg->buffer++ = hri_sercomi2cm_read_DATA_reg(hw);
    1286:	68aa      	ldr	r2, [r5, #8]
    1288:	1c53      	adds	r3, r2, #1
    128a:	60ab      	str	r3, [r5, #8]
    128c:	69e3      	ldr	r3, [r4, #28]
    128e:	075b      	lsls	r3, r3, #29
    1290:	d4fc      	bmi.n	128c <_i2c_m_sync_transfer+0x19c>
	return ((Sercom *)hw)->I2CM.DATA.reg;
    1292:	2328      	movs	r3, #40	; 0x28
    1294:	5ce3      	ldrb	r3, [r4, r3]
    1296:	7013      	strb	r3, [r2, #0]
	((Sercom *)hw)->I2CM.INTFLAG.reg = SERCOM_I2CM_INTFLAG_SB;
    1298:	2302      	movs	r3, #2
    129a:	7623      	strb	r3, [r4, #24]
	return I2C_OK;
    129c:	2000      	movs	r0, #0
	while (i2c_dev->service.msg.flags & I2C_M_BUSY) {
    129e:	886b      	ldrh	r3, [r5, #2]
    12a0:	05db      	lsls	r3, r3, #23
    12a2:	d400      	bmi.n	12a6 <_i2c_m_sync_transfer+0x1b6>
    12a4:	e761      	b.n	116a <_i2c_m_sync_transfer+0x7a>
	void *   hw      = i2c_dev->hw;
    12a6:	6928      	ldr	r0, [r5, #16]
	uint32_t timeout = 65535;
    12a8:	4a2f      	ldr	r2, [pc, #188]	; (1368 <_i2c_m_sync_transfer+0x278>)
	return ((Sercom *)hw)->I2CM.INTFLAG.reg;
    12aa:	7e03      	ldrb	r3, [r0, #24]
    12ac:	b2db      	uxtb	r3, r3
		*flags = hri_sercomi2cm_read_INTFLAG_reg(hw);
    12ae:	001f      	movs	r7, r3
		if (timeout-- == 0) {
    12b0:	1e51      	subs	r1, r2, #1
    12b2:	2a00      	cmp	r2, #0
    12b4:	d100      	bne.n	12b8 <_i2c_m_sync_transfer+0x1c8>
    12b6:	e759      	b.n	116c <_i2c_m_sync_transfer+0x7c>
    12b8:	000a      	movs	r2, r1
	} while (!(*flags & MB_FLAG) && !(*flags & SB_FLAG));
    12ba:	079b      	lsls	r3, r3, #30
    12bc:	d0f5      	beq.n	12aa <_i2c_m_sync_transfer+0x1ba>
	return I2C_OK;
    12be:	2000      	movs	r0, #0
		if (ret) {
    12c0:	2800      	cmp	r0, #0
    12c2:	d000      	beq.n	12c6 <_i2c_m_sync_transfer+0x1d6>
    12c4:	e755      	b.n	1172 <_i2c_m_sync_transfer+0x82>
	tmp = ((Sercom *)hw)->I2CM.CTRLA.reg;
    12c6:	6823      	ldr	r3, [r4, #0]
	tmp = (tmp & SERCOM_I2CM_CTRLA_SCLSM) >> SERCOM_I2CM_CTRLA_SCLSM_Pos;
    12c8:	0edb      	lsrs	r3, r3, #27
    12ca:	2101      	movs	r1, #1
    12cc:	4019      	ands	r1, r3
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    12ce:	69e3      	ldr	r3, [r4, #28]
    12d0:	075b      	lsls	r3, r3, #29
    12d2:	d4fc      	bmi.n	12ce <_i2c_m_sync_transfer+0x1de>
	return ((Sercom *)hw)->I2CM.STATUS.reg;
    12d4:	8b62      	ldrh	r2, [r4, #26]
    12d6:	b292      	uxth	r2, r2
	if (flags & MB_FLAG) {
    12d8:	07fb      	lsls	r3, r7, #31
    12da:	d5ba      	bpl.n	1252 <_i2c_m_sync_transfer+0x162>
		if (status & SERCOM_I2CM_STATUS_ARBLOST) {
    12dc:	0793      	lsls	r3, r2, #30
    12de:	d400      	bmi.n	12e2 <_i2c_m_sync_transfer+0x1f2>
    12e0:	e759      	b.n	1196 <_i2c_m_sync_transfer+0xa6>
	((Sercom *)hw)->I2CM.INTFLAG.reg = SERCOM_I2CM_INTFLAG_MB;
    12e2:	2301      	movs	r3, #1
    12e4:	7623      	strb	r3, [r4, #24]
			msg->flags |= I2C_M_FAIL;
    12e6:	886b      	ldrh	r3, [r5, #2]
    12e8:	2180      	movs	r1, #128	; 0x80
    12ea:	0149      	lsls	r1, r1, #5
    12ec:	430b      	orrs	r3, r1
    12ee:	806b      	strh	r3, [r5, #2]
			msg->flags &= ~I2C_M_BUSY;
    12f0:	886b      	ldrh	r3, [r5, #2]
    12f2:	491b      	ldr	r1, [pc, #108]	; (1360 <_i2c_m_sync_transfer+0x270>)
    12f4:	400b      	ands	r3, r1
    12f6:	806b      	strh	r3, [r5, #2]
			if (status & SERCOM_I2CM_STATUS_BUSERR) {
    12f8:	07d3      	lsls	r3, r2, #31
    12fa:	d522      	bpl.n	1342 <_i2c_m_sync_transfer+0x252>
				return I2C_ERR_BUS;
    12fc:	2005      	movs	r0, #5
    12fe:	4240      	negs	r0, r0
    1300:	e7cd      	b.n	129e <_i2c_m_sync_transfer+0x1ae>
			if ((msg->len == 0 && !sclsm) || (msg->len == 1 && sclsm)) {
    1302:	2900      	cmp	r1, #0
    1304:	d0b4      	beq.n	1270 <_i2c_m_sync_transfer+0x180>
	((Sercom *)hw)->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_ACKACT;
    1306:	6862      	ldr	r2, [r4, #4]
    1308:	2380      	movs	r3, #128	; 0x80
    130a:	02db      	lsls	r3, r3, #11
    130c:	4313      	orrs	r3, r2
    130e:	6063      	str	r3, [r4, #4]
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    1310:	69e3      	ldr	r3, [r4, #28]
    1312:	075b      	lsls	r3, r3, #29
    1314:	d4fc      	bmi.n	1310 <_i2c_m_sync_transfer+0x220>
    1316:	e7ab      	b.n	1270 <_i2c_m_sync_transfer+0x180>
	((Sercom *)hw)->I2CM.CTRLB.reg &= ~SERCOM_I2CM_CTRLB_SMEN;
    1318:	6863      	ldr	r3, [r4, #4]
    131a:	4a11      	ldr	r2, [pc, #68]	; (1360 <_i2c_m_sync_transfer+0x270>)
    131c:	4013      	ands	r3, r2
    131e:	6063      	str	r3, [r4, #4]
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    1320:	69e3      	ldr	r3, [r4, #28]
    1322:	075b      	lsls	r3, r3, #29
    1324:	d4fc      	bmi.n	1320 <_i2c_m_sync_transfer+0x230>
	((Sercom *)hw)->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_CMD(mask);
    1326:	6862      	ldr	r2, [r4, #4]
    1328:	23c0      	movs	r3, #192	; 0xc0
    132a:	029b      	lsls	r3, r3, #10
    132c:	4313      	orrs	r3, r2
    132e:	6063      	str	r3, [r4, #4]
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    1330:	69e3      	ldr	r3, [r4, #28]
    1332:	075b      	lsls	r3, r3, #29
    1334:	d4fc      	bmi.n	1330 <_i2c_m_sync_transfer+0x240>
    1336:	e7a2      	b.n	127e <_i2c_m_sync_transfer+0x18e>
	((Sercom *)hw)->I2CM.INTFLAG.reg = SERCOM_I2CM_INTFLAG_SB;
    1338:	2302      	movs	r3, #2
    133a:	7623      	strb	r3, [r4, #24]
			return I2C_NACK;
    133c:	2002      	movs	r0, #2
    133e:	4240      	negs	r0, r0
    1340:	e7ad      	b.n	129e <_i2c_m_sync_transfer+0x1ae>
			return I2C_ERR_BAD_ADDRESS;
    1342:	2004      	movs	r0, #4
    1344:	4240      	negs	r0, r0
    1346:	e7aa      	b.n	129e <_i2c_m_sync_transfer+0x1ae>
	return I2C_OK;
    1348:	2000      	movs	r0, #0
    134a:	e7a8      	b.n	129e <_i2c_m_sync_transfer+0x1ae>
		return I2C_ERR_BUSY;
    134c:	2006      	movs	r0, #6
    134e:	4240      	negs	r0, r0
    1350:	e70b      	b.n	116a <_i2c_m_sync_transfer+0x7a>
    1352:	46c0      	nop			; (mov r8, r8)
    1354:	00005baa 	.word	0x00005baa
    1358:	000005bf 	.word	0x000005bf
    135c:	000005c1 	.word	0x000005c1
    1360:	fffffeff 	.word	0xfffffeff
    1364:	fffffbff 	.word	0xfffffbff
    1368:	0000ffff 	.word	0x0000ffff

0000136c <_sysctrl_init_sources>:
}

static inline void hri_sysctrl_set_OSC32K_ENABLE_bit(const void *const hw)
{
	SYSCTRL_CRITICAL_SECTION_ENTER();
	((Sysctrl *)hw)->OSC32K.reg |= SYSCTRL_OSC32K_ENABLE;
    136c:	4b04      	ldr	r3, [pc, #16]	; (1380 <_sysctrl_init_sources+0x14>)
    136e:	699a      	ldr	r2, [r3, #24]
    1370:	2102      	movs	r1, #2
    1372:	430a      	orrs	r2, r1
    1374:	619a      	str	r2, [r3, #24]
}

static inline hri_sysctrl_osculp32k_reg_t hri_sysctrl_read_OSCULP32K_CALIB_bf(const void *const hw)
{
	uint8_t tmp;
	tmp = ((Sysctrl *)hw)->OSCULP32K.reg;
    1376:	7f1a      	ldrb	r2, [r3, #28]
	tmp = (tmp & SYSCTRL_OSCULP32K_CALIB_Msk) >> SYSCTRL_OSCULP32K_CALIB_Pos;
    1378:	311d      	adds	r1, #29
    137a:	400a      	ands	r2, r1
}

static inline void hri_sysctrl_write_OSCULP32K_reg(const void *const hw, hri_sysctrl_osculp32k_reg_t data)
{
	SYSCTRL_CRITICAL_SECTION_ENTER();
	((Sysctrl *)hw)->OSCULP32K.reg = data;
    137c:	771a      	strb	r2, [r3, #28]
	hri_sysctrl_set_OSC8M_ONDEMAND_bit(hw);
#endif
#endif

	(void)calib, (void)hw;
}
    137e:	4770      	bx	lr
    1380:	40000800 	.word	0x40000800

00001384 <_sysctrl_init_referenced_generators>:
	((Gclk *)hw)->CLKCTRL.reg = data;
    1384:	2282      	movs	r2, #130	; 0x82
    1386:	01d2      	lsls	r2, r2, #7
    1388:	4b1c      	ldr	r3, [pc, #112]	; (13fc <_sysctrl_init_referenced_generators+0x78>)
    138a:	805a      	strh	r2, [r3, #2]
}

static inline void hri_sysctrl_write_DFLLCTRL_reg(const void *const hw, hri_sysctrl_dfllctrl_reg_t data)
{
	SYSCTRL_CRITICAL_SECTION_ENTER();
	((Sysctrl *)hw)->DFLLCTRL.reg = data;
    138c:	2202      	movs	r2, #2
    138e:	4b1c      	ldr	r3, [pc, #112]	; (1400 <_sysctrl_init_referenced_generators+0x7c>)
    1390:	849a      	strh	r2, [r3, #36]	; 0x24
	return (((Sysctrl *)hw)->PCLKSR.reg & SYSCTRL_PCLKSR_DFLLRDY) >> SYSCTRL_PCLKSR_DFLLRDY_Pos;
    1392:	4b1b      	ldr	r3, [pc, #108]	; (1400 <_sysctrl_init_referenced_generators+0x7c>)
    1394:	68db      	ldr	r3, [r3, #12]
	hri_gclk_write_CLKCTRL_reg(GCLK,
	                           GCLK_CLKCTRL_ID(0) | GCLK_CLKCTRL_GEN(CONF_DFLL_GCLK) | (1 << GCLK_CLKCTRL_CLKEN_Pos));
#endif

	hri_sysctrl_write_DFLLCTRL_reg(hw, SYSCTRL_DFLLCTRL_ENABLE);
	while (!hri_sysctrl_get_PCLKSR_DFLLRDY_bit(hw))
    1396:	06db      	lsls	r3, r3, #27
    1398:	d5fb      	bpl.n	1392 <_sysctrl_init_referenced_generators+0xe>
}

static inline void hri_sysctrl_write_DFLLMUL_reg(const void *const hw, hri_sysctrl_dfllmul_reg_t data)
{
	SYSCTRL_CRITICAL_SECTION_ENTER();
	((Sysctrl *)hw)->DFLLMUL.reg = data;
    139a:	4a1a      	ldr	r2, [pc, #104]	; (1404 <_sysctrl_init_referenced_generators+0x80>)
    139c:	4b18      	ldr	r3, [pc, #96]	; (1400 <_sysctrl_init_referenced_generators+0x7c>)
    139e:	62da      	str	r2, [r3, #44]	; 0x2c
		;

	hri_sysctrl_write_DFLLMUL_reg(hw,
	                              SYSCTRL_DFLLMUL_CSTEP(CONF_DFLL_CSTEP) | SYSCTRL_DFLLMUL_FSTEP(CONF_DFLL_FSTEP)
	                                  | SYSCTRL_DFLLMUL_MUL(CONF_DFLL_MUL));
	hri_sysctrl_write_DFLLVAL_reg(hw, CONF_DFLLVAL);
    13a0:	4b19      	ldr	r3, [pc, #100]	; (1408 <_sysctrl_init_referenced_generators+0x84>)
    13a2:	681b      	ldr	r3, [r3, #0]
    13a4:	0e9b      	lsrs	r3, r3, #26
    13a6:	2b3f      	cmp	r3, #63	; 0x3f
    13a8:	d020      	beq.n	13ec <_sysctrl_init_referenced_generators+0x68>
    13aa:	029b      	lsls	r3, r3, #10
    13ac:	2280      	movs	r2, #128	; 0x80
    13ae:	0092      	lsls	r2, r2, #2
    13b0:	4313      	orrs	r3, r2
	((Sysctrl *)hw)->DFLLVAL.reg = data;
    13b2:	4a13      	ldr	r2, [pc, #76]	; (1400 <_sysctrl_init_referenced_generators+0x7c>)
    13b4:	6293      	str	r3, [r2, #40]	; 0x28
	((Sysctrl *)hw)->DFLLCTRL.reg = data;
    13b6:	2306      	movs	r3, #6
    13b8:	8493      	strh	r3, [r2, #36]	; 0x24
	tmp = ((Sysctrl *)hw)->DFLLCTRL.reg;
    13ba:	8c93      	ldrh	r3, [r2, #36]	; 0x24
	        | SYSCTRL_DPLLCTRLB_FILTER(CONF_DPLL_FILTER));
#endif

#if CONF_DFLL_CONFIG == 1
#if CONF_DFLL_ENABLE == 1
	if (hri_sysctrl_get_DFLLCTRL_MODE_bit(hw)) {
    13bc:	075b      	lsls	r3, r3, #29
    13be:	d518      	bpl.n	13f2 <_sysctrl_init_referenced_generators+0x6e>
	tmp = ((Sysctrl *)hw)->PCLKSR.reg;
    13c0:	4b0f      	ldr	r3, [pc, #60]	; (1400 <_sysctrl_init_referenced_generators+0x7c>)
    13c2:	68da      	ldr	r2, [r3, #12]
	tmp &= mask;
    13c4:	23d0      	movs	r3, #208	; 0xd0
    13c6:	4013      	ands	r3, r2
		    = SYSCTRL_PCLKSR_DFLLRDY | SYSCTRL_PCLKSR_DFLLLCKF | SYSCTRL_PCLKSR_DFLLLCKC;
#else
		hri_sysctrl_pclksr_reg_t status_mask = SYSCTRL_PCLKSR_DFLLRDY;
#endif

		while (hri_sysctrl_get_PCLKSR_reg(hw, status_mask) != status_mask)
    13c8:	2bd0      	cmp	r3, #208	; 0xd0
    13ca:	d1f9      	bne.n	13c0 <_sysctrl_init_referenced_generators+0x3c>
	((Sysctrl *)hw)->DFLLCTRL.reg |= SYSCTRL_DFLLCTRL_ONDEMAND;
    13cc:	4a0c      	ldr	r2, [pc, #48]	; (1400 <_sysctrl_init_referenced_generators+0x7c>)
    13ce:	8c93      	ldrh	r3, [r2, #36]	; 0x24
    13d0:	2180      	movs	r1, #128	; 0x80
    13d2:	430b      	orrs	r3, r1
    13d4:	b29b      	uxth	r3, r3
    13d6:	8493      	strh	r3, [r2, #36]	; 0x24
	return (((Gclk *)hw)->STATUS.reg & GCLK_STATUS_SYNCBUSY) >> GCLK_STATUS_SYNCBUSY_Pos;
    13d8:	4b08      	ldr	r3, [pc, #32]	; (13fc <_sysctrl_init_referenced_generators+0x78>)
    13da:	785b      	ldrb	r3, [r3, #1]
	hri_sysctrl_set_DPLLCTRLA_ONDEMAND_bit(hw);
#endif
#endif

#if CONF_DFLL_CONFIG == 1
	while (hri_gclk_get_STATUS_SYNCBUSY_bit(GCLK))
    13dc:	09db      	lsrs	r3, r3, #7
    13de:	d1fb      	bne.n	13d8 <_sysctrl_init_referenced_generators+0x54>
	((Sysctrl *)hw)->OSC32K.reg &= ~SYSCTRL_OSC32K_ENABLE;
    13e0:	4a07      	ldr	r2, [pc, #28]	; (1400 <_sysctrl_init_referenced_generators+0x7c>)
    13e2:	6993      	ldr	r3, [r2, #24]
    13e4:	2102      	movs	r1, #2
    13e6:	438b      	bics	r3, r1
    13e8:	6193      	str	r3, [r2, #24]
	/* Disable after all possible configurations needs sync written. */
	hri_sysctrl_clear_OSC32K_ENABLE_bit(hw);
#endif

	(void)hw;
}
    13ea:	4770      	bx	lr
	hri_sysctrl_write_DFLLVAL_reg(hw, CONF_DFLLVAL);
    13ec:	23fc      	movs	r3, #252	; 0xfc
    13ee:	01db      	lsls	r3, r3, #7
    13f0:	e7df      	b.n	13b2 <_sysctrl_init_referenced_generators+0x2e>
	return (((Sysctrl *)hw)->PCLKSR.reg & SYSCTRL_PCLKSR_DFLLRDY) >> SYSCTRL_PCLKSR_DFLLRDY_Pos;
    13f2:	4b03      	ldr	r3, [pc, #12]	; (1400 <_sysctrl_init_referenced_generators+0x7c>)
    13f4:	68db      	ldr	r3, [r3, #12]
		while (!hri_sysctrl_get_PCLKSR_DFLLRDY_bit(hw))
    13f6:	06db      	lsls	r3, r3, #27
    13f8:	d5fb      	bpl.n	13f2 <_sysctrl_init_referenced_generators+0x6e>
    13fa:	e7e7      	b.n	13cc <_sysctrl_init_referenced_generators+0x48>
    13fc:	40000c00 	.word	0x40000c00
    1400:	40000800 	.word	0x40000800
    1404:	040105b9 	.word	0x040105b9
    1408:	00806024 	.word	0x00806024

0000140c <_system_time_init>:
 * \brief Initialize system time module
 */
void _system_time_init(void *const hw)
{
	(void)hw;
	SysTick->LOAD = (0xFFFFFF << SysTick_LOAD_RELOAD_Pos);
    140c:	4b02      	ldr	r3, [pc, #8]	; (1418 <_system_time_init+0xc>)
    140e:	4a03      	ldr	r2, [pc, #12]	; (141c <_system_time_init+0x10>)
    1410:	605a      	str	r2, [r3, #4]
	SysTick->CTRL = (1 << SysTick_CTRL_ENABLE_Pos) | (CONF_SYSTICK_TICKINT << SysTick_CTRL_TICKINT_Pos)
    1412:	2205      	movs	r2, #5
    1414:	601a      	str	r2, [r3, #0]
	                | (1 << SysTick_CTRL_CLKSOURCE_Pos);
}
    1416:	4770      	bx	lr
    1418:	e000e010 	.word	0xe000e010
    141c:	00ffffff 	.word	0x00ffffff

00001420 <_delay_init>:
/**
 * \brief Initialize delay functionality
 */
void _delay_init(void *const hw)
{
    1420:	b510      	push	{r4, lr}
	_system_time_init(hw);
    1422:	f7ff fff3 	bl	140c <_system_time_init>
}
    1426:	bd10      	pop	{r4, pc}

00001428 <_delay_cycles>:
 * \brief Delay loop to delay n number of cycles
 */
void _delay_cycles(void *const hw, uint32_t cycles)
{
	(void)hw;
	uint8_t  n   = cycles >> 24;
    1428:	0e08      	lsrs	r0, r1, #24
	uint32_t buf = cycles;

	while (n--) {
    142a:	e00b      	b.n	1444 <_delay_cycles+0x1c>
		SysTick->LOAD = 0xFFFFFF;
    142c:	4b0b      	ldr	r3, [pc, #44]	; (145c <_delay_cycles+0x34>)
    142e:	480c      	ldr	r0, [pc, #48]	; (1460 <_delay_cycles+0x38>)
    1430:	6058      	str	r0, [r3, #4]
		SysTick->VAL  = 0xFFFFFF;
    1432:	6098      	str	r0, [r3, #8]
		while (!(SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk))
    1434:	4b09      	ldr	r3, [pc, #36]	; (145c <_delay_cycles+0x34>)
    1436:	681b      	ldr	r3, [r3, #0]
    1438:	03db      	lsls	r3, r3, #15
    143a:	d5fb      	bpl.n	1434 <_delay_cycles+0xc>
			;
		buf -= 0xFFFFFF;
    143c:	4b09      	ldr	r3, [pc, #36]	; (1464 <_delay_cycles+0x3c>)
    143e:	469c      	mov	ip, r3
    1440:	4461      	add	r1, ip
	while (n--) {
    1442:	0010      	movs	r0, r2
    1444:	1e42      	subs	r2, r0, #1
    1446:	b2d2      	uxtb	r2, r2
    1448:	2800      	cmp	r0, #0
    144a:	d1ef      	bne.n	142c <_delay_cycles+0x4>
	}

	SysTick->LOAD = buf;
    144c:	4b03      	ldr	r3, [pc, #12]	; (145c <_delay_cycles+0x34>)
    144e:	6059      	str	r1, [r3, #4]
	SysTick->VAL  = buf;
    1450:	6099      	str	r1, [r3, #8]
	while (!(SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk))
    1452:	4b02      	ldr	r3, [pc, #8]	; (145c <_delay_cycles+0x34>)
    1454:	681b      	ldr	r3, [r3, #0]
    1456:	03db      	lsls	r3, r3, #15
    1458:	d5fb      	bpl.n	1452 <_delay_cycles+0x2a>
		;
}
    145a:	4770      	bx	lr
    145c:	e000e010 	.word	0xe000e010
    1460:	00ffffff 	.word	0x00ffffff
    1464:	ff000001 	.word	0xff000001

00001468 <main>:

mcp794xx_irq_callback_t mcp794x_irq_cb = mcp794xx_basic_irq_handler;	/**< define a callback function for external interrupt */


int main(void)
{
    1468:	b5f0      	push	{r4, r5, r6, r7, lr}
    146a:	b087      	sub	sp, #28
    146c:	4dc5      	ldr	r5, [pc, #788]	; (1784 <main+0x31c>)
    146e:	447d      	add	r5, pc
	/* Initializes MCU, drivers and middle-ware */
	atmel_start_init();
    1470:	f7fe fe50 	bl	114 <atmel_start_init>
	
	err = mcp794xx_basic_initialize(MCP79412_VARIANT);				/**< initialize device driver  passing in the correct variant*/
    1474:	2007      	movs	r0, #7
    1476:	f002 ffc3 	bl	4400 <mcp794xx_basic_initialize>
    147a:	1e01      	subs	r1, r0, #0
	if(err != MCP794XX_DRV_OK){
    147c:	d173      	bne.n	1566 <main+0xfe>
		mcp794xx_interface_debug_print("initialize failed, error code: %d\r", err);
	}
	err = mcp794xx_info(&mcp794xx_handler);
    147e:	4cc2      	ldr	r4, [pc, #776]	; (1788 <main+0x320>)
    1480:	447c      	add	r4, pc
    1482:	0020      	movs	r0, r4
    1484:	f002 ff80 	bl	4388 <mcp794xx_info>

	mcp794xx_interface_debug_print("Chip name :\t%s\n\r", mcp794xx_handler.info.chip_name);
    1488:	0021      	movs	r1, r4
    148a:	3124      	adds	r1, #36	; 0x24
    148c:	48bf      	ldr	r0, [pc, #764]	; (178c <main+0x324>)
    148e:	4478      	add	r0, pc
    1490:	f003 faa0 	bl	49d4 <mcp794xx_interface_debug_print>
	mcp794xx_interface_debug_print("Manufacturer: \t%s\n\r",  mcp794xx_handler.info.manufacturer_name);
    1494:	0021      	movs	r1, r4
    1496:	312e      	adds	r1, #46	; 0x2e
    1498:	48bd      	ldr	r0, [pc, #756]	; (1790 <main+0x328>)
    149a:	4478      	add	r0, pc
    149c:	f003 fa9a 	bl	49d4 <mcp794xx_interface_debug_print>

	mcp794xx_interface_debug_print("Interface: \t%s\n\r",  mcp794xx_handler.info.interface);
    14a0:	0021      	movs	r1, r4
    14a2:	3147      	adds	r1, #71	; 0x47
    14a4:	48bb      	ldr	r0, [pc, #748]	; (1794 <main+0x32c>)
    14a6:	4478      	add	r0, pc
    14a8:	f003 fa94 	bl	49d4 <mcp794xx_interface_debug_print>
	mcp794xx_interface_debug_print("Supply voltage max : \t%0.2fV\n\r",  mcp794xx_handler.info.supply_voltage_max_v);
    14ac:	6d20      	ldr	r0, [r4, #80]	; 0x50
    14ae:	f004 fcc7 	bl	5e40 <__aeabi_f2d>
    14b2:	0002      	movs	r2, r0
    14b4:	000b      	movs	r3, r1
    14b6:	48b8      	ldr	r0, [pc, #736]	; (1798 <main+0x330>)
    14b8:	4478      	add	r0, pc
    14ba:	f003 fa8b 	bl	49d4 <mcp794xx_interface_debug_print>
	mcp794xx_interface_debug_print("Supply voltage min: \t%0.2fV\n\r",  mcp794xx_handler.info.supply_voltage_min_v);
    14be:	6ce0      	ldr	r0, [r4, #76]	; 0x4c
    14c0:	f004 fcbe 	bl	5e40 <__aeabi_f2d>
    14c4:	0002      	movs	r2, r0
    14c6:	000b      	movs	r3, r1
    14c8:	48b4      	ldr	r0, [pc, #720]	; (179c <main+0x334>)
    14ca:	4478      	add	r0, pc
    14cc:	f003 fa82 	bl	49d4 <mcp794xx_interface_debug_print>
	mcp794xx_interface_debug_print("Maximum current: \t%0.1fmA\n\r",  mcp794xx_handler.info.max_current_ma);
    14d0:	6d60      	ldr	r0, [r4, #84]	; 0x54
    14d2:	f004 fcb5 	bl	5e40 <__aeabi_f2d>
    14d6:	0002      	movs	r2, r0
    14d8:	000b      	movs	r3, r1
    14da:	48b1      	ldr	r0, [pc, #708]	; (17a0 <main+0x338>)
    14dc:	4478      	add	r0, pc
    14de:	f003 fa79 	bl	49d4 <mcp794xx_interface_debug_print>
	mcp794xx_interface_debug_print("Temperature Max: \t%.1fC\n\r",  mcp794xx_handler.info.temperature_max);
    14e2:	6de0      	ldr	r0, [r4, #92]	; 0x5c
    14e4:	f004 fcac 	bl	5e40 <__aeabi_f2d>
    14e8:	0002      	movs	r2, r0
    14ea:	000b      	movs	r3, r1
    14ec:	48ad      	ldr	r0, [pc, #692]	; (17a4 <main+0x33c>)
    14ee:	4478      	add	r0, pc
    14f0:	f003 fa70 	bl	49d4 <mcp794xx_interface_debug_print>
	mcp794xx_interface_debug_print("Temperature Min: \t%.1fC\n\r",  mcp794xx_handler.info.temperature_min);
    14f4:	6da0      	ldr	r0, [r4, #88]	; 0x58
    14f6:	f004 fca3 	bl	5e40 <__aeabi_f2d>
    14fa:	0002      	movs	r2, r0
    14fc:	000b      	movs	r3, r1
    14fe:	48aa      	ldr	r0, [pc, #680]	; (17a8 <main+0x340>)
    1500:	4478      	add	r0, pc
    1502:	f003 fa67 	bl	49d4 <mcp794xx_interface_debug_print>
	mcp794xx_interface_debug_print("Driver version: \tV%.1f.%.2d\n\r", ( mcp794xx_handler.info.driver_version / 1000), (uint8_t)( mcp794xx_handler.info.driver_version - (uint8_t)( mcp794xx_handler.info.driver_version / 100)*100));
    1506:	6e64      	ldr	r4, [r4, #100]	; 0x64
    1508:	49a8      	ldr	r1, [pc, #672]	; (17ac <main+0x344>)
    150a:	1c20      	adds	r0, r4, #0
    150c:	f003 fd28 	bl	4f60 <__aeabi_fmul>
    1510:	1c06      	adds	r6, r0, #0
    1512:	49a7      	ldr	r1, [pc, #668]	; (17b0 <main+0x348>)
    1514:	1c20      	adds	r0, r4, #0
    1516:	f003 fd23 	bl	4f60 <__aeabi_fmul>
    151a:	f003 fd09 	bl	4f30 <__aeabi_f2uiz>
    151e:	b2c3      	uxtb	r3, r0
    1520:	2064      	movs	r0, #100	; 0x64
    1522:	4358      	muls	r0, r3
    1524:	f003 fff8 	bl	5518 <__aeabi_i2f>
    1528:	1c01      	adds	r1, r0, #0
    152a:	1c20      	adds	r0, r4, #0
    152c:	f003 fe38 	bl	51a0 <__aeabi_fsub>
    1530:	f003 fcfe 	bl	4f30 <__aeabi_f2uiz>
    1534:	b2c4      	uxtb	r4, r0
    1536:	1c30      	adds	r0, r6, #0
    1538:	f004 fc82 	bl	5e40 <__aeabi_f2d>
    153c:	0002      	movs	r2, r0
    153e:	000b      	movs	r3, r1
    1540:	9400      	str	r4, [sp, #0]
    1542:	489c      	ldr	r0, [pc, #624]	; (17b4 <main+0x34c>)
    1544:	4478      	add	r0, pc
    1546:	f003 fa45 	bl	49d4 <mcp794xx_interface_debug_print>

    test.state = SET_TIME_DATE;
    154a:	4b9b      	ldr	r3, [pc, #620]	; (17b8 <main+0x350>)
    154c:	58eb      	ldr	r3, [r5, r3]
    154e:	9304      	str	r3, [sp, #16]
    1550:	2300      	movs	r3, #0
    1552:	9a04      	ldr	r2, [sp, #16]
    1554:	7013      	strb	r3, [r2, #0]
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
    1556:	2280      	movs	r2, #128	; 0x80
    1558:	0492      	lsls	r2, r2, #18
    155a:	23c0      	movs	r3, #192	; 0xc0
    155c:	05db      	lsls	r3, r3, #23
    155e:	619a      	str	r2, [r3, #24]
	gpio_set_pin_level(user_led, true);
	
	EXTERNAL_IRQ_0_example();
    1560:	f7fe ff58 	bl	414 <EXTERNAL_IRQ_0_example>
    1564:	e01b      	b.n	159e <main+0x136>
		mcp794xx_interface_debug_print("initialize failed, error code: %d\r", err);
    1566:	4895      	ldr	r0, [pc, #596]	; (17bc <main+0x354>)
    1568:	4478      	add	r0, pc
    156a:	f003 fa33 	bl	49d4 <mcp794xx_interface_debug_print>
    156e:	e786      	b.n	147e <main+0x16>

		switch((int)test.state)
		{
			case SET_TIME_DATE :
			{
				mcp794xx_basic_set_time_date(&default_time_date);   							/**< set rtc time and date manually */ 
    1570:	4b93      	ldr	r3, [pc, #588]	; (17c0 <main+0x358>)
    1572:	58eb      	ldr	r3, [r5, r3]
    1574:	9304      	str	r3, [sp, #16]
    1576:	0018      	movs	r0, r3
    1578:	f003 f894 	bl	46a4 <mcp794xx_basic_set_time_date>

				#ifdef USE_COMPILE_TIME_DATE         											/**< set time and date using compile time and date (if this routine fails use default time and date above )*/
					mcp794xx_basic_get_compile_time_date(__TIMESTAMP__, &compile_time_date);	/**< read and convert compile time and date to rtc time object */
    157c:	4b91      	ldr	r3, [pc, #580]	; (17c4 <main+0x35c>)
    157e:	58eb      	ldr	r3, [r5, r3]
    1580:	9304      	str	r3, [sp, #16]
    1582:	0019      	movs	r1, r3
    1584:	4890      	ldr	r0, [pc, #576]	; (17c8 <main+0x360>)
    1586:	4478      	add	r0, pc
    1588:	f003 f994 	bl	48b4 <mcp794xx_basic_get_compile_time_date>
					mcp794xx_basic_set_time_date(&compile_time_date);						    /**< set time and date */
    158c:	9804      	ldr	r0, [sp, #16]
    158e:	f003 f889 	bl	46a4 <mcp794xx_basic_set_time_date>
				#endif 

				test.state = READ_TIME_AND_DATE;
    1592:	4b89      	ldr	r3, [pc, #548]	; (17b8 <main+0x350>)
    1594:	58eb      	ldr	r3, [r5, r3]
    1596:	9304      	str	r3, [sp, #16]
    1598:	2302      	movs	r3, #2
    159a:	9a04      	ldr	r2, [sp, #16]
    159c:	7013      	strb	r3, [r2, #0]
		switch((int)test.state)
    159e:	4b86      	ldr	r3, [pc, #536]	; (17b8 <main+0x350>)
    15a0:	58eb      	ldr	r3, [r5, r3]
    15a2:	9304      	str	r3, [sp, #16]
    15a4:	7818      	ldrb	r0, [r3, #0]
    15a6:	2812      	cmp	r0, #18
    15a8:	d8f9      	bhi.n	159e <main+0x136>
    15aa:	f003 faf9 	bl	4ba0 <__gnu_thumb1_case_shi>
    15ae:	ffe1      	.short	0xffe1
    15b0:	0013fff8 	.word	0x0013fff8
    15b4:	00cd0058 	.word	0x00cd0058
    15b8:	fff8014b 	.word	0xfff8014b
    15bc:	01d80151 	.word	0x01d80151
    15c0:	01fe01ac 	.word	0x01fe01ac
    15c4:	02470209 	.word	0x02470209
    15c8:	02700212 	.word	0x02700212
    15cc:	fff8028a 	.word	0xfff8028a
    15d0:	009d0181 	.word	0x009d0181
				break;
			}

			case READ_TIME_AND_DATE:   
			{
				mcp794xx_basic_get_current_time_date(&now);				/**< read current time and date */
    15d4:	4b7d      	ldr	r3, [pc, #500]	; (17cc <main+0x364>)
    15d6:	58eb      	ldr	r3, [r5, r3]
    15d8:	9304      	str	r3, [sp, #16]
    15da:	0018      	movs	r0, r3
    15dc:	f003 f828 	bl	4630 <mcp794xx_basic_get_current_time_date>

				if(now.second != previous_seconds){                     /**< print time every second */
    15e0:	9b04      	ldr	r3, [sp, #16]
    15e2:	795b      	ldrb	r3, [r3, #5]
    15e4:	4a7a      	ldr	r2, [pc, #488]	; (17d0 <main+0x368>)
    15e6:	58aa      	ldr	r2, [r5, r2]
    15e8:	9204      	str	r2, [sp, #16]
    15ea:	7812      	ldrb	r2, [r2, #0]
    15ec:	4293      	cmp	r3, r2
    15ee:	d0d6      	beq.n	159e <main+0x136>
					previous_seconds = now.second;
    15f0:	4a77      	ldr	r2, [pc, #476]	; (17d0 <main+0x368>)
    15f2:	58aa      	ldr	r2, [r5, r2]
    15f4:	9204      	str	r2, [sp, #16]
    15f6:	7013      	strb	r3, [r2, #0]

					/**< print current time and date*/
					mcp794xx_interface_debug_print("Time: %.2d:",now.hour);
    15f8:	4b74      	ldr	r3, [pc, #464]	; (17cc <main+0x364>)
    15fa:	58ec      	ldr	r4, [r5, r3]
    15fc:	78e1      	ldrb	r1, [r4, #3]
    15fe:	4875      	ldr	r0, [pc, #468]	; (17d4 <main+0x36c>)
    1600:	4478      	add	r0, pc
    1602:	f003 f9e7 	bl	49d4 <mcp794xx_interface_debug_print>
					mcp794xx_interface_debug_print("%.2d:",now.minute);
    1606:	7921      	ldrb	r1, [r4, #4]
    1608:	4873      	ldr	r0, [pc, #460]	; (17d8 <main+0x370>)
    160a:	4478      	add	r0, pc
    160c:	f003 f9e2 	bl	49d4 <mcp794xx_interface_debug_print>
					mcp794xx_interface_debug_print("%.2d",now.second);
    1610:	7961      	ldrb	r1, [r4, #5]
    1612:	4872      	ldr	r0, [pc, #456]	; (17dc <main+0x374>)
    1614:	4478      	add	r0, pc
    1616:	f003 f9dd 	bl	49d4 <mcp794xx_interface_debug_print>
					//	  mcp794xx_interface_debug_print(" %s \n\r",am_pm_array[now.am_pm_indicator]);
					mcp794xx_interface_debug_print("\r\ndate: %s",week_days_arr[now.weekDay]);
    161a:	79e3      	ldrb	r3, [r4, #7]
    161c:	4e70      	ldr	r6, [pc, #448]	; (17e0 <main+0x378>)
    161e:	447e      	add	r6, pc
    1620:	009b      	lsls	r3, r3, #2
    1622:	5999      	ldr	r1, [r3, r6]
    1624:	486f      	ldr	r0, [pc, #444]	; (17e4 <main+0x37c>)
    1626:	4478      	add	r0, pc
    1628:	f003 f9d4 	bl	49d4 <mcp794xx_interface_debug_print>
					mcp794xx_interface_debug_print(" %.2d",now.date);
    162c:	78a1      	ldrb	r1, [r4, #2]
    162e:	486e      	ldr	r0, [pc, #440]	; (17e8 <main+0x380>)
    1630:	4478      	add	r0, pc
    1632:	f003 f9cf 	bl	49d4 <mcp794xx_interface_debug_print>
					mcp794xx_interface_debug_print(" %s",months_array[now.month]);
    1636:	79a3      	ldrb	r3, [r4, #6]
    1638:	009b      	lsls	r3, r3, #2
    163a:	18f6      	adds	r6, r6, r3
    163c:	6a31      	ldr	r1, [r6, #32]
    163e:	486b      	ldr	r0, [pc, #428]	; (17ec <main+0x384>)
    1640:	4478      	add	r0, pc
    1642:	f003 f9c7 	bl	49d4 <mcp794xx_interface_debug_print>
					mcp794xx_interface_debug_print(" %d \n\r",now.year);
    1646:	8821      	ldrh	r1, [r4, #0]
    1648:	4869      	ldr	r0, [pc, #420]	; (17f0 <main+0x388>)
    164a:	4478      	add	r0, pc
    164c:	f003 f9c2 	bl	49d4 <mcp794xx_interface_debug_print>
					
					test.state = COUNTDOWN_TIMER;
    1650:	4b59      	ldr	r3, [pc, #356]	; (17b8 <main+0x350>)
    1652:	58eb      	ldr	r3, [r5, r3]
    1654:	9304      	str	r3, [sp, #16]
    1656:	2312      	movs	r3, #18
    1658:	9a04      	ldr	r2, [sp, #16]
    165a:	7013      	strb	r3, [r2, #0]
    165c:	e79f      	b.n	159e <main+0x136>
				break;
			}

			case TEST_ALARM:
			{
				if(set_alarm_status == false)
    165e:	4b65      	ldr	r3, [pc, #404]	; (17f4 <main+0x38c>)
    1660:	58eb      	ldr	r3, [r5, r3]
    1662:	9304      	str	r3, [sp, #16]
    1664:	781b      	ldrb	r3, [r3, #0]
    1666:	2b00      	cmp	r3, #0
    1668:	d011      	beq.n	168e <main+0x226>

					mcp794xx_basic_get_alarm_time_date(MCP794XX_ALARM0, &alarm_mask, &alarm);     							/**< read alarm time, date and alarm mask set(this operation is not necessary when setting alarm) */
					mcp794xx_interface_debug_print("alarm time: %.2d:",alarm.hour);											/**< print time and date set*/
				}

				mcp794xx_basic_get_alarm_interrupt_flag(MCP794XX_ALARM0, &alarm_flag);       								/**< read alarm interrupt flag */
    166a:	4b63      	ldr	r3, [pc, #396]	; (17f8 <main+0x390>)
    166c:	58eb      	ldr	r3, [r5, r3]
    166e:	9304      	str	r3, [sp, #16]
    1670:	0019      	movs	r1, r3
    1672:	2000      	movs	r0, #0
    1674:	f003 f8b6 	bl	47e4 <mcp794xx_basic_get_alarm_interrupt_flag>

				if(alarm_flag == 1)    																						/**< this routine should be executed inside the external interrupt callback function */
    1678:	9b04      	ldr	r3, [sp, #16]
    167a:	781b      	ldrb	r3, [r3, #0]
    167c:	2b01      	cmp	r3, #1
    167e:	d02a      	beq.n	16d6 <main+0x26e>
					gpio_toggle_pin_level(user_led);																		/**< toggle user led for debug purposes */;											
					mcp794xx_basic_clr_alarm_interrupt_flag(MCP794XX_ALARM0);												/**< clear alarm time flag (note that if time still match alarm flag will be held */
					
				    //mcp794xx_basic_irq_callBack(MCP794XX_ALARM0, mcp794x_irq_cb);											/**< interrupt callback function (to be called in the external interrupt callback function ) */
				}
				test.state = READ_TIME_AND_DATE;
    1680:	4b4d      	ldr	r3, [pc, #308]	; (17b8 <main+0x350>)
    1682:	58eb      	ldr	r3, [r5, r3]
    1684:	9304      	str	r3, [sp, #16]
    1686:	2302      	movs	r3, #2
    1688:	9a04      	ldr	r2, [sp, #16]
    168a:	7013      	strb	r3, [r2, #0]
				break;
    168c:	e787      	b.n	159e <main+0x136>
					set_alarm_status = true;
    168e:	4b59      	ldr	r3, [pc, #356]	; (17f4 <main+0x38c>)
    1690:	58eb      	ldr	r3, [r5, r3]
    1692:	9304      	str	r3, [sp, #16]
    1694:	2301      	movs	r3, #1
    1696:	9a04      	ldr	r2, [sp, #16]
    1698:	7013      	strb	r3, [r2, #0]
					mcp794xx_basic_enable_alarm(MCP794XX_ALARM0, MCP794XX_INT_POLARITY_LOW);								/**< enable alarm 0 and set interrupt output polarity logic low*/
    169a:	2100      	movs	r1, #0
    169c:	2000      	movs	r0, #0
    169e:	f003 f83d 	bl	471c <mcp794xx_basic_enable_alarm>
					mcp794xx_basic_set_alarm_time_date(MCP794XX_ALARM0, MCP794XX_MASK_MINUTES, &alarm_default_time);		/**< set hour alarm (alarm will fire an interrupt when hour match) */
    16a2:	4b56      	ldr	r3, [pc, #344]	; (17fc <main+0x394>)
    16a4:	58eb      	ldr	r3, [r5, r3]
    16a6:	9304      	str	r3, [sp, #16]
    16a8:	001a      	movs	r2, r3
    16aa:	2101      	movs	r1, #1
    16ac:	2000      	movs	r0, #0
    16ae:	f003 f855 	bl	475c <mcp794xx_basic_set_alarm_time_date>
					mcp794xx_basic_get_alarm_time_date(MCP794XX_ALARM0, &alarm_mask, &alarm);     							/**< read alarm time, date and alarm mask set(this operation is not necessary when setting alarm) */
    16b2:	4b53      	ldr	r3, [pc, #332]	; (1800 <main+0x398>)
    16b4:	58eb      	ldr	r3, [r5, r3]
    16b6:	9304      	str	r3, [sp, #16]
    16b8:	4b52      	ldr	r3, [pc, #328]	; (1804 <main+0x39c>)
    16ba:	58eb      	ldr	r3, [r5, r3]
    16bc:	9305      	str	r3, [sp, #20]
    16be:	9a04      	ldr	r2, [sp, #16]
    16c0:	0019      	movs	r1, r3
    16c2:	2000      	movs	r0, #0
    16c4:	f003 f880 	bl	47c8 <mcp794xx_basic_get_alarm_time_date>
					mcp794xx_interface_debug_print("alarm time: %.2d:",alarm.hour);											/**< print time and date set*/
    16c8:	9b04      	ldr	r3, [sp, #16]
    16ca:	78d9      	ldrb	r1, [r3, #3]
    16cc:	484e      	ldr	r0, [pc, #312]	; (1808 <main+0x3a0>)
    16ce:	4478      	add	r0, pc
    16d0:	f003 f980 	bl	49d4 <mcp794xx_interface_debug_print>
    16d4:	e7c9      	b.n	166a <main+0x202>
	((Port *)hw)->Group[submodule_index].OUTTGL.reg = mask;
    16d6:	2280      	movs	r2, #128	; 0x80
    16d8:	0492      	lsls	r2, r2, #18
    16da:	23c0      	movs	r3, #192	; 0xc0
    16dc:	05db      	lsls	r3, r3, #23
    16de:	61da      	str	r2, [r3, #28]
					mcp794xx_basic_clr_alarm_interrupt_flag(MCP794XX_ALARM0);												/**< clear alarm time flag (note that if time still match alarm flag will be held */
    16e0:	2000      	movs	r0, #0
    16e2:	f003 f88d 	bl	4800 <mcp794xx_basic_clr_alarm_interrupt_flag>
    16e6:	e7cb      	b.n	1680 <main+0x218>
			}
			
			case COUNTDOWN_TIMER:
			{   /**< !! note that week day must be set accurately according to calendar for this routine to work !! */

				if(set_alarm_status == false)
    16e8:	4b42      	ldr	r3, [pc, #264]	; (17f4 <main+0x38c>)
    16ea:	58eb      	ldr	r3, [r5, r3]
    16ec:	9304      	str	r3, [sp, #16]
    16ee:	781b      	ldrb	r3, [r3, #0]
    16f0:	2b00      	cmp	r3, #0
    16f2:	d014      	beq.n	171e <main+0x2b6>
					set_alarm_status = true;
					mcp794xx_basic_enable_countdown_interrupt();							/**< enable count down timer interrupt (this routine uses ALARM1) and generate an interrupt when time expires*/
					mcp794xx_basic_set_countdown_time(5, MCP794XX_CNTDWN_SECONDS);			/**< set count down time, fires an interrupt every 5 sec(this routine will disable ALARM0)*/
				}

				mcp794xx_basic_get_alarm_interrupt_flag(MCP794XX_ALARM1, &alarm_flag);      /**< read alarm interrupt flag */
    16f4:	4b40      	ldr	r3, [pc, #256]	; (17f8 <main+0x390>)
    16f6:	58ec      	ldr	r4, [r5, r3]
    16f8:	0021      	movs	r1, r4
    16fa:	2001      	movs	r0, #1
    16fc:	f003 f872 	bl	47e4 <mcp794xx_basic_get_alarm_interrupt_flag>
				mcp794xx_interface_debug_print("flag %d\n", alarm_flag);
    1700:	7821      	ldrb	r1, [r4, #0]
    1702:	4842      	ldr	r0, [pc, #264]	; (180c <main+0x3a4>)
    1704:	4478      	add	r0, pc
    1706:	f003 f965 	bl	49d4 <mcp794xx_interface_debug_print>

				if(alarm_flag == 1)    														
    170a:	7823      	ldrb	r3, [r4, #0]
    170c:	2b01      	cmp	r3, #1
    170e:	d013      	beq.n	1738 <main+0x2d0>
					mcp794xx_basic_clr_alarm_interrupt_flag(MCP794XX_ALARM1);				/**< clear interrupt flag */
					mcp794xx_basic_set_countdown_time(5, MCP794XX_CNTDWN_SECONDS);			/**< reload time in register when count down expires (not advisable to call this function within a interrupt callback function) */
					
					//mcp794xx_basic_irq_callBack(MCP794XX_ALARM1, mcp794x_irq_cb);			/**< interrupt callback function (to be called in the external interrupt callback function) */
				}
				test.state = READ_TIME_AND_DATE;
    1710:	4b29      	ldr	r3, [pc, #164]	; (17b8 <main+0x350>)
    1712:	58eb      	ldr	r3, [r5, r3]
    1714:	9304      	str	r3, [sp, #16]
    1716:	2302      	movs	r3, #2
    1718:	9a04      	ldr	r2, [sp, #16]
    171a:	7013      	strb	r3, [r2, #0]
				break;
    171c:	e73f      	b.n	159e <main+0x136>
					set_alarm_status = true;
    171e:	4b35      	ldr	r3, [pc, #212]	; (17f4 <main+0x38c>)
    1720:	58eb      	ldr	r3, [r5, r3]
    1722:	9304      	str	r3, [sp, #16]
    1724:	2301      	movs	r3, #1
    1726:	9a04      	ldr	r2, [sp, #16]
    1728:	7013      	strb	r3, [r2, #0]
					mcp794xx_basic_enable_countdown_interrupt();							/**< enable count down timer interrupt (this routine uses ALARM1) and generate an interrupt when time expires*/
    172a:	f003 f875 	bl	4818 <mcp794xx_basic_enable_countdown_interrupt>
					mcp794xx_basic_set_countdown_time(5, MCP794XX_CNTDWN_SECONDS);			/**< set count down time, fires an interrupt every 5 sec(this routine will disable ALARM0)*/
    172e:	2100      	movs	r1, #0
    1730:	2005      	movs	r0, #5
    1732:	f003 f87d 	bl	4830 <mcp794xx_basic_set_countdown_time>
    1736:	e7dd      	b.n	16f4 <main+0x28c>
					mcp794xx_basic_clr_alarm_interrupt_flag(MCP794XX_ALARM1);				/**< clear interrupt flag */
    1738:	2001      	movs	r0, #1
    173a:	f003 f861 	bl	4800 <mcp794xx_basic_clr_alarm_interrupt_flag>
					mcp794xx_basic_set_countdown_time(5, MCP794XX_CNTDWN_SECONDS);			/**< reload time in register when count down expires (not advisable to call this function within a interrupt callback function) */
    173e:	2100      	movs	r1, #0
    1740:	2005      	movs	r0, #5
    1742:	f003 f875 	bl	4830 <mcp794xx_basic_set_countdown_time>
    1746:	e7e3      	b.n	1710 <main+0x2a8>
			}

			case TEST_POWER_FAIL:
			{
				if(pwr_fail_read == false)   /**< !! make sure power fail time stamp is read before any other instruction clears existing data (must be called before setting time at start up !! */
    1748:	4b31      	ldr	r3, [pc, #196]	; (1810 <main+0x3a8>)
    174a:	58eb      	ldr	r3, [r5, r3]
    174c:	9304      	str	r3, [sp, #16]
    174e:	781b      	ldrb	r3, [r3, #0]
    1750:	2b00      	cmp	r3, #0
    1752:	d067      	beq.n	1824 <main+0x3bc>
					pwr_fail_read = true;
					mcp794xx_basic_get_pwr_fail_time_stamp(MCP794XX_PWR_UP_TIME_STAMP, &pwr_fail);           /**< read power fail time stamp */
					mcp794xx_basic_enable_ext_batt_bckup_pwr();											     /**< enable back up power for future power fail event (calling this function will clear power fail time stamp event) */
				}
				/*< print time stamp */
				mcp794xx_interface_debug_print("pwr fail:%.2d:",pwr_fail.hour);
    1754:	4b2f      	ldr	r3, [pc, #188]	; (1814 <main+0x3ac>)
    1756:	58ec      	ldr	r4, [r5, r3]
    1758:	78e1      	ldrb	r1, [r4, #3]
    175a:	482f      	ldr	r0, [pc, #188]	; (1818 <main+0x3b0>)
    175c:	4478      	add	r0, pc
    175e:	f003 f939 	bl	49d4 <mcp794xx_interface_debug_print>
				mcp794xx_interface_debug_print("%.2d - ",pwr_fail.minute);
    1762:	7921      	ldrb	r1, [r4, #4]
    1764:	482d      	ldr	r0, [pc, #180]	; (181c <main+0x3b4>)
    1766:	4478      	add	r0, pc
    1768:	f003 f934 	bl	49d4 <mcp794xx_interface_debug_print>
				mcp794xx_interface_debug_print("%.2d\r\n",pwr_fail.time_Format);
    176c:	7a21      	ldrb	r1, [r4, #8]
    176e:	482c      	ldr	r0, [pc, #176]	; (1820 <main+0x3b8>)
    1770:	4478      	add	r0, pc
    1772:	f003 f92f 	bl	49d4 <mcp794xx_interface_debug_print>

				test.state = SET_TIME_DATE;
    1776:	4b10      	ldr	r3, [pc, #64]	; (17b8 <main+0x350>)
    1778:	58eb      	ldr	r3, [r5, r3]
    177a:	9304      	str	r3, [sp, #16]
    177c:	2300      	movs	r3, #0
    177e:	9a04      	ldr	r2, [sp, #16]
    1780:	7013      	strb	r3, [r2, #0]

				break;
    1782:	e70c      	b.n	159e <main+0x136>
    1784:	0000715a 	.word	0x0000715a
    1788:	1fffedec 	.word	0x1fffedec
    178c:	00005856 	.word	0x00005856
    1790:	0000585e 	.word	0x0000585e
    1794:	00005866 	.word	0x00005866
    1798:	00005868 	.word	0x00005868
    179c:	00005876 	.word	0x00005876
    17a0:	00005884 	.word	0x00005884
    17a4:	0000588e 	.word	0x0000588e
    17a8:	00005898 	.word	0x00005898
    17ac:	3a83126f 	.word	0x3a83126f
    17b0:	3c23d70a 	.word	0x3c23d70a
    17b4:	00005870 	.word	0x00005870
    17b8:	00000034 	.word	0x00000034
    17bc:	00005758 	.word	0x00005758
    17c0:	00000000 	.word	0x00000000
    17c4:	0000008c 	.word	0x0000008c
    17c8:	0000584e 	.word	0x0000584e
    17cc:	00000008 	.word	0x00000008
    17d0:	00000014 	.word	0x00000014
    17d4:	000057f0 	.word	0x000057f0
    17d8:	00005826 	.word	0x00005826
    17dc:	000057e8 	.word	0x000057e8
    17e0:	1fffe9fa 	.word	0x1fffe9fa
    17e4:	000057de 	.word	0x000057de
    17e8:	000057e0 	.word	0x000057e0
    17ec:	000057d8 	.word	0x000057d8
    17f0:	000057d2 	.word	0x000057d2
    17f4:	0000006c 	.word	0x0000006c
    17f8:	00000030 	.word	0x00000030
    17fc:	00000040 	.word	0x00000040
    1800:	00000028 	.word	0x00000028
    1804:	0000003c 	.word	0x0000003c
    1808:	00005756 	.word	0x00005756
    180c:	00005734 	.word	0x00005734
    1810:	00000048 	.word	0x00000048
    1814:	00000074 	.word	0x00000074
    1818:	000056e8 	.word	0x000056e8
    181c:	000056ee 	.word	0x000056ee
    1820:	000056ec 	.word	0x000056ec
					pwr_fail_read = true;
    1824:	4bb2      	ldr	r3, [pc, #712]	; (1af0 <main+0x688>)
    1826:	58eb      	ldr	r3, [r5, r3]
    1828:	9304      	str	r3, [sp, #16]
    182a:	2301      	movs	r3, #1
    182c:	9a04      	ldr	r2, [sp, #16]
    182e:	7013      	strb	r3, [r2, #0]
					mcp794xx_basic_get_pwr_fail_time_stamp(MCP794XX_PWR_UP_TIME_STAMP, &pwr_fail);           /**< read power fail time stamp */
    1830:	4bb0      	ldr	r3, [pc, #704]	; (1af4 <main+0x68c>)
    1832:	58eb      	ldr	r3, [r5, r3]
    1834:	9304      	str	r3, [sp, #16]
    1836:	0019      	movs	r1, r3
    1838:	2001      	movs	r0, #1
    183a:	f002 ff51 	bl	46e0 <mcp794xx_basic_get_pwr_fail_time_stamp>
					mcp794xx_basic_enable_ext_batt_bckup_pwr();											     /**< enable back up power for future power fail event (calling this function will clear power fail time stamp event) */
    183e:	f002 ff61 	bl	4704 <mcp794xx_basic_enable_ext_batt_bckup_pwr>
    1842:	e787      	b.n	1754 <main+0x2ec>
			}

			case TEST_FREQ_OUT:
			{
				mcp794xx_basic_enable_sqr_wave_output();									/**< enable frequency output */
    1844:	f003 f802 	bl	484c <mcp794xx_basic_enable_sqr_wave_output>
				mcp94xx_basic_set_sqr_wave_output_freq(MCP794XX_SQR_FREQ_SELCET_4_096KHZ);	/**< set frequency output value */
    1848:	2001      	movs	r0, #1
    184a:	f003 f80b 	bl	4864 <mcp94xx_basic_set_sqr_wave_output_freq>
				break;
    184e:	e6a6      	b.n	159e <main+0x136>
			}

			case TEST_EPOCH_TIME:
			{
				mcp794xx_basic_convert_time_to_epoch_unix_time(&now, (uint32_t *)&epoch_time);              /**< convert current time and date to epoch Unix time (local time) */
    1850:	4ba9      	ldr	r3, [pc, #676]	; (1af8 <main+0x690>)
    1852:	58ee      	ldr	r6, [r5, r3]
    1854:	4ba9      	ldr	r3, [pc, #676]	; (1afc <main+0x694>)
    1856:	58eb      	ldr	r3, [r5, r3]
    1858:	9304      	str	r3, [sp, #16]
    185a:	0031      	movs	r1, r6
    185c:	0018      	movs	r0, r3
    185e:	f003 f80d 	bl	487c <mcp794xx_basic_convert_time_to_epoch_unix_time>
				mcp794xx_interface_debug_print("time date: %lu\r\n",epoch_time);
    1862:	6831      	ldr	r1, [r6, #0]
    1864:	48a6      	ldr	r0, [pc, #664]	; (1b00 <main+0x698>)
    1866:	4478      	add	r0, pc
    1868:	f003 f8b4 	bl	49d4 <mcp794xx_interface_debug_print>
				
				//struct tm *time = localtime((const time_t *)&epoch_time);          						/**< built-in function from time.h library */
				//mcp794xx_interface_debug_print("epoch m: %d-%d-%d  %02d:%02d:%02d\n\r", time->tm_year + 1900, time->tm_mon + 1, time->tm_mday, time->tm_hour, time->tm_min, time->tm_sec);

				mcp794xx_basic_convert_epoch_to_human_time_format(epoch_time, &epoch_t);                    /**< convert epoch time format to human readable format*/
    186c:	4ba5      	ldr	r3, [pc, #660]	; (1b04 <main+0x69c>)
    186e:	58ec      	ldr	r4, [r5, r3]
    1870:	6830      	ldr	r0, [r6, #0]
    1872:	0021      	movs	r1, r4
    1874:	f003 f810 	bl	4898 <mcp794xx_basic_convert_epoch_to_human_time_format>
				mcp794xx_interface_debug_print("current tm: %d-%d-%d  %02d:%02d:%02d, %s\n\r", epoch_t.year, epoch_t.month, epoch_t.date, epoch_t.hour, epoch_t.minute, epoch_t.second, week_days_arr[epoch_t.weekDay]);
    1878:	8821      	ldrh	r1, [r4, #0]
    187a:	79a2      	ldrb	r2, [r4, #6]
    187c:	78a3      	ldrb	r3, [r4, #2]
    187e:	78e6      	ldrb	r6, [r4, #3]
    1880:	7927      	ldrb	r7, [r4, #4]
    1882:	7960      	ldrb	r0, [r4, #5]
    1884:	4684      	mov	ip, r0
    1886:	79e0      	ldrb	r0, [r4, #7]
    1888:	0080      	lsls	r0, r0, #2
    188a:	4c9f      	ldr	r4, [pc, #636]	; (1b08 <main+0x6a0>)
    188c:	447c      	add	r4, pc
    188e:	5900      	ldr	r0, [r0, r4]
    1890:	9003      	str	r0, [sp, #12]
    1892:	4660      	mov	r0, ip
    1894:	9002      	str	r0, [sp, #8]
    1896:	9701      	str	r7, [sp, #4]
    1898:	9600      	str	r6, [sp, #0]
    189a:	489c      	ldr	r0, [pc, #624]	; (1b0c <main+0x6a4>)
    189c:	4478      	add	r0, pc
    189e:	f003 f899 	bl	49d4 <mcp794xx_interface_debug_print>
				test.state = READ_TIME_AND_DATE;
    18a2:	4b9b      	ldr	r3, [pc, #620]	; (1b10 <main+0x6a8>)
    18a4:	58eb      	ldr	r3, [r5, r3]
    18a6:	9304      	str	r3, [sp, #16]
    18a8:	2302      	movs	r3, #2
    18aa:	9a04      	ldr	r2, [sp, #16]
    18ac:	7013      	strb	r3, [r2, #0]
				break;
    18ae:	e676      	b.n	159e <main+0x136>
			}

			case READ_UID:
			{
				pUnique_id = (uint8_t *)calloc(UID_MAX_LENGTH, sizeof(uint8_t));     	  /**< allocate memory for data to read */
    18b0:	2101      	movs	r1, #1
    18b2:	2008      	movs	r0, #8
    18b4:	f004 fc3c 	bl	6130 <calloc>
    18b8:	4b96      	ldr	r3, [pc, #600]	; (1b14 <main+0x6ac>)
    18ba:	58eb      	ldr	r3, [r5, r3]
    18bc:	6018      	str	r0, [r3, #0]
				
				if(pUnique_id == NULL){
    18be:	2800      	cmp	r0, #0
    18c0:	d006      	beq.n	18d0 <main+0x468>
					mcp794xx_interface_debug_print("failed to allocate memory\n\r");	
				}

				mcp794xx_basic_uid_read((uint8_t*)pUnique_id);                            /**< read device unique identifier */
    18c2:	4b94      	ldr	r3, [pc, #592]	; (1b14 <main+0x6ac>)
    18c4:	58eb      	ldr	r3, [r5, r3]
    18c6:	6818      	ldr	r0, [r3, #0]
    18c8:	f003 f838 	bl	493c <mcp794xx_basic_uid_read>
				for(int index = 0; index < UID_MAX_LENGTH; index++){					  /*< print id */
    18cc:	2400      	movs	r4, #0
    18ce:	e00d      	b.n	18ec <main+0x484>
					mcp794xx_interface_debug_print("failed to allocate memory\n\r");	
    18d0:	4891      	ldr	r0, [pc, #580]	; (1b18 <main+0x6b0>)
    18d2:	4478      	add	r0, pc
    18d4:	f003 f87e 	bl	49d4 <mcp794xx_interface_debug_print>
    18d8:	e7f3      	b.n	18c2 <main+0x45a>
					mcp794xx_interface_debug_print("%.2p :",pUnique_id[index]);
    18da:	4b8e      	ldr	r3, [pc, #568]	; (1b14 <main+0x6ac>)
    18dc:	58eb      	ldr	r3, [r5, r3]
    18de:	681b      	ldr	r3, [r3, #0]
    18e0:	5d19      	ldrb	r1, [r3, r4]
    18e2:	488e      	ldr	r0, [pc, #568]	; (1b1c <main+0x6b4>)
    18e4:	4478      	add	r0, pc
    18e6:	f003 f875 	bl	49d4 <mcp794xx_interface_debug_print>
				for(int index = 0; index < UID_MAX_LENGTH; index++){					  /*< print id */
    18ea:	3401      	adds	r4, #1
    18ec:	2c07      	cmp	r4, #7
    18ee:	ddf4      	ble.n	18da <main+0x472>
				}
				mcp794xx_interface_debug_print("\n\r");
    18f0:	488b      	ldr	r0, [pc, #556]	; (1b20 <main+0x6b8>)
    18f2:	4478      	add	r0, pc
    18f4:	f003 f86e 	bl	49d4 <mcp794xx_interface_debug_print>
				//free(pUnique_id);			/**< free memory allocated*/

				test.state = WRITE_EEPROM;
    18f8:	4b85      	ldr	r3, [pc, #532]	; (1b10 <main+0x6a8>)
    18fa:	58eb      	ldr	r3, [r5, r3]
    18fc:	9304      	str	r3, [sp, #16]
    18fe:	230c      	movs	r3, #12
    1900:	9a04      	ldr	r2, [sp, #16]
    1902:	7013      	strb	r3, [r2, #0]
				break;
    1904:	e64b      	b.n	159e <main+0x136>
			}

			case READ_SRAM:
			{
				pSram_data_read = (uint8_t *)calloc(SRAM_MEMORY_SIZE, sizeof(uint8_t));     						  /**< allocate memory for data to read */
    1906:	2101      	movs	r1, #1
    1908:	2040      	movs	r0, #64	; 0x40
    190a:	f004 fc11 	bl	6130 <calloc>
    190e:	4b85      	ldr	r3, [pc, #532]	; (1b24 <main+0x6bc>)
    1910:	58eb      	ldr	r3, [r5, r3]
    1912:	6018      	str	r0, [r3, #0]
				if(pSram_data_read == NULL){
    1914:	2800      	cmp	r0, #0
    1916:	d008      	beq.n	192a <main+0x4c2>
					mcp794xx_interface_debug_print("failed to allocate memory\n\r");
				}

				mcp794xx_basic_sram_read_byte(SRAM_FIRST_ADDRESS, (uint8_t *)pSram_data_read, SRAM_MEMORY_SIZE);      /**< read the whole sram memory, starting from first address (0x20) */
    1918:	4b82      	ldr	r3, [pc, #520]	; (1b24 <main+0x6bc>)
    191a:	58eb      	ldr	r3, [r5, r3]
    191c:	6819      	ldr	r1, [r3, #0]
    191e:	2240      	movs	r2, #64	; 0x40
    1920:	2020      	movs	r0, #32
    1922:	f002 ffe3 	bl	48ec <mcp794xx_basic_sram_read_byte>
				for(int index = 0; index < SRAM_MEMORY_SIZE; index++){
    1926:	2400      	movs	r4, #0
    1928:	e00d      	b.n	1946 <main+0x4de>
					mcp794xx_interface_debug_print("failed to allocate memory\n\r");
    192a:	487f      	ldr	r0, [pc, #508]	; (1b28 <main+0x6c0>)
    192c:	4478      	add	r0, pc
    192e:	f003 f851 	bl	49d4 <mcp794xx_interface_debug_print>
    1932:	e7f1      	b.n	1918 <main+0x4b0>
					mcp794xx_interface_debug_print("%.2p ",pSram_data_read[index]);
    1934:	4b7b      	ldr	r3, [pc, #492]	; (1b24 <main+0x6bc>)
    1936:	58eb      	ldr	r3, [r5, r3]
    1938:	681b      	ldr	r3, [r3, #0]
    193a:	5d19      	ldrb	r1, [r3, r4]
    193c:	487b      	ldr	r0, [pc, #492]	; (1b2c <main+0x6c4>)
    193e:	4478      	add	r0, pc
    1940:	f003 f848 	bl	49d4 <mcp794xx_interface_debug_print>
				for(int index = 0; index < SRAM_MEMORY_SIZE; index++){
    1944:	3401      	adds	r4, #1
    1946:	2c3f      	cmp	r4, #63	; 0x3f
    1948:	ddf4      	ble.n	1934 <main+0x4cc>
				}
				mcp794xx_interface_debug_print("\n\r");
    194a:	4879      	ldr	r0, [pc, #484]	; (1b30 <main+0x6c8>)
    194c:	4478      	add	r0, pc
    194e:	f003 f841 	bl	49d4 <mcp794xx_interface_debug_print>
				free(pSram_data_read);		/**< free memory allocated*/
    1952:	4b74      	ldr	r3, [pc, #464]	; (1b24 <main+0x6bc>)
    1954:	58eb      	ldr	r3, [r5, r3]
    1956:	6818      	ldr	r0, [r3, #0]
    1958:	f004 fc18 	bl	618c <free>
				
				//test.state = WIPE_SRAM;
				break;
    195c:	e61f      	b.n	159e <main+0x136>
			}

			case WRITE_SRAM:
			{
				pSram_data_write = (uint8_t *)calloc(SRAM_MEMORY_SIZE, sizeof(uint8_t));     /**< allocate memory for data to written */
    195e:	2101      	movs	r1, #1
    1960:	2040      	movs	r0, #64	; 0x40
    1962:	f004 fbe5 	bl	6130 <calloc>
    1966:	4b73      	ldr	r3, [pc, #460]	; (1b34 <main+0x6cc>)
    1968:	58eb      	ldr	r3, [r5, r3]
    196a:	6018      	str	r0, [r3, #0]
				if(pSram_data_write == NULL){
    196c:	2800      	cmp	r0, #0
    196e:	d017      	beq.n	19a0 <main+0x538>
					mcp794xx_interface_debug_print("failed to allocate memory\n\r");
				}

				memcpy((uint8_t *)pSram_data_write, (uint8_t *)pUnique_id, UID_MAX_LENGTH);   /**< copy UID and write it to sram */
    1970:	4b70      	ldr	r3, [pc, #448]	; (1b34 <main+0x6cc>)
    1972:	58ec      	ldr	r4, [r5, r3]
    1974:	4b67      	ldr	r3, [pc, #412]	; (1b14 <main+0x6ac>)
    1976:	58eb      	ldr	r3, [r5, r3]
    1978:	6819      	ldr	r1, [r3, #0]
    197a:	2208      	movs	r2, #8
    197c:	6820      	ldr	r0, [r4, #0]
    197e:	f004 fc0f 	bl	61a0 <memcpy>

				mcp794xx_basic_sram_write_byte(SRAM_FIRST_ADDRESS, (uint8_t *)pSram_data_write, UID_MAX_LENGTH);   /**< write data starting from sram first address */
    1982:	2208      	movs	r2, #8
    1984:	6821      	ldr	r1, [r4, #0]
    1986:	2020      	movs	r0, #32
    1988:	f002 ffa2 	bl	48d0 <mcp794xx_basic_sram_write_byte>

				free(pSram_data_write);
    198c:	6820      	ldr	r0, [r4, #0]
    198e:	f004 fbfd 	bl	618c <free>
				test.state = READ_TIME_AND_DATE;
    1992:	4b5f      	ldr	r3, [pc, #380]	; (1b10 <main+0x6a8>)
    1994:	58eb      	ldr	r3, [r5, r3]
    1996:	9304      	str	r3, [sp, #16]
    1998:	2302      	movs	r3, #2
    199a:	9a04      	ldr	r2, [sp, #16]
    199c:	7013      	strb	r3, [r2, #0]
				break;
    199e:	e5fe      	b.n	159e <main+0x136>
					mcp794xx_interface_debug_print("failed to allocate memory\n\r");
    19a0:	4865      	ldr	r0, [pc, #404]	; (1b38 <main+0x6d0>)
    19a2:	4478      	add	r0, pc
    19a4:	f003 f816 	bl	49d4 <mcp794xx_interface_debug_print>
    19a8:	e7e2      	b.n	1970 <main+0x508>
			}

			case ERASE_SRAM_SECTOR:
			{
				mcp794xx_basic_sram_erase_selector(0x20, 0x40);             				 /**< erase sram data from address 0x20 - 0x40 */
    19aa:	2140      	movs	r1, #64	; 0x40
    19ac:	2020      	movs	r0, #32
    19ae:	f002 ffab 	bl	4908 <mcp794xx_basic_sram_erase_selector>
				test.state = READ_UID;
    19b2:	4b57      	ldr	r3, [pc, #348]	; (1b10 <main+0x6a8>)
    19b4:	58eb      	ldr	r3, [r5, r3]
    19b6:	9304      	str	r3, [sp, #16]
    19b8:	2311      	movs	r3, #17
    19ba:	9a04      	ldr	r2, [sp, #16]
    19bc:	7013      	strb	r3, [r2, #0]
				break;
    19be:	e5ee      	b.n	159e <main+0x136>
			}

			case WIPE_SRAM:
			{
				mcp794xx_basic_sram_wipe();													/**< wipe the whole sram memory */
    19c0:	f002 ffb0 	bl	4924 <mcp794xx_basic_sram_wipe>
				test.state = READ_SRAM;
    19c4:	4b52      	ldr	r3, [pc, #328]	; (1b10 <main+0x6a8>)
    19c6:	58eb      	ldr	r3, [r5, r3]
    19c8:	9304      	str	r3, [sp, #16]
    19ca:	2309      	movs	r3, #9
    19cc:	9a04      	ldr	r2, [sp, #16]
    19ce:	7013      	strb	r3, [r2, #0]
				break;
    19d0:	e5e5      	b.n	159e <main+0x136>
			}

			case READ_EEPROM:
			{
				mcp794xx_interface_delay_ms(5);
    19d2:	2005      	movs	r0, #5
    19d4:	f002 fffa 	bl	49cc <mcp794xx_interface_delay_ms>
				
				pEeprom_data_read = (uint8_t *)calloc(EEPROM_PAGE_SIZE, sizeof(uint8_t));     						  /**< allocate memory for data to read */
    19d8:	2101      	movs	r1, #1
    19da:	2008      	movs	r0, #8
    19dc:	f004 fba8 	bl	6130 <calloc>
    19e0:	4b56      	ldr	r3, [pc, #344]	; (1b3c <main+0x6d4>)
    19e2:	58eb      	ldr	r3, [r5, r3]
    19e4:	6018      	str	r0, [r3, #0]
				if(pEeprom_data_read == NULL)
    19e6:	2800      	cmp	r0, #0
    19e8:	d008      	beq.n	19fc <main+0x594>
				{
					mcp794xx_interface_debug_print("failed to allocate memory\n\r");
				}

				mcp794xx_basic_eeprom_read_byte(EEPROM_LOWEST_ADDRESS, (uint8_t *)pEeprom_data_read, EEPROM_PAGE_SIZE);   /**< read the 8 byte starting from address 0x00 */
    19ea:	4b54      	ldr	r3, [pc, #336]	; (1b3c <main+0x6d4>)
    19ec:	58eb      	ldr	r3, [r5, r3]
    19ee:	6819      	ldr	r1, [r3, #0]
    19f0:	2208      	movs	r2, #8
    19f2:	2000      	movs	r0, #0
    19f4:	f002 ffbc 	bl	4970 <mcp794xx_basic_eeprom_read_byte>
				for(int index = 0; index < EEPROM_PAGE_SIZE ; index++){
    19f8:	2400      	movs	r4, #0
    19fa:	e00d      	b.n	1a18 <main+0x5b0>
					mcp794xx_interface_debug_print("failed to allocate memory\n\r");
    19fc:	4850      	ldr	r0, [pc, #320]	; (1b40 <main+0x6d8>)
    19fe:	4478      	add	r0, pc
    1a00:	f002 ffe8 	bl	49d4 <mcp794xx_interface_debug_print>
    1a04:	e7f1      	b.n	19ea <main+0x582>
					mcp794xx_interface_debug_print("%.2p ", pEeprom_data_read[index]);
    1a06:	4b4d      	ldr	r3, [pc, #308]	; (1b3c <main+0x6d4>)
    1a08:	58eb      	ldr	r3, [r5, r3]
    1a0a:	681b      	ldr	r3, [r3, #0]
    1a0c:	5d19      	ldrb	r1, [r3, r4]
    1a0e:	484d      	ldr	r0, [pc, #308]	; (1b44 <main+0x6dc>)
    1a10:	4478      	add	r0, pc
    1a12:	f002 ffdf 	bl	49d4 <mcp794xx_interface_debug_print>
				for(int index = 0; index < EEPROM_PAGE_SIZE ; index++){
    1a16:	3401      	adds	r4, #1
    1a18:	2c07      	cmp	r4, #7
    1a1a:	ddf4      	ble.n	1a06 <main+0x59e>
				}
				mcp794xx_interface_debug_print("\n\r");
    1a1c:	484a      	ldr	r0, [pc, #296]	; (1b48 <main+0x6e0>)
    1a1e:	4478      	add	r0, pc
    1a20:	f002 ffd8 	bl	49d4 <mcp794xx_interface_debug_print>
				free(pEeprom_data_read);
    1a24:	4b45      	ldr	r3, [pc, #276]	; (1b3c <main+0x6d4>)
    1a26:	58eb      	ldr	r3, [r5, r3]
    1a28:	6818      	ldr	r0, [r3, #0]
    1a2a:	f004 fbaf 	bl	618c <free>
				
				test.state = GET_EEPROM;
    1a2e:	4b38      	ldr	r3, [pc, #224]	; (1b10 <main+0x6a8>)
    1a30:	58eb      	ldr	r3, [r5, r3]
    1a32:	9304      	str	r3, [sp, #16]
    1a34:	230f      	movs	r3, #15
    1a36:	9a04      	ldr	r2, [sp, #16]
    1a38:	7013      	strb	r3, [r2, #0]
				break;
    1a3a:	e5b0      	b.n	159e <main+0x136>
			}

			case WRITE_EEPROM:
			{
				pEeprom_data_write = (uint8_t *)calloc(EEPROM_PAGE_SIZE, sizeof(uint8_t));							  /**< allocate a block memory for the eeprom write buffer */
    1a3c:	2101      	movs	r1, #1
    1a3e:	2008      	movs	r0, #8
    1a40:	f004 fb76 	bl	6130 <calloc>
    1a44:	4b41      	ldr	r3, [pc, #260]	; (1b4c <main+0x6e4>)
    1a46:	58eb      	ldr	r3, [r5, r3]
    1a48:	6018      	str	r0, [r3, #0]
				if(pEeprom_data_write == NULL){
    1a4a:	2800      	cmp	r0, #0
    1a4c:	d01a      	beq.n	1a84 <main+0x61c>
					mcp794xx_interface_debug_print("failed to allocate dynamic memory\n\r");
				}
					
				memcpy((uint8_t *)pEeprom_data_write, (uint8_t *)pUnique_id, UID_MAX_LENGTH);		 				  /**< copy UID and write it to eeprom */
    1a4e:	4b3f      	ldr	r3, [pc, #252]	; (1b4c <main+0x6e4>)
    1a50:	58ec      	ldr	r4, [r5, r3]
    1a52:	4b30      	ldr	r3, [pc, #192]	; (1b14 <main+0x6ac>)
    1a54:	58ee      	ldr	r6, [r5, r3]
    1a56:	2208      	movs	r2, #8
    1a58:	6831      	ldr	r1, [r6, #0]
    1a5a:	6820      	ldr	r0, [r4, #0]
    1a5c:	f004 fba0 	bl	61a0 <memcpy>
				
				mcp794xx_basic_eeprom_write_byte(0x00, (uint8_t *)pEeprom_data_write, EEPROM_PAGE_SIZE);      		  /**< write the first 8 bytes address (keep in mind the 5ms Write Cycle Time before attempt to read back written data)*/
    1a60:	2208      	movs	r2, #8
    1a62:	6821      	ldr	r1, [r4, #0]
    1a64:	2000      	movs	r0, #0
    1a66:	f002 ff75 	bl	4954 <mcp794xx_basic_eeprom_write_byte>

				free(pEeprom_data_write);   /**< allocated memory */
    1a6a:	6820      	ldr	r0, [r4, #0]
    1a6c:	f004 fb8e 	bl	618c <free>
				free(pUnique_id);			/**< free memory allocated*/
    1a70:	6830      	ldr	r0, [r6, #0]
    1a72:	f004 fb8b 	bl	618c <free>
				test.state = READ_EEPROM; 
    1a76:	4b26      	ldr	r3, [pc, #152]	; (1b10 <main+0x6a8>)
    1a78:	58eb      	ldr	r3, [r5, r3]
    1a7a:	9304      	str	r3, [sp, #16]
    1a7c:	230d      	movs	r3, #13
    1a7e:	9a04      	ldr	r2, [sp, #16]
    1a80:	7013      	strb	r3, [r2, #0]
				break;
    1a82:	e58c      	b.n	159e <main+0x136>
					mcp794xx_interface_debug_print("failed to allocate dynamic memory\n\r");
    1a84:	4832      	ldr	r0, [pc, #200]	; (1b50 <main+0x6e8>)
    1a86:	4478      	add	r0, pc
    1a88:	f002 ffa4 	bl	49d4 <mcp794xx_interface_debug_print>
    1a8c:	e7df      	b.n	1a4e <main+0x5e6>
			}

			case PUT_EEPROM:
			{
				mcp794xx_basic_convert_time_to_epoch_unix_time(&now, (uint32_t *)&epoch_time);			/**< convert current time stamp to epoch Unix time */
    1a8e:	4b1a      	ldr	r3, [pc, #104]	; (1af8 <main+0x690>)
    1a90:	58ec      	ldr	r4, [r5, r3]
    1a92:	4b1a      	ldr	r3, [pc, #104]	; (1afc <main+0x694>)
    1a94:	58eb      	ldr	r3, [r5, r3]
    1a96:	9304      	str	r3, [sp, #16]
    1a98:	0021      	movs	r1, r4
    1a9a:	0018      	movs	r0, r3
    1a9c:	f002 feee 	bl	487c <mcp794xx_basic_convert_time_to_epoch_unix_time>

				err = mcp794xx_basic_eeprom_put_byte(0x00, (uint32_t*)&epoch_time, 4);  				  /**< store converted epoch time into eeprom from address 0x00, knowing that it is always a 4 bytes long number */
    1aa0:	2204      	movs	r2, #4
    1aa2:	0021      	movs	r1, r4
    1aa4:	2000      	movs	r0, #0
    1aa6:	f002 ff71 	bl	498c <mcp794xx_basic_eeprom_put_byte>
				mcp794xx_interface_debug_print("epoch written: %.8p\n\r",epoch_time);
    1aaa:	6821      	ldr	r1, [r4, #0]
    1aac:	4829      	ldr	r0, [pc, #164]	; (1b54 <main+0x6ec>)
    1aae:	4478      	add	r0, pc
    1ab0:	f002 ff90 	bl	49d4 <mcp794xx_interface_debug_print>

				test.state = READ_EEPROM;
    1ab4:	4b16      	ldr	r3, [pc, #88]	; (1b10 <main+0x6a8>)
    1ab6:	58eb      	ldr	r3, [r5, r3]
    1ab8:	9304      	str	r3, [sp, #16]
    1aba:	230d      	movs	r3, #13
    1abc:	9a04      	ldr	r2, [sp, #16]
    1abe:	7013      	strb	r3, [r2, #0]
				break;
    1ac0:	e56d      	b.n	159e <main+0x136>
			}

			case GET_EEPROM:
			{
				mcp794xx_interface_delay_ms(5);														/**< wait 5ms before read */
    1ac2:	2005      	movs	r0, #5
    1ac4:	f002 ff82 	bl	49cc <mcp794xx_interface_delay_ms>

				mcp794xx_basic_eeprom_get_byte(0x00, (uint32_t*)&epoch_time_read, 4);				/**<  read epoch time written in previous state */
    1ac8:	4b23      	ldr	r3, [pc, #140]	; (1b58 <main+0x6f0>)
    1aca:	58ec      	ldr	r4, [r5, r3]
    1acc:	2204      	movs	r2, #4
    1ace:	0021      	movs	r1, r4
    1ad0:	2000      	movs	r0, #0
    1ad2:	f002 ff69 	bl	49a8 <mcp794xx_basic_eeprom_get_byte>
				mcp794xx_interface_debug_print("eeprom get: %lu\n\r",epoch_time_read);
    1ad6:	6821      	ldr	r1, [r4, #0]
    1ad8:	4820      	ldr	r0, [pc, #128]	; (1b5c <main+0x6f4>)
    1ada:	4478      	add	r0, pc
    1adc:	f002 ff7a 	bl	49d4 <mcp794xx_interface_debug_print>
				
				test.state = READ_TIME_AND_DATE;
    1ae0:	4b0b      	ldr	r3, [pc, #44]	; (1b10 <main+0x6a8>)
    1ae2:	58eb      	ldr	r3, [r5, r3]
    1ae4:	9304      	str	r3, [sp, #16]
    1ae6:	2302      	movs	r3, #2
    1ae8:	9a04      	ldr	r2, [sp, #16]
    1aea:	7013      	strb	r3, [r2, #0]
				
				break;
    1aec:	e557      	b.n	159e <main+0x136>
    1aee:	46c0      	nop			; (mov r8, r8)
    1af0:	00000048 	.word	0x00000048
    1af4:	00000074 	.word	0x00000074
    1af8:	00000044 	.word	0x00000044
    1afc:	00000008 	.word	0x00000008
    1b00:	000055fe 	.word	0x000055fe
    1b04:	00000020 	.word	0x00000020
    1b08:	1fffe78c 	.word	0x1fffe78c
    1b0c:	000055dc 	.word	0x000055dc
    1b10:	00000034 	.word	0x00000034
    1b14:	00000084 	.word	0x00000084
    1b18:	000055d2 	.word	0x000055d2
    1b1c:	000055dc 	.word	0x000055dc
    1b20:	0000552e 	.word	0x0000552e
    1b24:	00000024 	.word	0x00000024
    1b28:	00005578 	.word	0x00005578
    1b2c:	0000558a 	.word	0x0000558a
    1b30:	000054d4 	.word	0x000054d4
    1b34:	00000038 	.word	0x00000038
    1b38:	00005502 	.word	0x00005502
    1b3c:	00000080 	.word	0x00000080
    1b40:	000054a6 	.word	0x000054a6
    1b44:	000054b8 	.word	0x000054b8
    1b48:	00005402 	.word	0x00005402
    1b4c:	0000002c 	.word	0x0000002c
    1b50:	0000544a 	.word	0x0000544a
    1b54:	00005446 	.word	0x00005446
    1b58:	00000050 	.word	0x00000050
    1b5c:	00005432 	.word	0x00005432

00001b60 <serial_print>:
 * @param[in] length is the data size
 * @return
 * @note		none
 * */
void serial_print(const char *pString, uint8_t u8Length)
{
    1b60:	b530      	push	{r4, r5, lr}
    1b62:	b085      	sub	sp, #20
    1b64:	0005      	movs	r5, r0
    1b66:	000c      	movs	r4, r1
    1b68:	4b09      	ldr	r3, [pc, #36]	; (1b90 <serial_print+0x30>)
    1b6a:	447b      	add	r3, pc
	struct io_descriptor *io;
	usart_sync_get_io_descriptor(&USART_0, &io);
    1b6c:	4a09      	ldr	r2, [pc, #36]	; (1b94 <serial_print+0x34>)
    1b6e:	589b      	ldr	r3, [r3, r2]
    1b70:	9301      	str	r3, [sp, #4]
    1b72:	a903      	add	r1, sp, #12
    1b74:	0018      	movs	r0, r3
    1b76:	f7fe fe5b 	bl	830 <usart_sync_get_io_descriptor>
	usart_sync_enable(&USART_0);
    1b7a:	9801      	ldr	r0, [sp, #4]
    1b7c:	f7fe fe46 	bl	80c <usart_sync_enable>

	io_write(io, (char *)pString, u8Length);
    1b80:	b2a2      	uxth	r2, r4
    1b82:	0029      	movs	r1, r5
    1b84:	9803      	ldr	r0, [sp, #12]
    1b86:	f7fe fd81 	bl	68c <io_write>
}
    1b8a:	b005      	add	sp, #20
    1b8c:	bd30      	pop	{r4, r5, pc}
    1b8e:	46c0      	nop			; (mov r8, r8)
    1b90:	00006a5e 	.word	0x00006a5e
    1b94:	00000058 	.word	0x00000058

00001b98 <i2c_write>:
 * 			- 0 success
 * 			- 1 failed to write
 * @note	none
 * */
uint8_t i2c_write(uint8_t addr, uint8_t *buf, uint8_t len)
{
    1b98:	b570      	push	{r4, r5, r6, lr}
    1b9a:	b084      	sub	sp, #16
    1b9c:	0005      	movs	r5, r0
    1b9e:	000e      	movs	r6, r1
    1ba0:	0014      	movs	r4, r2
    1ba2:	4b0d      	ldr	r3, [pc, #52]	; (1bd8 <i2c_write+0x40>)
    1ba4:	447b      	add	r3, pc
	struct io_descriptor *I2C_0_io;

	i2c_m_sync_get_io_descriptor(&I2C_0, &I2C_0_io);
    1ba6:	4a0d      	ldr	r2, [pc, #52]	; (1bdc <i2c_write+0x44>)
    1ba8:	589b      	ldr	r3, [r3, r2]
    1baa:	9301      	str	r3, [sp, #4]
    1bac:	a903      	add	r1, sp, #12
    1bae:	0018      	movs	r0, r3
    1bb0:	f7fe fd67 	bl	682 <i2c_m_sync_get_io_descriptor>
	i2c_m_sync_enable(&I2C_0);
    1bb4:	9801      	ldr	r0, [sp, #4]
    1bb6:	f7fe fd57 	bl	668 <i2c_m_sync_enable>
	i2c_m_sync_set_slaveaddr(&I2C_0, addr, I2C_M_SEVEN);
    1bba:	b229      	sxth	r1, r5
    1bbc:	2280      	movs	r2, #128	; 0x80
    1bbe:	0112      	lsls	r2, r2, #4
    1bc0:	9801      	ldr	r0, [sp, #4]
    1bc2:	f7fe fd55 	bl	670 <i2c_m_sync_set_slaveaddr>

	io_write(I2C_0_io, (uint8_t *)buf, len);
    1bc6:	b2a2      	uxth	r2, r4
    1bc8:	0031      	movs	r1, r6
    1bca:	9803      	ldr	r0, [sp, #12]
    1bcc:	f7fe fd5e 	bl	68c <io_write>
	return 0;
}
    1bd0:	2000      	movs	r0, #0
    1bd2:	b004      	add	sp, #16
    1bd4:	bd70      	pop	{r4, r5, r6, pc}
    1bd6:	46c0      	nop			; (mov r8, r8)
    1bd8:	00006a24 	.word	0x00006a24
    1bdc:	00000088 	.word	0x00000088

00001be0 <i2c_read>:
 * 			- 1 failed to read
 * @note	none
 * */

uint8_t i2c_read(uint8_t addr, uint8_t *buf, uint8_t len)
{
    1be0:	b570      	push	{r4, r5, r6, lr}
    1be2:	b084      	sub	sp, #16
    1be4:	0005      	movs	r5, r0
    1be6:	000e      	movs	r6, r1
    1be8:	0014      	movs	r4, r2
    1bea:	4b0d      	ldr	r3, [pc, #52]	; (1c20 <i2c_read+0x40>)
    1bec:	447b      	add	r3, pc
    struct io_descriptor *I2C_0_io;

    i2c_m_sync_get_io_descriptor(&I2C_0, &I2C_0_io);
    1bee:	4a0d      	ldr	r2, [pc, #52]	; (1c24 <i2c_read+0x44>)
    1bf0:	589b      	ldr	r3, [r3, r2]
    1bf2:	9301      	str	r3, [sp, #4]
    1bf4:	a903      	add	r1, sp, #12
    1bf6:	0018      	movs	r0, r3
    1bf8:	f7fe fd43 	bl	682 <i2c_m_sync_get_io_descriptor>
    i2c_m_sync_enable(&I2C_0);
    1bfc:	9801      	ldr	r0, [sp, #4]
    1bfe:	f7fe fd33 	bl	668 <i2c_m_sync_enable>
    i2c_m_sync_set_slaveaddr(&I2C_0, addr, I2C_M_SEVEN);
    1c02:	b229      	sxth	r1, r5
    1c04:	2280      	movs	r2, #128	; 0x80
    1c06:	0112      	lsls	r2, r2, #4
    1c08:	9801      	ldr	r0, [sp, #4]
    1c0a:	f7fe fd31 	bl	670 <i2c_m_sync_set_slaveaddr>
	
    io_read(I2C_0_io, buf,  len);
    1c0e:	b2a2      	uxth	r2, r4
    1c10:	0031      	movs	r1, r6
    1c12:	9803      	ldr	r0, [sp, #12]
    1c14:	f7fe fd54 	bl	6c0 <io_read>
    return 0;
}
    1c18:	2000      	movs	r0, #0
    1c1a:	b004      	add	sp, #16
    1c1c:	bd70      	pop	{r4, r5, r6, pc}
    1c1e:	46c0      	nop			; (mov r8, r8)
    1c20:	000069dc 	.word	0x000069dc
    1c24:	00000088 	.word	0x00000088

00001c28 <led_toggle>:
    1c28:	2280      	movs	r2, #128	; 0x80
    1c2a:	0492      	lsls	r2, r2, #18
    1c2c:	23c0      	movs	r3, #192	; 0xc0
    1c2e:	05db      	lsls	r3, r3, #23
    1c30:	61da      	str	r2, [r3, #28]

void led_toggle(void)
{
	gpio_toggle_pin_level(user_led);
    1c32:	4770      	bx	lr

00001c34 <rtc_mcp794xx_i2c_write>:
            - 0 success
            - 1 failed to write
* @note none
*/
uint8_t rtc_mcp794xx_i2c_write(mcp794xx_handle_t *const pHandle, uint8_t u8Reg, uint8_t *pBuf)
{
    1c34:	b510      	push	{r4, lr}
    1c36:	b082      	sub	sp, #8
	uint8_t tempBuffer[2];    //len +1
	tempBuffer[0] = u8Reg;
    1c38:	ab01      	add	r3, sp, #4
    1c3a:	7019      	strb	r1, [r3, #0]

	for(int index = 1; index < 2; index++){
    1c3c:	2301      	movs	r3, #1
    1c3e:	2b01      	cmp	r3, #1
    1c40:	dd08      	ble.n	1c54 <rtc_mcp794xx_i2c_write+0x20>
		tempBuffer[index] = pBuf[index - 1];
	}

    if (pHandle->i2c_write(pHandle->rtc_address, (uint8_t *)tempBuffer, 2) != 0) /**< read data   (size is len +1) */
    1c42:	68c3      	ldr	r3, [r0, #12]
    1c44:	7f00      	ldrb	r0, [r0, #28]
    1c46:	2202      	movs	r2, #2
    1c48:	a901      	add	r1, sp, #4
    1c4a:	4798      	blx	r3
    1c4c:	2800      	cmp	r0, #0
    1c4e:	d108      	bne.n	1c62 <rtc_mcp794xx_i2c_write+0x2e>
    {
        return 1; /**< read fail */
    }
    return 0;                                            /**< return success */

}
    1c50:	b002      	add	sp, #8
    1c52:	bd10      	pop	{r4, pc}
		tempBuffer[index] = pBuf[index - 1];
    1c54:	18d1      	adds	r1, r2, r3
    1c56:	3901      	subs	r1, #1
    1c58:	780c      	ldrb	r4, [r1, #0]
    1c5a:	a901      	add	r1, sp, #4
    1c5c:	54cc      	strb	r4, [r1, r3]
	for(int index = 1; index < 2; index++){
    1c5e:	3301      	adds	r3, #1
    1c60:	e7ed      	b.n	1c3e <rtc_mcp794xx_i2c_write+0xa>
        return 1; /**< read fail */
    1c62:	2001      	movs	r0, #1
    1c64:	e7f4      	b.n	1c50 <rtc_mcp794xx_i2c_write+0x1c>

00001c66 <rtc_mcp794xx_i2c_read>:
*          - 0 success
*          - 1 failed to read
* @note none
*/
uint8_t rtc_mcp794xx_i2c_read(mcp794xx_handle_t  *const pHandle, uint16_t u8Reg, uint8_t *pBuf, uint8_t u8Length)
{
    1c66:	b570      	push	{r4, r5, r6, lr}
    1c68:	b082      	sub	sp, #8
    1c6a:	0004      	movs	r4, r0
    1c6c:	0015      	movs	r5, r2
    1c6e:	001e      	movs	r6, r3
    1c70:	466b      	mov	r3, sp
    1c72:	80d9      	strh	r1, [r3, #6]
    1c74:	3306      	adds	r3, #6

	if (pHandle->i2c_write(pHandle->rtc_address, (uint8_t *)&u8Reg, 1) != 0) /**< read data */
    1c76:	7f00      	ldrb	r0, [r0, #28]
    1c78:	2201      	movs	r2, #1
    1c7a:	0019      	movs	r1, r3
    1c7c:	68e3      	ldr	r3, [r4, #12]
    1c7e:	4798      	blx	r3
    1c80:	2800      	cmp	r0, #0
    1c82:	d002      	beq.n	1c8a <rtc_mcp794xx_i2c_read+0x24>
	{
		return 1; /**< read fail */
    1c84:	2001      	movs	r0, #1
    if (pHandle->i2c_read(pHandle->rtc_address, (uint8_t *)pBuf, u8Length) != 0) /**< read data */
    {
        return 1; /**< read fail */
    }
    return 0;                                           /**< return success */
}
    1c86:	b002      	add	sp, #8
    1c88:	bd70      	pop	{r4, r5, r6, pc}
    if (pHandle->i2c_read(pHandle->rtc_address, (uint8_t *)pBuf, u8Length) != 0) /**< read data */
    1c8a:	68a3      	ldr	r3, [r4, #8]
    1c8c:	7f20      	ldrb	r0, [r4, #28]
    1c8e:	0032      	movs	r2, r6
    1c90:	0029      	movs	r1, r5
    1c92:	4798      	blx	r3
    1c94:	2800      	cmp	r0, #0
    1c96:	d0f6      	beq.n	1c86 <rtc_mcp794xx_i2c_read+0x20>
        return 1; /**< read fail */
    1c98:	2001      	movs	r0, #1
    1c9a:	e7f4      	b.n	1c86 <rtc_mcp794xx_i2c_read+0x20>

00001c9c <eeprom_mcp794xx_i2c_write>:
            - 0 success
            - 1 failed to write
* @note none
*/
uint8_t eeprom_mcp794xx_i2c_write(mcp794xx_handle_t *const pHandle, uint8_t u8Reg, uint8_t *pBuf, uint8_t u8Length)
{
    1c9c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    1c9e:	af00      	add	r7, sp, #0
    1ca0:	000d      	movs	r5, r1
	int index;
	uint8_t tempBuffer[u8Length + 1];    //len +1
    1ca2:	1c5e      	adds	r6, r3, #1
    1ca4:	001c      	movs	r4, r3
    1ca6:	3408      	adds	r4, #8
    1ca8:	08e4      	lsrs	r4, r4, #3
    1caa:	00e4      	lsls	r4, r4, #3
    1cac:	4669      	mov	r1, sp
    1cae:	1b09      	subs	r1, r1, r4
    1cb0:	468d      	mov	sp, r1
	tempBuffer[0] = u8Reg;
    1cb2:	700d      	strb	r5, [r1, #0]

	for(index = 1; index < (u8Length + 1); index++){
    1cb4:	2401      	movs	r4, #1
    1cb6:	e004      	b.n	1cc2 <eeprom_mcp794xx_i2c_write+0x26>
		tempBuffer[index] = pBuf[index - 1];
    1cb8:	1915      	adds	r5, r2, r4
    1cba:	3d01      	subs	r5, #1
    1cbc:	782d      	ldrb	r5, [r5, #0]
    1cbe:	550d      	strb	r5, [r1, r4]
	for(index = 1; index < (u8Length + 1); index++){
    1cc0:	3401      	adds	r4, #1
    1cc2:	42b4      	cmp	r4, r6
    1cc4:	dbf8      	blt.n	1cb8 <eeprom_mcp794xx_i2c_write+0x1c>
	}

    if (pHandle->i2c_write(pHandle->eeprom_address, (uint8_t *)tempBuffer, (u8Length + 1)) != MCP794XX_DRV_OK) /**< read data   (size is len +1) */
    1cc6:	68c4      	ldr	r4, [r0, #12]
    1cc8:	3301      	adds	r3, #1
    1cca:	b2da      	uxtb	r2, r3
    1ccc:	7f40      	ldrb	r0, [r0, #29]
    1cce:	47a0      	blx	r4
    1cd0:	2800      	cmp	r0, #0
    1cd2:	d101      	bne.n	1cd8 <eeprom_mcp794xx_i2c_write+0x3c>
    {
        return MCP794XX_DRV_FAILED; /**< read fail */
    }
    return MCP794XX_DRV_OK;                                            /**< return success */

}
    1cd4:	46bd      	mov	sp, r7
    1cd6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        return MCP794XX_DRV_FAILED; /**< read fail */
    1cd8:	2001      	movs	r0, #1
    1cda:	e7fb      	b.n	1cd4 <eeprom_mcp794xx_i2c_write+0x38>

00001cdc <eeprom_mcp794xx_i2c_read>:
*          - 0 success
*          - 1 failed to read
* @note none
*/
uint8_t eeprom_mcp794xx_i2c_read(mcp794xx_handle_t  *const pHandle, uint16_t u8Reg, uint8_t *pBuf, uint8_t u8Length)
{
    1cdc:	b570      	push	{r4, r5, r6, lr}
    1cde:	b082      	sub	sp, #8
    1ce0:	0004      	movs	r4, r0
    1ce2:	0015      	movs	r5, r2
    1ce4:	001e      	movs	r6, r3
    1ce6:	466b      	mov	r3, sp
    1ce8:	80d9      	strh	r1, [r3, #6]
    1cea:	3306      	adds	r3, #6
	if (pHandle->i2c_write(pHandle->eeprom_address, (uint8_t *)&u8Reg, 1) != MCP794XX_DRV_OK) /**< read data */
    1cec:	7f40      	ldrb	r0, [r0, #29]
    1cee:	2201      	movs	r2, #1
    1cf0:	0019      	movs	r1, r3
    1cf2:	68e3      	ldr	r3, [r4, #12]
    1cf4:	4798      	blx	r3
    1cf6:	2800      	cmp	r0, #0
    1cf8:	d002      	beq.n	1d00 <eeprom_mcp794xx_i2c_read+0x24>
	{
		return MCP794XX_DRV_FAILED; /**< read fail */
    1cfa:	2001      	movs	r0, #1
    if (pHandle->i2c_read(pHandle->eeprom_address, (uint8_t *)pBuf, u8Length) != MCP794XX_DRV_OK) /**< read data */
    {
        return MCP794XX_DRV_FAILED; /**< read fail */
    }
    return MCP794XX_DRV_OK;                                           /**< return success */
}
    1cfc:	b002      	add	sp, #8
    1cfe:	bd70      	pop	{r4, r5, r6, pc}
    if (pHandle->i2c_read(pHandle->eeprom_address, (uint8_t *)pBuf, u8Length) != MCP794XX_DRV_OK) /**< read data */
    1d00:	68a3      	ldr	r3, [r4, #8]
    1d02:	7f60      	ldrb	r0, [r4, #29]
    1d04:	0032      	movs	r2, r6
    1d06:	0029      	movs	r1, r5
    1d08:	4798      	blx	r3
    1d0a:	2800      	cmp	r0, #0
    1d0c:	d0f6      	beq.n	1cfc <eeprom_mcp794xx_i2c_read+0x20>
        return MCP794XX_DRV_FAILED; /**< read fail */
    1d0e:	2001      	movs	r0, #1
    1d10:	e7f4      	b.n	1cfc <eeprom_mcp794xx_i2c_read+0x20>

00001d12 <sram_mcp794xx_i2c_write>:
            - 0 success
            - 1 failed to write
* @note none
*/
uint8_t sram_mcp794xx_i2c_write(mcp794xx_handle_t *const pHandle, uint8_t u8Reg, uint8_t *pBuf, uint8_t u8Length)
{
    1d12:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    1d14:	af00      	add	r7, sp, #0
    1d16:	000d      	movs	r5, r1
	int index;
	uint8_t tempBuffer[u8Length + 1];    //len +1
    1d18:	001e      	movs	r6, r3
    1d1a:	001c      	movs	r4, r3
    1d1c:	3408      	adds	r4, #8
    1d1e:	08e4      	lsrs	r4, r4, #3
    1d20:	00e4      	lsls	r4, r4, #3
    1d22:	4669      	mov	r1, sp
    1d24:	1b09      	subs	r1, r1, r4
    1d26:	468d      	mov	sp, r1
	tempBuffer[0] = u8Reg;
    1d28:	700d      	strb	r5, [r1, #0]

	for(index = 1; index < u8Length; index++){
    1d2a:	2401      	movs	r4, #1
    1d2c:	e004      	b.n	1d38 <sram_mcp794xx_i2c_write+0x26>
		tempBuffer[index] = pBuf[index - 1];
    1d2e:	1915      	adds	r5, r2, r4
    1d30:	3d01      	subs	r5, #1
    1d32:	782d      	ldrb	r5, [r5, #0]
    1d34:	550d      	strb	r5, [r1, r4]
	for(index = 1; index < u8Length; index++){
    1d36:	3401      	adds	r4, #1
    1d38:	42b4      	cmp	r4, r6
    1d3a:	dbf8      	blt.n	1d2e <sram_mcp794xx_i2c_write+0x1c>
	}

    if (pHandle->i2c_write(pHandle->rtc_address, (uint8_t *)tempBuffer, u8Length + 1) != MCP794XX_DRV_OK) /**< read data   (size is len +1) */
    1d3c:	68c4      	ldr	r4, [r0, #12]
    1d3e:	3301      	adds	r3, #1
    1d40:	b2da      	uxtb	r2, r3
    1d42:	7f00      	ldrb	r0, [r0, #28]
    1d44:	47a0      	blx	r4
    1d46:	2800      	cmp	r0, #0
    1d48:	d101      	bne.n	1d4e <sram_mcp794xx_i2c_write+0x3c>
    {
        return MCP794XX_DRV_FAILED; /**< read fail */
    }
	return MCP794XX_DRV_OK;
}
    1d4a:	46bd      	mov	sp, r7
    1d4c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        return MCP794XX_DRV_FAILED; /**< read fail */
    1d4e:	2001      	movs	r0, #1
    1d50:	e7fb      	b.n	1d4a <sram_mcp794xx_i2c_write+0x38>
	...

00001d54 <a_mcp794xx_print_error_msg>:
* @param[in] *pBuffer point to the string to be printed
* @return none
* @note   none
*/
void a_mcp794xx_print_error_msg(mcp794xx_handle_t *const pHandle, char *const pBuffer)
{
    1d54:	b510      	push	{r4, lr}
#ifdef MCP794XX_DEBUG_MODE
    pHandle->debug_print("mcp794xx: failed to %s.\r\n", pBuffer);
    1d56:	6943      	ldr	r3, [r0, #20]
    1d58:	4801      	ldr	r0, [pc, #4]	; (1d60 <a_mcp794xx_print_error_msg+0xc>)
    1d5a:	4478      	add	r0, pc
    1d5c:	4798      	blx	r3
#endif // MCP794XX_DEBUG_MODE
}
    1d5e:	bd10      	pop	{r4, pc}
    1d60:	0000528a 	.word	0x0000528a

00001d64 <a_pcf85xxx_dec2bcd>:
 * @param[in] u8Decimal is the decimal value to be converted
 * @return BCD data
 * @note    none
 */
uint8_t a_pcf85xxx_dec2bcd(uint8_t u8Decimal)
{
    1d64:	b570      	push	{r4, r5, r6, lr}
    1d66:	0005      	movs	r5, r0
    return (((u8Decimal / 10) << 4) | (u8Decimal % 10));
    1d68:	210a      	movs	r1, #10
    1d6a:	f002 ff23 	bl	4bb4 <__udivsi3>
    1d6e:	b2c4      	uxtb	r4, r0
    1d70:	0124      	lsls	r4, r4, #4
    1d72:	210a      	movs	r1, #10
    1d74:	0028      	movs	r0, r5
    1d76:	f002 ffa3 	bl	4cc0 <__aeabi_uidivmod>
    1d7a:	4321      	orrs	r1, r4
    1d7c:	b2c8      	uxtb	r0, r1
}
    1d7e:	bd70      	pop	{r4, r5, r6, pc}

00001d80 <a_pcf85xxx_bcd2dec>:
 * @param[in] u8Bcd is the BCD value to be converted
 * @return decimal data
 * @note     none
 */
uint8_t a_pcf85xxx_bcd2dec(uint8_t u8Bcd)
{
    1d80:	0001      	movs	r1, r0
    return ( (u8Bcd/16*10) + (u8Bcd%16) );
    1d82:	0902      	lsrs	r2, r0, #4
    1d84:	0093      	lsls	r3, r2, #2
    1d86:	18d2      	adds	r2, r2, r3
    1d88:	0053      	lsls	r3, r2, #1
    1d8a:	b2db      	uxtb	r3, r3
    1d8c:	200f      	movs	r0, #15
    1d8e:	4008      	ands	r0, r1
    1d90:	1818      	adds	r0, r3, r0
    1d92:	b2c0      	uxtb	r0, r0
}
    1d94:	4770      	bx	lr
	...

00001d98 <mcp794xx_init>:
 *            - 2 pHandle is NULL
 *            - 3 linked functions is NULL
 * @note      none
 */
uint8_t mcp794xx_init(mcp794xx_handle_t *const pHandle)
{
    1d98:	b510      	push	{r4, lr}
    1d9a:	1e04      	subs	r4, r0, #0
    if (pHandle == NULL)
    1d9c:	d03e      	beq.n	1e1c <mcp794xx_init+0x84>
        return 2;
    if (pHandle->debug_print == NULL)
    1d9e:	6943      	ldr	r3, [r0, #20]
    1da0:	2b00      	cmp	r3, #0
    1da2:	d03d      	beq.n	1e20 <mcp794xx_init+0x88>
        return 3;
    if (pHandle->i2c_init == NULL)
    1da4:	6802      	ldr	r2, [r0, #0]
    1da6:	2a00      	cmp	r2, #0
    1da8:	d015      	beq.n	1dd6 <mcp794xx_init+0x3e>
#ifdef MCP794XX_DEBUG_MODE
        pHandle->debug_print("mcp794xx: i2c initialize is null\n");
#endif
        return 3;
    }
    if (pHandle->i2c_deinit == NULL)
    1daa:	6842      	ldr	r2, [r0, #4]
    1dac:	2a00      	cmp	r2, #0
    1dae:	d017      	beq.n	1de0 <mcp794xx_init+0x48>
#ifdef MCP794XX_DEBUG_MODE
        pHandle->debug_print("mcp794xx: i2c_deint is null\n");
#endif
        return 3;
    }
    if (pHandle->i2c_read == NULL)
    1db0:	6882      	ldr	r2, [r0, #8]
    1db2:	2a00      	cmp	r2, #0
    1db4:	d019      	beq.n	1dea <mcp794xx_init+0x52>
#ifdef MCP794XX_DEBUG_MODE
        pHandle->debug_print("mcp794xx: i2c_read is null\n");
#endif
        return 3;
    }
    if (pHandle->i2c_write == NULL)
    1db6:	68c2      	ldr	r2, [r0, #12]
    1db8:	2a00      	cmp	r2, #0
    1dba:	d01b      	beq.n	1df4 <mcp794xx_init+0x5c>
#ifdef MCP794XX_DEBUG_MODE
        pHandle->debug_print("mcp794xx: i2c_write is null\n");
#endif
        return 3;
    }
    if (pHandle->receive_callback == NULL)
    1dbc:	6982      	ldr	r2, [r0, #24]
    1dbe:	2a00      	cmp	r2, #0
    1dc0:	d01d      	beq.n	1dfe <mcp794xx_init+0x66>
#ifdef MCP794XX_DEBUG_MODE
        pHandle->debug_print("mcp794xx: receive_callback\n");
#endif
        return 3;
    }
    if (pHandle->delay_ms == NULL)
    1dc2:	6902      	ldr	r2, [r0, #16]
    1dc4:	2a00      	cmp	r2, #0
    1dc6:	d01f      	beq.n	1e08 <mcp794xx_init+0x70>
    {
#ifdef MCP794XX_DEBUG_MODE
        pHandle->debug_print("mcp794xx: delay_ms\n");
#endif
    }
    if (pHandle->i2c_init())
    1dc8:	6823      	ldr	r3, [r4, #0]
    1dca:	4798      	blx	r3
    1dcc:	2800      	cmp	r0, #0
    1dce:	d11f      	bne.n	1e10 <mcp794xx_init+0x78>
        pHandle->debug_print("mcp794xx: i2c initialize failed\n");
#endif
        return 1;
    }

    pHandle->inited = 1; /* flag finish initialization */
    1dd0:	2301      	movs	r3, #1
    1dd2:	77e3      	strb	r3, [r4, #31]

    return 0;
    1dd4:	e023      	b.n	1e1e <mcp794xx_init+0x86>
        pHandle->debug_print("mcp794xx: i2c initialize is null\n");
    1dd6:	4813      	ldr	r0, [pc, #76]	; (1e24 <mcp794xx_init+0x8c>)
    1dd8:	4478      	add	r0, pc
    1dda:	4798      	blx	r3
        return 3;
    1ddc:	2003      	movs	r0, #3
    1dde:	e01e      	b.n	1e1e <mcp794xx_init+0x86>
        pHandle->debug_print("mcp794xx: i2c_deint is null\n");
    1de0:	4811      	ldr	r0, [pc, #68]	; (1e28 <mcp794xx_init+0x90>)
    1de2:	4478      	add	r0, pc
    1de4:	4798      	blx	r3
        return 3;
    1de6:	2003      	movs	r0, #3
    1de8:	e019      	b.n	1e1e <mcp794xx_init+0x86>
        pHandle->debug_print("mcp794xx: i2c_read is null\n");
    1dea:	4810      	ldr	r0, [pc, #64]	; (1e2c <mcp794xx_init+0x94>)
    1dec:	4478      	add	r0, pc
    1dee:	4798      	blx	r3
        return 3;
    1df0:	2003      	movs	r0, #3
    1df2:	e014      	b.n	1e1e <mcp794xx_init+0x86>
        pHandle->debug_print("mcp794xx: i2c_write is null\n");
    1df4:	480e      	ldr	r0, [pc, #56]	; (1e30 <mcp794xx_init+0x98>)
    1df6:	4478      	add	r0, pc
    1df8:	4798      	blx	r3
        return 3;
    1dfa:	2003      	movs	r0, #3
    1dfc:	e00f      	b.n	1e1e <mcp794xx_init+0x86>
        pHandle->debug_print("mcp794xx: receive_callback\n");
    1dfe:	480d      	ldr	r0, [pc, #52]	; (1e34 <mcp794xx_init+0x9c>)
    1e00:	4478      	add	r0, pc
    1e02:	4798      	blx	r3
        return 3;
    1e04:	2003      	movs	r0, #3
    1e06:	e00a      	b.n	1e1e <mcp794xx_init+0x86>
        pHandle->debug_print("mcp794xx: delay_ms\n");
    1e08:	480b      	ldr	r0, [pc, #44]	; (1e38 <mcp794xx_init+0xa0>)
    1e0a:	4478      	add	r0, pc
    1e0c:	4798      	blx	r3
    1e0e:	e7db      	b.n	1dc8 <mcp794xx_init+0x30>
        pHandle->debug_print("mcp794xx: i2c initialize failed\n");
    1e10:	6963      	ldr	r3, [r4, #20]
    1e12:	480a      	ldr	r0, [pc, #40]	; (1e3c <mcp794xx_init+0xa4>)
    1e14:	4478      	add	r0, pc
    1e16:	4798      	blx	r3
        return 1;
    1e18:	2001      	movs	r0, #1
    1e1a:	e000      	b.n	1e1e <mcp794xx_init+0x86>
        return 2;
    1e1c:	2002      	movs	r0, #2
}
    1e1e:	bd10      	pop	{r4, pc}
        return 3;
    1e20:	2003      	movs	r0, #3
    1e22:	e7fc      	b.n	1e1e <mcp794xx_init+0x86>
    1e24:	00005228 	.word	0x00005228
    1e28:	00005242 	.word	0x00005242
    1e2c:	00005258 	.word	0x00005258
    1e30:	0000526a 	.word	0x0000526a
    1e34:	00005280 	.word	0x00005280
    1e38:	00005292 	.word	0x00005292
    1e3c:	0000529c 	.word	0x0000529c

00001e40 <mcp794xx_irq_pHandler>:
 *            - 2 pHandle is NULL
 *            - 3 pHandle is not initialized
 * @note      none
 */
uint8_t mcp794xx_irq_pHandler(mcp794xx_handle_t *const pHandle, mcp794xx_alarm_t alarm)
{
    1e40:	b510      	push	{r4, lr}
    if(pHandle == NULL)
    1e42:	2800      	cmp	r0, #0
    1e44:	d013      	beq.n	1e6e <mcp794xx_irq_pHandler+0x2e>
        return 2;     /**< return failed error */
    if(pHandle->inited != 1)
    1e46:	7fc3      	ldrb	r3, [r0, #31]
    1e48:	2b01      	cmp	r3, #1
    1e4a:	d002      	beq.n	1e52 <mcp794xx_irq_pHandler+0x12>
        return 3;      /**< return failed error */
    1e4c:	2303      	movs	r3, #3
			return 1;
		break;
	}

    return 0;              /**< success */
}
    1e4e:	0018      	movs	r0, r3
    1e50:	bd10      	pop	{r4, pc}
	switch(alarm)
    1e52:	2900      	cmp	r1, #0
    1e54:	d006      	beq.n	1e64 <mcp794xx_irq_pHandler+0x24>
    1e56:	2901      	cmp	r1, #1
    1e58:	d1f9      	bne.n	1e4e <mcp794xx_irq_pHandler+0xe>
			pHandle->receive_callback(MCP794XX_ALARM1);
    1e5a:	6983      	ldr	r3, [r0, #24]
    1e5c:	2001      	movs	r0, #1
    1e5e:	4798      	blx	r3
    return 0;              /**< success */
    1e60:	2300      	movs	r3, #0
			break;
    1e62:	e7f4      	b.n	1e4e <mcp794xx_irq_pHandler+0xe>
			pHandle->receive_callback(MCP794XX_ALARM0);
    1e64:	6983      	ldr	r3, [r0, #24]
    1e66:	2000      	movs	r0, #0
    1e68:	4798      	blx	r3
    return 0;              /**< success */
    1e6a:	2300      	movs	r3, #0
			break;
    1e6c:	e7ef      	b.n	1e4e <mcp794xx_irq_pHandler+0xe>
        return 2;     /**< return failed error */
    1e6e:	2302      	movs	r3, #2
    1e70:	e7ed      	b.n	1e4e <mcp794xx_irq_pHandler+0xe>
	...

00001e74 <mcp794xx_set_addr_pin>:
 *            - 2 pHandle is NULL
 *            - 3 pHandle is not initialized
 * @note      none
 */
uint8_t mcp794xx_set_addr_pin(mcp794xx_handle_t *const pHandle)
{
    1e74:	b510      	push	{r4, lr}

    if(pHandle == NULL)
    1e76:	2800      	cmp	r0, #0
    1e78:	d012      	beq.n	1ea0 <mcp794xx_set_addr_pin+0x2c>
        return 2;     /**< return failed error */
    if(pHandle->inited != 1)
    1e7a:	7fc4      	ldrb	r4, [r0, #31]
    1e7c:	2c01      	cmp	r4, #1
    1e7e:	d002      	beq.n	1e86 <mcp794xx_set_addr_pin+0x12>
        return 3;      /**< return failed error */
    1e80:	2403      	movs	r4, #3
        a_mcp794xx_print_error_msg(pHandle, "set i2c slave address");
        return 1;           /**< failed error */
    }

    return 0;           /**< success */
}
    1e82:	0020      	movs	r0, r4
    1e84:	bd10      	pop	{r4, pc}
    pHandle->rtc_address = MCP794XX_RTC_IIC_ADDRESS;
    1e86:	236f      	movs	r3, #111	; 0x6f
    1e88:	7703      	strb	r3, [r0, #28]
    pHandle->eeprom_address = MCP794XX_EEPROM_IIC_ADDRESS;
    1e8a:	3b18      	subs	r3, #24
    1e8c:	7743      	strb	r3, [r0, #29]
    if((pHandle->rtc_address != MCP794XX_RTC_IIC_ADDRESS) || (pHandle->eeprom_address != MCP794XX_EEPROM_IIC_ADDRESS))
    1e8e:	8b82      	ldrh	r2, [r0, #28]
    1e90:	4b05      	ldr	r3, [pc, #20]	; (1ea8 <mcp794xx_set_addr_pin+0x34>)
    1e92:	429a      	cmp	r2, r3
    1e94:	d006      	beq.n	1ea4 <mcp794xx_set_addr_pin+0x30>
        a_mcp794xx_print_error_msg(pHandle, "set i2c slave address");
    1e96:	4905      	ldr	r1, [pc, #20]	; (1eac <mcp794xx_set_addr_pin+0x38>)
    1e98:	4479      	add	r1, pc
    1e9a:	f7ff ff5b 	bl	1d54 <a_mcp794xx_print_error_msg>
        return 1;           /**< failed error */
    1e9e:	e7f0      	b.n	1e82 <mcp794xx_set_addr_pin+0xe>
        return 2;     /**< return failed error */
    1ea0:	2402      	movs	r4, #2
    1ea2:	e7ee      	b.n	1e82 <mcp794xx_set_addr_pin+0xe>
    return 0;           /**< success */
    1ea4:	2400      	movs	r4, #0
    1ea6:	e7ec      	b.n	1e82 <mcp794xx_set_addr_pin+0xe>
    1ea8:	0000576f 	.word	0x0000576f
    1eac:	00005250 	.word	0x00005250

00001eb0 <mcp794xx_set_variant>:
 *            - 3 handle is not initialized
 * @note      none
 */
uint8_t mcp794xx_set_variant(mcp794xx_handle_t *const pHandle, mcp794xx_variant_t variant)
{
    if(pHandle == NULL)
    1eb0:	2800      	cmp	r0, #0
    1eb2:	d007      	beq.n	1ec4 <mcp794xx_set_variant+0x14>
        return 2;     /**< return failed error */
    if(pHandle->inited != 1)
    1eb4:	7fc3      	ldrb	r3, [r0, #31]
    1eb6:	2b01      	cmp	r3, #1
    1eb8:	d001      	beq.n	1ebe <mcp794xx_set_variant+0xe>
        return 3;      /**< return failed error */
    1eba:	2003      	movs	r0, #3
        a_mcp794xx_print_error_msg(pHandle, "set variant");
        return 1;           /**< failed error */
    }

    return 0;           /**< success */
}
    1ebc:	4770      	bx	lr
    pHandle->device_variant = variant;
    1ebe:	7781      	strb	r1, [r0, #30]
    return 0;           /**< success */
    1ec0:	2000      	movs	r0, #0
    1ec2:	e7fb      	b.n	1ebc <mcp794xx_set_variant+0xc>
        return 2;     /**< return failed error */
    1ec4:	2002      	movs	r0, #2
    1ec6:	e7f9      	b.n	1ebc <mcp794xx_set_variant+0xc>

00001ec8 <mcp794xx_set_debug_print_buffer_size>:
 *            - 3 handle is not initialized
 * @note      none
 */
uint8_t mcp794xx_set_debug_print_buffer_size(mcp794xx_handle_t *const pHandle, mcp794xx_degub_print_buffer_size_t bf_size)
{
    if(pHandle == NULL)
    1ec8:	2800      	cmp	r0, #0
    1eca:	d007      	beq.n	1edc <mcp794xx_set_debug_print_buffer_size+0x14>
        return 2;     /**< return failed error */
    if(pHandle->inited != 1)
    1ecc:	7fc3      	ldrb	r3, [r0, #31]
    1ece:	2b01      	cmp	r3, #1
    1ed0:	d001      	beq.n	1ed6 <mcp794xx_set_debug_print_buffer_size+0xe>
        return 3;      /**< return failed error */
    1ed2:	2003      	movs	r0, #3
    {
        a_mcp794xx_print_error_msg(pHandle,"set debug print function buffer size");
        return 1;
    }
    return 0;       /**< success */
}
    1ed4:	4770      	bx	lr
    pHandle->buffer_size = bf_size;
    1ed6:	6201      	str	r1, [r0, #32]
    return 0;       /**< success */
    1ed8:	2000      	movs	r0, #0
    1eda:	e7fb      	b.n	1ed4 <mcp794xx_set_debug_print_buffer_size+0xc>
        return 2;     /**< return failed error */
    1edc:	2002      	movs	r0, #2
    1ede:	e7f9      	b.n	1ed4 <mcp794xx_set_debug_print_buffer_size+0xc>

00001ee0 <mcp794xx_get_time_and_date>:
 *             - 2 handle or time is NULL
 *             - 3 handle is not initialized
 * @note       none
 */
uint8_t mcp794xx_get_time_and_date(mcp794xx_handle_t *const pHandle, mcp794xx_time_t *pTime)
{
    1ee0:	b5f0      	push	{r4, r5, r6, r7, lr}
    1ee2:	46c6      	mov	lr, r8
    1ee4:	b500      	push	{lr}
    1ee6:	b082      	sub	sp, #8
    1ee8:	0004      	movs	r4, r0
    1eea:	000f      	movs	r7, r1
    uint8_t timeBuffer[MCP794XX_TIME_BUFFER_SIZE];

    if(pHandle == NULL)
    1eec:	2800      	cmp	r0, #0
    1eee:	d05f      	beq.n	1fb0 <mcp794xx_get_time_and_date+0xd0>
        return 2;     /**< return failed error */
    if(pHandle->inited != 1)
    1ef0:	7fc6      	ldrb	r6, [r0, #31]
    1ef2:	2e01      	cmp	r6, #1
    1ef4:	d005      	beq.n	1f02 <mcp794xx_get_time_and_date+0x22>
        return 3;      /**< return failed error */
    1ef6:	2503      	movs	r5, #3
    pTime->date = a_pcf85xxx_bcd2dec(timeBuffer[4] & MCP794XX_DATE_BCD_MASK);
    pTime->month = a_pcf85xxx_bcd2dec(timeBuffer[5] & MCP794XX_MONTH_BCD_MASK);
    pTime->year = a_pcf85xxx_bcd2dec(timeBuffer[6] & MCP794XX_YEAR_BCD_MASK) + 2000;

    return 0;           /**< success */
}
    1ef8:	0028      	movs	r0, r5
    1efa:	b002      	add	sp, #8
    1efc:	bc04      	pop	{r2}
    1efe:	4690      	mov	r8, r2
    1f00:	bdf0      	pop	{r4, r5, r6, r7, pc}
    err = rtc_mcp794xx_i2c_read(pHandle, MCP794XX_RTC_SECOND_REG, (uint8_t *)timeBuffer, MCP794XX_TIME_BUFFER_SIZE);
    1f02:	2307      	movs	r3, #7
    1f04:	466a      	mov	r2, sp
    1f06:	2100      	movs	r1, #0
    1f08:	f7ff fead 	bl	1c66 <rtc_mcp794xx_i2c_read>
    1f0c:	0005      	movs	r5, r0
    1f0e:	4b29      	ldr	r3, [pc, #164]	; (1fb4 <mcp794xx_get_time_and_date+0xd4>)
    1f10:	447b      	add	r3, pc
    1f12:	7018      	strb	r0, [r3, #0]
    if(err)
    1f14:	2800      	cmp	r0, #0
    1f16:	d12f      	bne.n	1f78 <mcp794xx_get_time_and_date+0x98>
    pTime->second = a_pcf85xxx_bcd2dec(timeBuffer[0] & MCP794XX_SEC_BCD_MASK);
    1f18:	466b      	mov	r3, sp
    1f1a:	7818      	ldrb	r0, [r3, #0]
    1f1c:	267f      	movs	r6, #127	; 0x7f
    1f1e:	4030      	ands	r0, r6
    1f20:	f7ff ff2e 	bl	1d80 <a_pcf85xxx_bcd2dec>
    1f24:	7178      	strb	r0, [r7, #5]
    pTime->minute = a_pcf85xxx_bcd2dec(timeBuffer[1] & MCP794XX_MIN_BCD_MASK);
    1f26:	466b      	mov	r3, sp
    1f28:	7858      	ldrb	r0, [r3, #1]
    1f2a:	4030      	ands	r0, r6
    1f2c:	f7ff ff28 	bl	1d80 <a_pcf85xxx_bcd2dec>
    1f30:	7138      	strb	r0, [r7, #4]
    if(pHandle->time_param.time_Format == MCP794XX_24HR_FORMAT)
    1f32:	2370      	movs	r3, #112	; 0x70
    1f34:	5ce3      	ldrb	r3, [r4, r3]
    1f36:	2b00      	cmp	r3, #0
    1f38:	d025      	beq.n	1f86 <mcp794xx_get_time_and_date+0xa6>
    else if(pHandle->time_param.time_Format == MCP794XX_12HR_FORMAT)
    1f3a:	2b01      	cmp	r3, #1
    1f3c:	d02b      	beq.n	1f96 <mcp794xx_get_time_and_date+0xb6>
    pTime->weekDay = a_pcf85xxx_bcd2dec(timeBuffer[3] & MCP794XX_WKDAY_BCD_MASK);
    1f3e:	466c      	mov	r4, sp
    1f40:	78e3      	ldrb	r3, [r4, #3]
    1f42:	2007      	movs	r0, #7
    1f44:	4018      	ands	r0, r3
    1f46:	f7ff ff1b 	bl	1d80 <a_pcf85xxx_bcd2dec>
    1f4a:	71f8      	strb	r0, [r7, #7]
    pTime->date = a_pcf85xxx_bcd2dec(timeBuffer[4] & MCP794XX_DATE_BCD_MASK);
    1f4c:	7923      	ldrb	r3, [r4, #4]
    1f4e:	203f      	movs	r0, #63	; 0x3f
    1f50:	4018      	ands	r0, r3
    1f52:	f7ff ff15 	bl	1d80 <a_pcf85xxx_bcd2dec>
    1f56:	70b8      	strb	r0, [r7, #2]
    pTime->month = a_pcf85xxx_bcd2dec(timeBuffer[5] & MCP794XX_MONTH_BCD_MASK);
    1f58:	7963      	ldrb	r3, [r4, #5]
    1f5a:	201f      	movs	r0, #31
    1f5c:	4018      	ands	r0, r3
    1f5e:	f7ff ff0f 	bl	1d80 <a_pcf85xxx_bcd2dec>
    1f62:	71b8      	strb	r0, [r7, #6]
    pTime->year = a_pcf85xxx_bcd2dec(timeBuffer[6] & MCP794XX_YEAR_BCD_MASK) + 2000;
    1f64:	79a0      	ldrb	r0, [r4, #6]
    1f66:	f7ff ff0b 	bl	1d80 <a_pcf85xxx_bcd2dec>
    1f6a:	b280      	uxth	r0, r0
    1f6c:	23fa      	movs	r3, #250	; 0xfa
    1f6e:	00db      	lsls	r3, r3, #3
    1f70:	469c      	mov	ip, r3
    1f72:	4460      	add	r0, ip
    1f74:	8038      	strh	r0, [r7, #0]
    return 0;           /**< success */
    1f76:	e7bf      	b.n	1ef8 <mcp794xx_get_time_and_date+0x18>
        a_mcp794xx_print_error_msg(pHandle, "read time and date");
    1f78:	490f      	ldr	r1, [pc, #60]	; (1fb8 <mcp794xx_get_time_and_date+0xd8>)
    1f7a:	4479      	add	r1, pc
    1f7c:	0020      	movs	r0, r4
    1f7e:	f7ff fee9 	bl	1d54 <a_mcp794xx_print_error_msg>
        return 1;           /**< failed error */
    1f82:	0035      	movs	r5, r6
    1f84:	e7b8      	b.n	1ef8 <mcp794xx_get_time_and_date+0x18>
        pTime->hour = a_pcf85xxx_bcd2dec(timeBuffer[2] & MCP794XX_24HR_FRMT_BCD_MASK);
    1f86:	466b      	mov	r3, sp
    1f88:	789b      	ldrb	r3, [r3, #2]
    1f8a:	203f      	movs	r0, #63	; 0x3f
    1f8c:	4018      	ands	r0, r3
    1f8e:	f7ff fef7 	bl	1d80 <a_pcf85xxx_bcd2dec>
    1f92:	70f8      	strb	r0, [r7, #3]
    1f94:	e7d3      	b.n	1f3e <mcp794xx_get_time_and_date+0x5e>
        pTime->hour = a_pcf85xxx_bcd2dec(timeBuffer[2] & MCP794XX_12HR_FRMT_BCD_MASK);
    1f96:	466c      	mov	r4, sp
    1f98:	78a3      	ldrb	r3, [r4, #2]
    1f9a:	201f      	movs	r0, #31
    1f9c:	4018      	ands	r0, r3
    1f9e:	f7ff feef 	bl	1d80 <a_pcf85xxx_bcd2dec>
    1fa2:	70f8      	strb	r0, [r7, #3]
        pTime->am_pm_indicator = ((timeBuffer[2] & MCP794XX_TIME_AM_PM_MASK) >> 5) ;
    1fa4:	78a2      	ldrb	r2, [r4, #2]
    1fa6:	1152      	asrs	r2, r2, #5
    1fa8:	2301      	movs	r3, #1
    1faa:	4013      	ands	r3, r2
    1fac:	727b      	strb	r3, [r7, #9]
    1fae:	e7c6      	b.n	1f3e <mcp794xx_get_time_and_date+0x5e>
        return 2;     /**< return failed error */
    1fb0:	2502      	movs	r5, #2
    1fb2:	e7a1      	b.n	1ef8 <mcp794xx_get_time_and_date+0x18>
    1fb4:	1fffe3d0 	.word	0x1fffe3d0
    1fb8:	000051ba 	.word	0x000051ba

00001fbc <mcp794xx_set_hour_format>:
 *          - 0 success
 *          - 1 failed to set time format
 * @note        none
 */
uint8_t mcp794xx_set_hour_format(mcp794xx_handle_t *const pHandle, uint8_t u8Register, mcp794xx_time_format_t format)
{
    1fbc:	b5f0      	push	{r4, r5, r6, r7, lr}
    1fbe:	b083      	sub	sp, #12
    1fc0:	0005      	movs	r5, r0
    1fc2:	000e      	movs	r6, r1
    1fc4:	0017      	movs	r7, r2
    uint8_t read_status;

    if(pHandle == NULL)
    1fc6:	2800      	cmp	r0, #0
    1fc8:	d033      	beq.n	2032 <STACK_SIZE+0x32>
        return 2;      /**< return failed error */
    if(pHandle->inited != 1)
    1fca:	7fc4      	ldrb	r4, [r0, #31]
    1fcc:	2c01      	cmp	r4, #1
    1fce:	d003      	beq.n	1fd8 <mcp794xx_set_hour_format+0x1c>
        return 3;      /**< return failed error */
    1fd0:	2403      	movs	r4, #3
    }

    pHandle->time_param.time_Format = format;

    return 0;              /**< success */
}
    1fd2:	0020      	movs	r0, r4
    1fd4:	b003      	add	sp, #12
    1fd6:	bdf0      	pop	{r4, r5, r6, r7, pc}
    err = rtc_mcp794xx_i2c_read(pHandle, u8Register, (uint8_t*)&read_status, 1);
    1fd8:	b289      	uxth	r1, r1
    1fda:	2301      	movs	r3, #1
    1fdc:	466a      	mov	r2, sp
    1fde:	3207      	adds	r2, #7
    1fe0:	f7ff fe41 	bl	1c66 <rtc_mcp794xx_i2c_read>
    1fe4:	4b14      	ldr	r3, [pc, #80]	; (2038 <STACK_SIZE+0x38>)
    1fe6:	447b      	add	r3, pc
    1fe8:	7018      	strb	r0, [r3, #0]
    if(err)
    1fea:	2800      	cmp	r0, #0
    1fec:	d115      	bne.n	201a <STACK_SIZE+0x1a>
    read_status &= ~(1 << 6);            /*< clear hour format status bit */
    1fee:	466b      	mov	r3, sp
    1ff0:	1dda      	adds	r2, r3, #7
    1ff2:	7813      	ldrb	r3, [r2, #0]
    1ff4:	2140      	movs	r1, #64	; 0x40
    1ff6:	438b      	bics	r3, r1
    1ff8:	0019      	movs	r1, r3
    read_status |= (format << 6);        /*< write hour format status bit */
    1ffa:	01bb      	lsls	r3, r7, #6
    1ffc:	430b      	orrs	r3, r1
    1ffe:	7013      	strb	r3, [r2, #0]
    err = rtc_mcp794xx_i2c_write(pHandle, u8Register, (uint8_t*)&read_status);
    2000:	0031      	movs	r1, r6
    2002:	0028      	movs	r0, r5
    2004:	f7ff fe16 	bl	1c34 <rtc_mcp794xx_i2c_write>
    2008:	4b0c      	ldr	r3, [pc, #48]	; (203c <STACK_SIZE+0x3c>)
    200a:	447b      	add	r3, pc
    200c:	7018      	strb	r0, [r3, #0]
    if(err)
    200e:	2800      	cmp	r0, #0
    2010:	d109      	bne.n	2026 <STACK_SIZE+0x26>
    pHandle->time_param.time_Format = format;
    2012:	2370      	movs	r3, #112	; 0x70
    2014:	54ef      	strb	r7, [r5, r3]
    return 0;              /**< success */
    2016:	0004      	movs	r4, r0
    2018:	e7db      	b.n	1fd2 <mcp794xx_set_hour_format+0x16>
        a_mcp794xx_print_error_msg(pHandle, "read hour format before write");
    201a:	4909      	ldr	r1, [pc, #36]	; (2040 <STACK_SIZE+0x40>)
    201c:	4479      	add	r1, pc
    201e:	0028      	movs	r0, r5
    2020:	f7ff fe98 	bl	1d54 <a_mcp794xx_print_error_msg>
        return 1;            /**< failed error */
    2024:	e7d5      	b.n	1fd2 <mcp794xx_set_hour_format+0x16>
        a_mcp794xx_print_error_msg(pHandle, "set hour format ");
    2026:	4907      	ldr	r1, [pc, #28]	; (2044 <STACK_SIZE+0x44>)
    2028:	4479      	add	r1, pc
    202a:	0028      	movs	r0, r5
    202c:	f7ff fe92 	bl	1d54 <a_mcp794xx_print_error_msg>
        return 1;           /**< failed error */
    2030:	e7cf      	b.n	1fd2 <mcp794xx_set_hour_format+0x16>
        return 2;      /**< return failed error */
    2032:	2402      	movs	r4, #2
    2034:	e7cd      	b.n	1fd2 <mcp794xx_set_hour_format+0x16>
    2036:	46c0      	nop			; (mov r8, r8)
    2038:	1fffe2fa 	.word	0x1fffe2fa
    203c:	1fffe2d6 	.word	0x1fffe2d6
    2040:	0000512c 	.word	0x0000512c
    2044:	00005140 	.word	0x00005140

00002048 <mcp794xx_get_hour_format>:
 *          - 0 success
 *          - 1 failed to set time format
 * @note        none
 */
uint8_t mcp794xx_get_hour_format(mcp794xx_handle_t *const pHandle, uint8_t u8Register, mcp794xx_time_format_t *pFormat)
{
    2048:	b570      	push	{r4, r5, r6, lr}
    204a:	b082      	sub	sp, #8
    204c:	0004      	movs	r4, r0
    204e:	0016      	movs	r6, r2
    uint8_t read_status;

    if(pHandle == NULL)
    2050:	2800      	cmp	r0, #0
    2052:	d020      	beq.n	2096 <mcp794xx_get_hour_format+0x4e>
        return 2;     /**< return failed error */
    if(pHandle->inited != 1)
    2054:	7fc5      	ldrb	r5, [r0, #31]
    2056:	2d01      	cmp	r5, #1
    2058:	d002      	beq.n	2060 <mcp794xx_get_hour_format+0x18>
        return 3;      /**< return failed error */
    205a:	2003      	movs	r0, #3
    pHandle->time_param.time_Format = *pFormat;

    *pFormat =  pHandle->time_param.time_Format;

    return 0;              /**< success */
}
    205c:	b002      	add	sp, #8
    205e:	bd70      	pop	{r4, r5, r6, pc}
    err = rtc_mcp794xx_i2c_read(pHandle, u8Register, (uint8_t *)&read_status, 1);
    2060:	b289      	uxth	r1, r1
    2062:	2301      	movs	r3, #1
    2064:	466a      	mov	r2, sp
    2066:	3207      	adds	r2, #7
    2068:	f7ff fdfd 	bl	1c66 <rtc_mcp794xx_i2c_read>
    206c:	4a0b      	ldr	r2, [pc, #44]	; (209c <mcp794xx_get_hour_format+0x54>)
    206e:	447a      	add	r2, pc
    2070:	7010      	strb	r0, [r2, #0]
    if(err)
    2072:	2800      	cmp	r0, #0
    2074:	d108      	bne.n	2088 <mcp794xx_get_hour_format+0x40>
    *pFormat = (mcp794xx_time_format_t)((read_status & MCP794XX_ALARMx_12HR_24HR_FRMT_STAT_MASK) >> 6);
    2076:	466b      	mov	r3, sp
    2078:	79da      	ldrb	r2, [r3, #7]
    207a:	1192      	asrs	r2, r2, #6
    207c:	2301      	movs	r3, #1
    207e:	4013      	ands	r3, r2
    pHandle->time_param.time_Format = *pFormat;
    2080:	2270      	movs	r2, #112	; 0x70
    2082:	54a3      	strb	r3, [r4, r2]
    *pFormat =  pHandle->time_param.time_Format;
    2084:	7033      	strb	r3, [r6, #0]
    return 0;              /**< success */
    2086:	e7e9      	b.n	205c <mcp794xx_get_hour_format+0x14>
        a_mcp794xx_print_error_msg(pHandle, "get hour format");
    2088:	4905      	ldr	r1, [pc, #20]	; (20a0 <mcp794xx_get_hour_format+0x58>)
    208a:	4479      	add	r1, pc
    208c:	0020      	movs	r0, r4
    208e:	f7ff fe61 	bl	1d54 <a_mcp794xx_print_error_msg>
        return 1;           /**< failed error */
    2092:	0028      	movs	r0, r5
    2094:	e7e2      	b.n	205c <mcp794xx_get_hour_format+0x14>
        return 2;     /**< return failed error */
    2096:	2002      	movs	r0, #2
    2098:	e7e0      	b.n	205c <mcp794xx_get_hour_format+0x14>
    209a:	46c0      	nop			; (mov r8, r8)
    209c:	1fffe272 	.word	0x1fffe272
    20a0:	000050f2 	.word	0x000050f2

000020a4 <mcp794xx_set_am_pm>:
 *          - 1 failed to set AM/PM period
            - 2 handle null
 *          - 3 handle is not initialized
 */
uint8_t mcp794xx_set_am_pm(mcp794xx_handle_t *const pHandle, uint8_t u8Register, mcp794xx_am_pm_indicator_t am_pm)
{
    20a4:	b5f0      	push	{r4, r5, r6, r7, lr}
    20a6:	b083      	sub	sp, #12
    20a8:	0004      	movs	r4, r0
    20aa:	000f      	movs	r7, r1
    20ac:	0016      	movs	r6, r2
    uint8_t read_status;

    if(pHandle == NULL)
    20ae:	2800      	cmp	r0, #0
    20b0:	d02f      	beq.n	2112 <mcp794xx_set_am_pm+0x6e>
        return 2;     /**< return failed error */
    if(pHandle->inited != 1)
    20b2:	7fc5      	ldrb	r5, [r0, #31]
    20b4:	2d01      	cmp	r5, #1
    20b6:	d002      	beq.n	20be <mcp794xx_set_am_pm+0x1a>
        return 3;      /**< return failed error */
    20b8:	2003      	movs	r0, #3
        return 1;           /**< failed error */
    }


    return 0;              /**< success */
}
    20ba:	b003      	add	sp, #12
    20bc:	bdf0      	pop	{r4, r5, r6, r7, pc}
    err = rtc_mcp794xx_i2c_read(pHandle, u8Register, (uint8_t *)&read_status, 1);
    20be:	b289      	uxth	r1, r1
    20c0:	2301      	movs	r3, #1
    20c2:	466a      	mov	r2, sp
    20c4:	3207      	adds	r2, #7
    20c6:	f7ff fdce 	bl	1c66 <rtc_mcp794xx_i2c_read>
    20ca:	4b13      	ldr	r3, [pc, #76]	; (2118 <mcp794xx_set_am_pm+0x74>)
    20cc:	447b      	add	r3, pc
    20ce:	7018      	strb	r0, [r3, #0]
    if(err)
    20d0:	2800      	cmp	r0, #0
    20d2:	d117      	bne.n	2104 <mcp794xx_set_am_pm+0x60>
    read_status &= ~(1 << 5);
    20d4:	466b      	mov	r3, sp
    20d6:	1dda      	adds	r2, r3, #7
    20d8:	7813      	ldrb	r3, [r2, #0]
    20da:	2120      	movs	r1, #32
    20dc:	438b      	bics	r3, r1
    read_status |= (am_pm << 5);
    20de:	0176      	lsls	r6, r6, #5
    20e0:	431e      	orrs	r6, r3
    20e2:	7016      	strb	r6, [r2, #0]
    err = rtc_mcp794xx_i2c_write(pHandle, u8Register, (uint8_t *)&read_status);
    20e4:	0039      	movs	r1, r7
    20e6:	0020      	movs	r0, r4
    20e8:	f7ff fda4 	bl	1c34 <rtc_mcp794xx_i2c_write>
    20ec:	4a0b      	ldr	r2, [pc, #44]	; (211c <mcp794xx_set_am_pm+0x78>)
    20ee:	447a      	add	r2, pc
    20f0:	7010      	strb	r0, [r2, #0]
    if(err)
    20f2:	2800      	cmp	r0, #0
    20f4:	d0e1      	beq.n	20ba <mcp794xx_set_am_pm+0x16>
        a_mcp794xx_print_error_msg(pHandle, "set time am/pm indicator");
    20f6:	490a      	ldr	r1, [pc, #40]	; (2120 <mcp794xx_set_am_pm+0x7c>)
    20f8:	4479      	add	r1, pc
    20fa:	0020      	movs	r0, r4
    20fc:	f7ff fe2a 	bl	1d54 <a_mcp794xx_print_error_msg>
        return 1;           /**< failed error */
    2100:	0028      	movs	r0, r5
    2102:	e7da      	b.n	20ba <mcp794xx_set_am_pm+0x16>
        a_mcp794xx_print_error_msg(pHandle, "read time am/pm indicator before write");
    2104:	4907      	ldr	r1, [pc, #28]	; (2124 <mcp794xx_set_am_pm+0x80>)
    2106:	4479      	add	r1, pc
    2108:	0020      	movs	r0, r4
    210a:	f7ff fe23 	bl	1d54 <a_mcp794xx_print_error_msg>
        return 1;           /**< failed error */
    210e:	0028      	movs	r0, r5
    2110:	e7d3      	b.n	20ba <mcp794xx_set_am_pm+0x16>
        return 2;     /**< return failed error */
    2112:	2002      	movs	r0, #2
    2114:	e7d1      	b.n	20ba <mcp794xx_set_am_pm+0x16>
    2116:	46c0      	nop			; (mov r8, r8)
    2118:	1fffe214 	.word	0x1fffe214
    211c:	1fffe1f2 	.word	0x1fffe1f2
    2120:	000050bc 	.word	0x000050bc
    2124:	00005086 	.word	0x00005086

00002128 <mcp794xx_set_time_and_date>:
{
    2128:	b5f0      	push	{r4, r5, r6, r7, lr}
    212a:	b085      	sub	sp, #20
    212c:	0005      	movs	r5, r0
    212e:	000e      	movs	r6, r1
    if(pHandle == NULL)
    2130:	2800      	cmp	r0, #0
    2132:	d100      	bne.n	2136 <mcp794xx_set_time_and_date+0xe>
    2134:	e164      	b.n	2400 <mcp794xx_set_time_and_date+0x2d8>
    if(pHandle->inited != 1)
    2136:	7fc4      	ldrb	r4, [r0, #31]
    2138:	2c01      	cmp	r4, #1
    213a:	d003      	beq.n	2144 <mcp794xx_set_time_and_date+0x1c>
        return 3;      /**< return failed error */
    213c:	2403      	movs	r4, #3
}
    213e:	0020      	movs	r0, r4
    2140:	b005      	add	sp, #20
    2142:	bdf0      	pop	{r4, r5, r6, r7, pc}
        if((pTime->year < 0) || (pTime->year > 99))
    2144:	880b      	ldrh	r3, [r1, #0]
    2146:	2b63      	cmp	r3, #99	; 0x63
    2148:	d900      	bls.n	214c <mcp794xx_set_time_and_date+0x24>
    214a:	e090      	b.n	226e <mcp794xx_set_time_and_date+0x146>
        if((pTime->month < 1) || (pTime->month > 12))
    214c:	798b      	ldrb	r3, [r1, #6]
    214e:	3b01      	subs	r3, #1
    2150:	b2db      	uxtb	r3, r3
    2152:	2b0b      	cmp	r3, #11
    2154:	d900      	bls.n	2158 <mcp794xx_set_time_and_date+0x30>
    2156:	e090      	b.n	227a <mcp794xx_set_time_and_date+0x152>
        if((pTime->date < 1) || (pTime->date > 31))
    2158:	788b      	ldrb	r3, [r1, #2]
    215a:	3b01      	subs	r3, #1
    215c:	b2db      	uxtb	r3, r3
    215e:	2b1e      	cmp	r3, #30
    2160:	d900      	bls.n	2164 <mcp794xx_set_time_and_date+0x3c>
    2162:	e090      	b.n	2286 <mcp794xx_set_time_and_date+0x15e>
        if((pTime->weekDay < 1) || (pTime->weekDay > 7))
    2164:	79cb      	ldrb	r3, [r1, #7]
    2166:	3b01      	subs	r3, #1
    2168:	b2db      	uxtb	r3, r3
    216a:	2b06      	cmp	r3, #6
    216c:	d900      	bls.n	2170 <mcp794xx_set_time_and_date+0x48>
    216e:	e090      	b.n	2292 <mcp794xx_set_time_and_date+0x16a>
        if((pTime->minute < 0) || (pTime->minute > 59))
    2170:	790b      	ldrb	r3, [r1, #4]
    2172:	2b3b      	cmp	r3, #59	; 0x3b
    2174:	d900      	bls.n	2178 <mcp794xx_set_time_and_date+0x50>
    2176:	e092      	b.n	229e <mcp794xx_set_time_and_date+0x176>
        if((pTime->second < 0) || (pTime->second > 59))
    2178:	794b      	ldrb	r3, [r1, #5]
    217a:	2b3b      	cmp	r3, #59	; 0x3b
    217c:	d900      	bls.n	2180 <mcp794xx_set_time_and_date+0x58>
    217e:	e094      	b.n	22aa <mcp794xx_set_time_and_date+0x182>
    if(pHandle->time_param.time_Format == MCP794XX_24HR_FORMAT)
    2180:	2370      	movs	r3, #112	; 0x70
    2182:	5cc3      	ldrb	r3, [r0, r3]
    2184:	2b00      	cmp	r3, #0
    2186:	d000      	beq.n	218a <mcp794xx_set_time_and_date+0x62>
    2188:	e09b      	b.n	22c2 <mcp794xx_set_time_and_date+0x19a>
        if((pTime->hour < 0) || (pTime->hour > 23))
    218a:	78cb      	ldrb	r3, [r1, #3]
    218c:	2b17      	cmp	r3, #23
    218e:	d900      	bls.n	2192 <mcp794xx_set_time_and_date+0x6a>
    2190:	e091      	b.n	22b6 <mcp794xx_set_time_and_date+0x18e>
    memset(ptimeBuffer, 0, sizeof(ptimeBuffer));
    2192:	2207      	movs	r2, #7
    2194:	2100      	movs	r1, #0
    2196:	af02      	add	r7, sp, #8
    2198:	0038      	movs	r0, r7
    219a:	f004 f80a 	bl	61b2 <memset>
    err = rtc_mcp794xx_i2c_read(pHandle, MCP794XX_RTC_SECOND_REG, (uint8_t *)ptimeBuffer, MCP794XX_TIME_BUFFER_SIZE);
    219e:	2307      	movs	r3, #7
    21a0:	003a      	movs	r2, r7
    21a2:	2100      	movs	r1, #0
    21a4:	0028      	movs	r0, r5
    21a6:	f7ff fd5e 	bl	1c66 <rtc_mcp794xx_i2c_read>
    21aa:	4b96      	ldr	r3, [pc, #600]	; (2404 <mcp794xx_set_time_and_date+0x2dc>)
    21ac:	447b      	add	r3, pc
    21ae:	7018      	strb	r0, [r3, #0]
    if(err)
    21b0:	2800      	cmp	r0, #0
    21b2:	d000      	beq.n	21b6 <mcp794xx_set_time_and_date+0x8e>
    21b4:	e099      	b.n	22ea <mcp794xx_set_time_and_date+0x1c2>
    status = (ptimeBuffer[0] & MCP794XX_ST_MASK) | a_pcf85xxx_dec2bcd(pTime->second);
    21b6:	ab02      	add	r3, sp, #8
    21b8:	2700      	movs	r7, #0
    21ba:	57df      	ldrsb	r7, [r3, r7]
    21bc:	237f      	movs	r3, #127	; 0x7f
    21be:	439f      	bics	r7, r3
    21c0:	7970      	ldrb	r0, [r6, #5]
    21c2:	f7ff fdcf 	bl	1d64 <a_pcf85xxx_dec2bcd>
    21c6:	b240      	sxtb	r0, r0
    21c8:	4307      	orrs	r7, r0
    21ca:	466b      	mov	r3, sp
    21cc:	1dda      	adds	r2, r3, #7
    21ce:	7017      	strb	r7, [r2, #0]
    err =  rtc_mcp794xx_i2c_write(pHandle, MCP794XX_RTC_SECOND_REG,  (uint8_t *)&status);
    21d0:	2100      	movs	r1, #0
    21d2:	0028      	movs	r0, r5
    21d4:	f7ff fd2e 	bl	1c34 <rtc_mcp794xx_i2c_write>
    21d8:	4b8b      	ldr	r3, [pc, #556]	; (2408 <mcp794xx_set_time_and_date+0x2e0>)
    21da:	447b      	add	r3, pc
    21dc:	7018      	strb	r0, [r3, #0]
    if(err)
    21de:	2800      	cmp	r0, #0
    21e0:	d000      	beq.n	21e4 <mcp794xx_set_time_and_date+0xbc>
    21e2:	e088      	b.n	22f6 <mcp794xx_set_time_and_date+0x1ce>
    status = a_pcf85xxx_dec2bcd(pTime->minute);
    21e4:	7930      	ldrb	r0, [r6, #4]
    21e6:	f7ff fdbd 	bl	1d64 <a_pcf85xxx_dec2bcd>
    21ea:	466b      	mov	r3, sp
    21ec:	1dda      	adds	r2, r3, #7
    21ee:	7010      	strb	r0, [r2, #0]
    err = rtc_mcp794xx_i2c_write(pHandle, MCP794XX_RTC_MINUTE_REG, (uint8_t *)&status);
    21f0:	2101      	movs	r1, #1
    21f2:	0028      	movs	r0, r5
    21f4:	f7ff fd1e 	bl	1c34 <rtc_mcp794xx_i2c_write>
    21f8:	4b84      	ldr	r3, [pc, #528]	; (240c <mcp794xx_set_time_and_date+0x2e4>)
    21fa:	447b      	add	r3, pc
    21fc:	7018      	strb	r0, [r3, #0]
    if(err)
    21fe:	2800      	cmp	r0, #0
    2200:	d000      	beq.n	2204 <mcp794xx_set_time_and_date+0xdc>
    2202:	e07e      	b.n	2302 <mcp794xx_set_time_and_date+0x1da>
    if(pHandle->time_param.time_Format == MCP794XX_24HR_FORMAT)
    2204:	2370      	movs	r3, #112	; 0x70
    2206:	5ceb      	ldrb	r3, [r5, r3]
    2208:	2b00      	cmp	r3, #0
    220a:	d100      	bne.n	220e <mcp794xx_set_time_and_date+0xe6>
    220c:	e07f      	b.n	230e <mcp794xx_set_time_and_date+0x1e6>
    else if(pHandle->time_param.time_Format == MCP794XX_12HR_FORMAT)
    220e:	2b01      	cmp	r3, #1
    2210:	d100      	bne.n	2214 <mcp794xx_set_time_and_date+0xec>
    2212:	e092      	b.n	233a <mcp794xx_set_time_and_date+0x212>
    status = a_pcf85xxx_dec2bcd(pTime->weekDay) | (ptimeBuffer[3] & (MCP794XX_OSC_RUN_STATUS_MASK | MCP794XX_PWR_FAIL_STATUS_MASK | MCP794XX_VBAT_EN_MASK));
    2214:	79f0      	ldrb	r0, [r6, #7]
    2216:	f7ff fda5 	bl	1d64 <a_pcf85xxx_dec2bcd>
    221a:	b240      	sxtb	r0, r0
    221c:	ab02      	add	r3, sp, #8
    221e:	78db      	ldrb	r3, [r3, #3]
    2220:	b25b      	sxtb	r3, r3
    2222:	2238      	movs	r2, #56	; 0x38
    2224:	4013      	ands	r3, r2
    2226:	4318      	orrs	r0, r3
    2228:	466b      	mov	r3, sp
    222a:	1dda      	adds	r2, r3, #7
    222c:	7010      	strb	r0, [r2, #0]
    err = rtc_mcp794xx_i2c_write(pHandle, MCP794XX_RTC_WKDAY_REG, (uint8_t *)&status);
    222e:	2103      	movs	r1, #3
    2230:	0028      	movs	r0, r5
    2232:	f7ff fcff 	bl	1c34 <rtc_mcp794xx_i2c_write>
    2236:	4b76      	ldr	r3, [pc, #472]	; (2410 <mcp794xx_set_time_and_date+0x2e8>)
    2238:	447b      	add	r3, pc
    223a:	7018      	strb	r0, [r3, #0]
    if(err)
    223c:	2800      	cmp	r0, #0
    223e:	d000      	beq.n	2242 <mcp794xx_set_time_and_date+0x11a>
    2240:	e0a4      	b.n	238c <mcp794xx_set_time_and_date+0x264>
    status = a_pcf85xxx_dec2bcd(pTime->date);
    2242:	78b0      	ldrb	r0, [r6, #2]
    2244:	f7ff fd8e 	bl	1d64 <a_pcf85xxx_dec2bcd>
    2248:	466b      	mov	r3, sp
    224a:	1dda      	adds	r2, r3, #7
    224c:	7010      	strb	r0, [r2, #0]
    err = rtc_mcp794xx_i2c_write(pHandle, MCP794XX_RTC_DATE_REG, (uint8_t *)&status);
    224e:	2104      	movs	r1, #4
    2250:	0028      	movs	r0, r5
    2252:	f7ff fcef 	bl	1c34 <rtc_mcp794xx_i2c_write>
    2256:	4b6f      	ldr	r3, [pc, #444]	; (2414 <mcp794xx_set_time_and_date+0x2ec>)
    2258:	447b      	add	r3, pc
    225a:	7018      	strb	r0, [r3, #0]
    if(err)
    225c:	2800      	cmp	r0, #0
    225e:	d100      	bne.n	2262 <mcp794xx_set_time_and_date+0x13a>
    2260:	e09a      	b.n	2398 <mcp794xx_set_time_and_date+0x270>
        a_mcp794xx_print_error_msg(pHandle, "to write date");
    2262:	496d      	ldr	r1, [pc, #436]	; (2418 <mcp794xx_set_time_and_date+0x2f0>)
    2264:	4479      	add	r1, pc
    2266:	0028      	movs	r0, r5
    2268:	f7ff fd74 	bl	1d54 <a_mcp794xx_print_error_msg>
        return 1;
    226c:	e767      	b.n	213e <mcp794xx_set_time_and_date+0x16>
            a_mcp794xx_print_error_msg(pHandle, "set time, year can not be less than 0 or greater than 99");
    226e:	496b      	ldr	r1, [pc, #428]	; (241c <mcp794xx_set_time_and_date+0x2f4>)
    2270:	4479      	add	r1, pc
    2272:	f7ff fd6f 	bl	1d54 <a_mcp794xx_print_error_msg>
            return 4;
    2276:	3403      	adds	r4, #3
    2278:	e761      	b.n	213e <mcp794xx_set_time_and_date+0x16>
            a_mcp794xx_print_error_msg(pHandle, "set time, month can not be less than 1 or greater than 12");
    227a:	4969      	ldr	r1, [pc, #420]	; (2420 <mcp794xx_set_time_and_date+0x2f8>)
    227c:	4479      	add	r1, pc
    227e:	f7ff fd69 	bl	1d54 <a_mcp794xx_print_error_msg>
            return 4;
    2282:	2404      	movs	r4, #4
    2284:	e75b      	b.n	213e <mcp794xx_set_time_and_date+0x16>
            a_mcp794xx_print_error_msg(pHandle, "set time, date can not be less than 1 or greater than 31");
    2286:	4967      	ldr	r1, [pc, #412]	; (2424 <mcp794xx_set_time_and_date+0x2fc>)
    2288:	4479      	add	r1, pc
    228a:	f7ff fd63 	bl	1d54 <a_mcp794xx_print_error_msg>
            return 4;
    228e:	2404      	movs	r4, #4
    2290:	e755      	b.n	213e <mcp794xx_set_time_and_date+0x16>
            a_mcp794xx_print_error_msg(pHandle, "set time, week day can not be less than 1 or greater than 7");
    2292:	4965      	ldr	r1, [pc, #404]	; (2428 <mcp794xx_set_time_and_date+0x300>)
    2294:	4479      	add	r1, pc
    2296:	f7ff fd5d 	bl	1d54 <a_mcp794xx_print_error_msg>
            return 4;
    229a:	2404      	movs	r4, #4
    229c:	e74f      	b.n	213e <mcp794xx_set_time_and_date+0x16>
            a_mcp794xx_print_error_msg(pHandle, "set time, minute can not be less than 0 or greater than 59");
    229e:	4963      	ldr	r1, [pc, #396]	; (242c <mcp794xx_set_time_and_date+0x304>)
    22a0:	4479      	add	r1, pc
    22a2:	f7ff fd57 	bl	1d54 <a_mcp794xx_print_error_msg>
            return 4;
    22a6:	2404      	movs	r4, #4
    22a8:	e749      	b.n	213e <mcp794xx_set_time_and_date+0x16>
            a_mcp794xx_print_error_msg(pHandle, "set time, seconds can not be less than 0 or greater than 59");
    22aa:	4961      	ldr	r1, [pc, #388]	; (2430 <mcp794xx_set_time_and_date+0x308>)
    22ac:	4479      	add	r1, pc
    22ae:	f7ff fd51 	bl	1d54 <a_mcp794xx_print_error_msg>
            return 4;
    22b2:	2404      	movs	r4, #4
    22b4:	e743      	b.n	213e <mcp794xx_set_time_and_date+0x16>
            a_mcp794xx_print_error_msg(pHandle, "set time, hour can not be less than 0 or greater than 23");
    22b6:	495f      	ldr	r1, [pc, #380]	; (2434 <mcp794xx_set_time_and_date+0x30c>)
    22b8:	4479      	add	r1, pc
    22ba:	f7ff fd4b 	bl	1d54 <a_mcp794xx_print_error_msg>
            return 4;
    22be:	2404      	movs	r4, #4
    22c0:	e73d      	b.n	213e <mcp794xx_set_time_and_date+0x16>
    else if(pHandle->time_param.time_Format == MCP794XX_12HR_FORMAT)
    22c2:	2b01      	cmp	r3, #1
    22c4:	d005      	beq.n	22d2 <mcp794xx_set_time_and_date+0x1aa>
        a_mcp794xx_print_error_msg(pHandle, "set time, invalid time format");
    22c6:	495c      	ldr	r1, [pc, #368]	; (2438 <mcp794xx_set_time_and_date+0x310>)
    22c8:	4479      	add	r1, pc
    22ca:	f7ff fd43 	bl	1d54 <a_mcp794xx_print_error_msg>
        return 4;
    22ce:	2404      	movs	r4, #4
    22d0:	e735      	b.n	213e <mcp794xx_set_time_and_date+0x16>
        if((pTime->hour < 1) || (pTime->hour > 12))
    22d2:	78cb      	ldrb	r3, [r1, #3]
    22d4:	3b01      	subs	r3, #1
    22d6:	b2db      	uxtb	r3, r3
    22d8:	2b0b      	cmp	r3, #11
    22da:	d800      	bhi.n	22de <mcp794xx_set_time_and_date+0x1b6>
    22dc:	e759      	b.n	2192 <mcp794xx_set_time_and_date+0x6a>
            a_mcp794xx_print_error_msg(pHandle, "set time, hour can not be less than 1 or greater than 12");
    22de:	4957      	ldr	r1, [pc, #348]	; (243c <mcp794xx_set_time_and_date+0x314>)
    22e0:	4479      	add	r1, pc
    22e2:	f7ff fd37 	bl	1d54 <a_mcp794xx_print_error_msg>
            return 4;
    22e6:	2404      	movs	r4, #4
    22e8:	e729      	b.n	213e <mcp794xx_set_time_and_date+0x16>
        a_mcp794xx_print_error_msg(pHandle, "read time before write");
    22ea:	4955      	ldr	r1, [pc, #340]	; (2440 <mcp794xx_set_time_and_date+0x318>)
    22ec:	4479      	add	r1, pc
    22ee:	0028      	movs	r0, r5
    22f0:	f7ff fd30 	bl	1d54 <a_mcp794xx_print_error_msg>
        return 1;
    22f4:	e723      	b.n	213e <mcp794xx_set_time_and_date+0x16>
        a_mcp794xx_print_error_msg(pHandle, "to write seconds");
    22f6:	4953      	ldr	r1, [pc, #332]	; (2444 <mcp794xx_set_time_and_date+0x31c>)
    22f8:	4479      	add	r1, pc
    22fa:	0028      	movs	r0, r5
    22fc:	f7ff fd2a 	bl	1d54 <a_mcp794xx_print_error_msg>
        return 1;
    2300:	e71d      	b.n	213e <mcp794xx_set_time_and_date+0x16>
        a_mcp794xx_print_error_msg(pHandle, "to write minutes");
    2302:	4951      	ldr	r1, [pc, #324]	; (2448 <mcp794xx_set_time_and_date+0x320>)
    2304:	4479      	add	r1, pc
    2306:	0028      	movs	r0, r5
    2308:	f7ff fd24 	bl	1d54 <a_mcp794xx_print_error_msg>
        return 1;
    230c:	e717      	b.n	213e <mcp794xx_set_time_and_date+0x16>
        status = a_pcf85xxx_dec2bcd(pTime->hour);
    230e:	78f0      	ldrb	r0, [r6, #3]
    2310:	f7ff fd28 	bl	1d64 <a_pcf85xxx_dec2bcd>
    2314:	466b      	mov	r3, sp
    2316:	1dda      	adds	r2, r3, #7
    2318:	7010      	strb	r0, [r2, #0]
        err = rtc_mcp794xx_i2c_write(pHandle, MCP794XX_RTC_HOUR_REG,  (uint8_t *)&status);
    231a:	2102      	movs	r1, #2
    231c:	0028      	movs	r0, r5
    231e:	f7ff fc89 	bl	1c34 <rtc_mcp794xx_i2c_write>
    2322:	4b4a      	ldr	r3, [pc, #296]	; (244c <mcp794xx_set_time_and_date+0x324>)
    2324:	447b      	add	r3, pc
    2326:	7018      	strb	r0, [r3, #0]
        if(err)
    2328:	2800      	cmp	r0, #0
    232a:	d100      	bne.n	232e <mcp794xx_set_time_and_date+0x206>
    232c:	e772      	b.n	2214 <mcp794xx_set_time_and_date+0xec>
            a_mcp794xx_print_error_msg(pHandle, "to write hours");
    232e:	4948      	ldr	r1, [pc, #288]	; (2450 <mcp794xx_set_time_and_date+0x328>)
    2330:	4479      	add	r1, pc
    2332:	0028      	movs	r0, r5
    2334:	f7ff fd0e 	bl	1d54 <a_mcp794xx_print_error_msg>
            return 1;
    2338:	e701      	b.n	213e <mcp794xx_set_time_and_date+0x16>
        status = a_pcf85xxx_dec2bcd(pTime->hour) |(ptimeBuffer[2] & (MCP794XX_12HR_24HR_FRMT_STAT_MASK | MCP794XX_TIME_AM_PM_MASK));
    233a:	78f0      	ldrb	r0, [r6, #3]
    233c:	f7ff fd12 	bl	1d64 <a_pcf85xxx_dec2bcd>
    2340:	b240      	sxtb	r0, r0
    2342:	ab02      	add	r3, sp, #8
    2344:	789b      	ldrb	r3, [r3, #2]
    2346:	b25b      	sxtb	r3, r3
    2348:	2260      	movs	r2, #96	; 0x60
    234a:	4013      	ands	r3, r2
    234c:	4318      	orrs	r0, r3
    234e:	466b      	mov	r3, sp
    2350:	1dda      	adds	r2, r3, #7
    2352:	7010      	strb	r0, [r2, #0]
        err = rtc_mcp794xx_i2c_write(pHandle, MCP794XX_RTC_HOUR_REG, (uint8_t *)&status);
    2354:	2102      	movs	r1, #2
    2356:	0028      	movs	r0, r5
    2358:	f7ff fc6c 	bl	1c34 <rtc_mcp794xx_i2c_write>
    235c:	4b3d      	ldr	r3, [pc, #244]	; (2454 <mcp794xx_set_time_and_date+0x32c>)
    235e:	447b      	add	r3, pc
    2360:	7018      	strb	r0, [r3, #0]
        if(err)
    2362:	2800      	cmp	r0, #0
    2364:	d005      	beq.n	2372 <mcp794xx_set_time_and_date+0x24a>
            a_mcp794xx_print_error_msg(pHandle, "to write hours");
    2366:	493c      	ldr	r1, [pc, #240]	; (2458 <mcp794xx_set_time_and_date+0x330>)
    2368:	4479      	add	r1, pc
    236a:	0028      	movs	r0, r5
    236c:	f7ff fcf2 	bl	1d54 <a_mcp794xx_print_error_msg>
            return 1;
    2370:	e6e5      	b.n	213e <mcp794xx_set_time_and_date+0x16>
        err = mcp794xx_set_am_pm(pHandle, MCP794XX_RTC_HOUR_REG, pTime->am_pm_indicator);
    2372:	7a72      	ldrb	r2, [r6, #9]
    2374:	2102      	movs	r1, #2
    2376:	0028      	movs	r0, r5
    2378:	f7ff fe94 	bl	20a4 <mcp794xx_set_am_pm>
    237c:	4b37      	ldr	r3, [pc, #220]	; (245c <mcp794xx_set_time_and_date+0x334>)
    237e:	447b      	add	r3, pc
    2380:	7018      	strb	r0, [r3, #0]
        if(err)
    2382:	2800      	cmp	r0, #0
    2384:	d100      	bne.n	2388 <mcp794xx_set_time_and_date+0x260>
    2386:	e745      	b.n	2214 <mcp794xx_set_time_and_date+0xec>
            return err;
    2388:	0004      	movs	r4, r0
    238a:	e6d8      	b.n	213e <mcp794xx_set_time_and_date+0x16>
        a_mcp794xx_print_error_msg(pHandle, "to write week day");
    238c:	4934      	ldr	r1, [pc, #208]	; (2460 <mcp794xx_set_time_and_date+0x338>)
    238e:	4479      	add	r1, pc
    2390:	0028      	movs	r0, r5
    2392:	f7ff fcdf 	bl	1d54 <a_mcp794xx_print_error_msg>
        return 1;
    2396:	e6d2      	b.n	213e <mcp794xx_set_time_and_date+0x16>
    status = a_pcf85xxx_dec2bcd(pTime->month) | (a_pcf85xxx_bcd2dec(ptimeBuffer[5] & MCP794XX_LEAP_YEAR_STATUS_MASK));
    2398:	79b0      	ldrb	r0, [r6, #6]
    239a:	f7ff fce3 	bl	1d64 <a_pcf85xxx_dec2bcd>
    239e:	0007      	movs	r7, r0
    23a0:	ab02      	add	r3, sp, #8
    23a2:	7958      	ldrb	r0, [r3, #5]
    23a4:	2320      	movs	r3, #32
    23a6:	4018      	ands	r0, r3
    23a8:	f7ff fcea 	bl	1d80 <a_pcf85xxx_bcd2dec>
    23ac:	4307      	orrs	r7, r0
    23ae:	466b      	mov	r3, sp
    23b0:	1dda      	adds	r2, r3, #7
    23b2:	7017      	strb	r7, [r2, #0]
    err = rtc_mcp794xx_i2c_write(pHandle, MCP794XX_RTC_MONTH_REG,  (uint8_t *)&status);
    23b4:	2105      	movs	r1, #5
    23b6:	0028      	movs	r0, r5
    23b8:	f7ff fc3c 	bl	1c34 <rtc_mcp794xx_i2c_write>
    23bc:	4b29      	ldr	r3, [pc, #164]	; (2464 <mcp794xx_set_time_and_date+0x33c>)
    23be:	447b      	add	r3, pc
    23c0:	7018      	strb	r0, [r3, #0]
    if(err)
    23c2:	2800      	cmp	r0, #0
    23c4:	d110      	bne.n	23e8 <mcp794xx_set_time_and_date+0x2c0>
    status = a_pcf85xxx_dec2bcd(pTime->year);
    23c6:	7830      	ldrb	r0, [r6, #0]
    23c8:	f7ff fccc 	bl	1d64 <a_pcf85xxx_dec2bcd>
    23cc:	466b      	mov	r3, sp
    23ce:	1dda      	adds	r2, r3, #7
    23d0:	7010      	strb	r0, [r2, #0]
    err = rtc_mcp794xx_i2c_write(pHandle, MCP794XX_RTC_YEAR_REG, (uint8_t *)&status);
    23d2:	2106      	movs	r1, #6
    23d4:	0028      	movs	r0, r5
    23d6:	f7ff fc2d 	bl	1c34 <rtc_mcp794xx_i2c_write>
    23da:	4b23      	ldr	r3, [pc, #140]	; (2468 <mcp794xx_set_time_and_date+0x340>)
    23dc:	447b      	add	r3, pc
    23de:	7018      	strb	r0, [r3, #0]
    if(err)
    23e0:	2800      	cmp	r0, #0
    23e2:	d107      	bne.n	23f4 <mcp794xx_set_time_and_date+0x2cc>
    return 0;           /**< success */
    23e4:	0004      	movs	r4, r0
    23e6:	e6aa      	b.n	213e <mcp794xx_set_time_and_date+0x16>
        a_mcp794xx_print_error_msg(pHandle, "to write month");
    23e8:	4920      	ldr	r1, [pc, #128]	; (246c <mcp794xx_set_time_and_date+0x344>)
    23ea:	4479      	add	r1, pc
    23ec:	0028      	movs	r0, r5
    23ee:	f7ff fcb1 	bl	1d54 <a_mcp794xx_print_error_msg>
        return 1;
    23f2:	e6a4      	b.n	213e <mcp794xx_set_time_and_date+0x16>
        a_mcp794xx_print_error_msg(pHandle, "to write year");
    23f4:	491e      	ldr	r1, [pc, #120]	; (2470 <mcp794xx_set_time_and_date+0x348>)
    23f6:	4479      	add	r1, pc
    23f8:	0028      	movs	r0, r5
    23fa:	f7ff fcab 	bl	1d54 <a_mcp794xx_print_error_msg>
        return 1;
    23fe:	e69e      	b.n	213e <mcp794xx_set_time_and_date+0x16>
        return 2;     /**< return failed error */
    2400:	2402      	movs	r4, #2
    2402:	e69c      	b.n	213e <mcp794xx_set_time_and_date+0x16>
    2404:	1fffe134 	.word	0x1fffe134
    2408:	1fffe106 	.word	0x1fffe106
    240c:	1fffe0e6 	.word	0x1fffe0e6
    2410:	1fffe0a8 	.word	0x1fffe0a8
    2414:	1fffe088 	.word	0x1fffe088
    2418:	000051d0 	.word	0x000051d0
    241c:	00004f60 	.word	0x00004f60
    2420:	00004f90 	.word	0x00004f90
    2424:	00004fc0 	.word	0x00004fc0
    2428:	00004ff0 	.word	0x00004ff0
    242c:	00005020 	.word	0x00005020
    2430:	00005050 	.word	0x00005050
    2434:	00005080 	.word	0x00005080
    2438:	000050e8 	.word	0x000050e8
    243c:	00005094 	.word	0x00005094
    2440:	000050e4 	.word	0x000050e4
    2444:	000050f0 	.word	0x000050f0
    2448:	000050f8 	.word	0x000050f8
    244c:	1fffdfbc 	.word	0x1fffdfbc
    2450:	000050e0 	.word	0x000050e0
    2454:	1fffdf82 	.word	0x1fffdf82
    2458:	000050a8 	.word	0x000050a8
    245c:	1fffdf62 	.word	0x1fffdf62
    2460:	00005092 	.word	0x00005092
    2464:	1fffdf22 	.word	0x1fffdf22
    2468:	1fffdf04 	.word	0x1fffdf04
    246c:	0000505a 	.word	0x0000505a
    2470:	0000505e 	.word	0x0000505e

00002474 <mcp794xx_get_am_pm>:
 *          - 1 failed to get AM/PM period
            - 2 handle null
 *          - 3 handle is not initialized
 */
uint8_t mcp794xx_get_am_pm(mcp794xx_handle_t *const pHandle, uint8_t u8Register, mcp794xx_am_pm_indicator_t *pAm_pm)
{
    2474:	b570      	push	{r4, r5, r6, lr}
    2476:	b082      	sub	sp, #8
    2478:	0004      	movs	r4, r0
    247a:	0016      	movs	r6, r2
    uint8_t read_status;

    if(pHandle == NULL)
    247c:	2800      	cmp	r0, #0
    247e:	d01e      	beq.n	24be <mcp794xx_get_am_pm+0x4a>
        return 2;     /**< return failed error */
    if(pHandle->inited != 1)
    2480:	7fc5      	ldrb	r5, [r0, #31]
    2482:	2d01      	cmp	r5, #1
    2484:	d002      	beq.n	248c <mcp794xx_get_am_pm+0x18>
        return 3;      /**< return failed error */
    2486:	2003      	movs	r0, #3
    }

    *pAm_pm = (mcp794xx_am_pm_indicator_t)((read_status & MCP794XX_ALARMx_AM_PM_MASK) >> 5);

    return 0;              /**< success */
}
    2488:	b002      	add	sp, #8
    248a:	bd70      	pop	{r4, r5, r6, pc}
    err = rtc_mcp794xx_i2c_read(pHandle, u8Register, (uint8_t *)&read_status, 1);
    248c:	b289      	uxth	r1, r1
    248e:	2301      	movs	r3, #1
    2490:	466a      	mov	r2, sp
    2492:	3207      	adds	r2, #7
    2494:	f7ff fbe7 	bl	1c66 <rtc_mcp794xx_i2c_read>
    2498:	4a0a      	ldr	r2, [pc, #40]	; (24c4 <mcp794xx_get_am_pm+0x50>)
    249a:	447a      	add	r2, pc
    249c:	7010      	strb	r0, [r2, #0]
    if(err)
    249e:	2800      	cmp	r0, #0
    24a0:	d106      	bne.n	24b0 <mcp794xx_get_am_pm+0x3c>
    *pAm_pm = (mcp794xx_am_pm_indicator_t)((read_status & MCP794XX_ALARMx_AM_PM_MASK) >> 5);
    24a2:	466b      	mov	r3, sp
    24a4:	79da      	ldrb	r2, [r3, #7]
    24a6:	1152      	asrs	r2, r2, #5
    24a8:	2301      	movs	r3, #1
    24aa:	4013      	ands	r3, r2
    24ac:	7033      	strb	r3, [r6, #0]
    return 0;              /**< success */
    24ae:	e7eb      	b.n	2488 <mcp794xx_get_am_pm+0x14>
        a_mcp794xx_print_error_msg(pHandle, "read time am/pm indicator");
    24b0:	4905      	ldr	r1, [pc, #20]	; (24c8 <mcp794xx_get_am_pm+0x54>)
    24b2:	4479      	add	r1, pc
    24b4:	0020      	movs	r0, r4
    24b6:	f7ff fc4d 	bl	1d54 <a_mcp794xx_print_error_msg>
        return 1;           /**< failed error */
    24ba:	0028      	movs	r0, r5
    24bc:	e7e4      	b.n	2488 <mcp794xx_get_am_pm+0x14>
        return 2;     /**< return failed error */
    24be:	2002      	movs	r0, #2
    24c0:	e7e2      	b.n	2488 <mcp794xx_get_am_pm+0x14>
    24c2:	46c0      	nop			; (mov r8, r8)
    24c4:	1fffde46 	.word	0x1fffde46
    24c8:	00004fb2 	.word	0x00004fb2

000024cc <mcp794xx_set_osc_status>:
 *          - 1 failed to set oscillator status bit
            - 2 handle null
 *          - 3 handle is not initialized
 */
uint8_t mcp794xx_set_osc_status(mcp794xx_handle_t *const pHandle, mcp794xx_osc_status_t status)
{
    24cc:	b570      	push	{r4, r5, r6, lr}
    24ce:	b082      	sub	sp, #8
    24d0:	0004      	movs	r4, r0
    24d2:	000e      	movs	r6, r1
    uint8_t read_status;

    if(pHandle == NULL)
    24d4:	2800      	cmp	r0, #0
    24d6:	d02f      	beq.n	2538 <mcp794xx_set_osc_status+0x6c>
        return 2;     /**< return failed error */
    if(pHandle->inited != 1)
    24d8:	7fc5      	ldrb	r5, [r0, #31]
    24da:	2d01      	cmp	r5, #1
    24dc:	d002      	beq.n	24e4 <mcp794xx_set_osc_status+0x18>
        return 3;      /**< return failed error */
    24de:	2003      	movs	r0, #3
        a_mcp794xx_print_error_msg(pHandle, "set oscillator status");
        return 1;           /**< failed error */
    }

    return 0;              /**< success */
}
    24e0:	b002      	add	sp, #8
    24e2:	bd70      	pop	{r4, r5, r6, pc}
    err = rtc_mcp794xx_i2c_read(pHandle, MCP794XX_RTC_SECOND_REG, (uint8_t *)&read_status, 1);
    24e4:	2301      	movs	r3, #1
    24e6:	466a      	mov	r2, sp
    24e8:	3207      	adds	r2, #7
    24ea:	2100      	movs	r1, #0
    24ec:	f7ff fbbb 	bl	1c66 <rtc_mcp794xx_i2c_read>
    24f0:	4b12      	ldr	r3, [pc, #72]	; (253c <mcp794xx_set_osc_status+0x70>)
    24f2:	447b      	add	r3, pc
    24f4:	7018      	strb	r0, [r3, #0]
    if(err)
    24f6:	2800      	cmp	r0, #0
    24f8:	d117      	bne.n	252a <mcp794xx_set_osc_status+0x5e>
    read_status &= ~(1 << 7);
    24fa:	466b      	mov	r3, sp
    24fc:	1dda      	adds	r2, r3, #7
    24fe:	7811      	ldrb	r1, [r2, #0]
    2500:	237f      	movs	r3, #127	; 0x7f
    2502:	400b      	ands	r3, r1
    read_status |= (status << 7);
    2504:	01f6      	lsls	r6, r6, #7
    2506:	431e      	orrs	r6, r3
    2508:	7016      	strb	r6, [r2, #0]
    err = rtc_mcp794xx_i2c_write(pHandle, MCP794XX_RTC_SECOND_REG, (uint8_t*)&read_status);
    250a:	2100      	movs	r1, #0
    250c:	0020      	movs	r0, r4
    250e:	f7ff fb91 	bl	1c34 <rtc_mcp794xx_i2c_write>
    2512:	4a0b      	ldr	r2, [pc, #44]	; (2540 <mcp794xx_set_osc_status+0x74>)
    2514:	447a      	add	r2, pc
    2516:	7010      	strb	r0, [r2, #0]
    if(err)
    2518:	2800      	cmp	r0, #0
    251a:	d0e1      	beq.n	24e0 <mcp794xx_set_osc_status+0x14>
        a_mcp794xx_print_error_msg(pHandle, "set oscillator status");
    251c:	4909      	ldr	r1, [pc, #36]	; (2544 <mcp794xx_set_osc_status+0x78>)
    251e:	4479      	add	r1, pc
    2520:	0020      	movs	r0, r4
    2522:	f7ff fc17 	bl	1d54 <a_mcp794xx_print_error_msg>
        return 1;           /**< failed error */
    2526:	0028      	movs	r0, r5
    2528:	e7da      	b.n	24e0 <mcp794xx_set_osc_status+0x14>
        a_mcp794xx_print_error_msg(pHandle, "read oscillator status before write");
    252a:	4907      	ldr	r1, [pc, #28]	; (2548 <mcp794xx_set_osc_status+0x7c>)
    252c:	4479      	add	r1, pc
    252e:	0020      	movs	r0, r4
    2530:	f7ff fc10 	bl	1d54 <a_mcp794xx_print_error_msg>
        return 1;           /**< failed error */
    2534:	0028      	movs	r0, r5
    2536:	e7d3      	b.n	24e0 <mcp794xx_set_osc_status+0x14>
        return 2;     /**< return failed error */
    2538:	2002      	movs	r0, #2
    253a:	e7d1      	b.n	24e0 <mcp794xx_set_osc_status+0x14>
    253c:	1fffddee 	.word	0x1fffddee
    2540:	1fffddcc 	.word	0x1fffddcc
    2544:	00004f86 	.word	0x00004f86
    2548:	00004f54 	.word	0x00004f54

0000254c <mcp794xx_get_pwr_fail_time_stamp>:
 * @note    - The PWRFAIL bit must be cleared to log new timestamp data.
            - Reading or writing the external battery back up bit will clear the pwr fail time stamp.
            - Time stamp should be read at start up before reading or setting current time and date.
 */
uint8_t mcp794xx_get_pwr_fail_time_stamp(mcp794xx_handle_t *const pHandle, mcp794xx_pwr_fail_type_t powerMode, mcp794xx_time_t *pTime)
{
    254c:	b570      	push	{r4, r5, r6, lr}
    254e:	b082      	sub	sp, #8
    2550:	0005      	movs	r5, r0
    2552:	0016      	movs	r6, r2

    uint8_t timeBuffer[MCP794XX_PWRFAIL_BUFFER_LENGTH];

    if(pHandle == NULL)
    2554:	2800      	cmp	r0, #0
    2556:	d100      	bne.n	255a <mcp794xx_get_pwr_fail_time_stamp+0xe>
    2558:	e06a      	b.n	2630 <mcp794xx_get_pwr_fail_time_stamp+0xe4>
        return 2;     /**< return failed error */
    if(pHandle->inited != 1)
    255a:	7fc4      	ldrb	r4, [r0, #31]
    255c:	2c01      	cmp	r4, #1
    255e:	d003      	beq.n	2568 <mcp794xx_get_pwr_fail_time_stamp+0x1c>
        return 3;      /**< return failed error */
    2560:	2403      	movs	r4, #3
    }
    pTime->date = a_pcf85xxx_bcd2dec(timeBuffer[2] & MCP794XX_PWRXX_DATE_BCD_MASK);          /**< read the power failure date */
    pTime->month = a_pcf85xxx_bcd2dec(timeBuffer[3] & MCP794XX_MONTH_BCD_MASK);              /**< read the power failure month timestamp */

    return 0;  /**< success */
}
    2562:	0020      	movs	r0, r4
    2564:	b002      	add	sp, #8
    2566:	bd70      	pop	{r4, r5, r6, pc}
    if(pHandle->device_variant == MCP7940M_VARIANT){
    2568:	7f83      	ldrb	r3, [r0, #30]
    256a:	2b03      	cmp	r3, #3
    256c:	d009      	beq.n	2582 <mcp794xx_get_pwr_fail_time_stamp+0x36>
   switch((int)powerMode)
    256e:	2900      	cmp	r1, #0
    2570:	d00d      	beq.n	258e <mcp794xx_get_pwr_fail_time_stamp+0x42>
    2572:	2901      	cmp	r1, #1
    2574:	d037      	beq.n	25e6 <mcp794xx_get_pwr_fail_time_stamp+0x9a>
         a_mcp794xx_print_error_msg(pHandle, "invalid pwr fail mode selected");
    2576:	492f      	ldr	r1, [pc, #188]	; (2634 <mcp794xx_get_pwr_fail_time_stamp+0xe8>)
    2578:	4479      	add	r1, pc
    257a:	f7ff fbeb 	bl	1d54 <a_mcp794xx_print_error_msg>
        return 4;   /**< invalid power failure mode */
    257e:	2404      	movs	r4, #4
    2580:	e7ef      	b.n	2562 <mcp794xx_get_pwr_fail_time_stamp+0x16>
         a_mcp794xx_print_error_msg(pHandle, "read power-up time stamp, not supported for the mcp7940M variant");
    2582:	492d      	ldr	r1, [pc, #180]	; (2638 <mcp794xx_get_pwr_fail_time_stamp+0xec>)
    2584:	4479      	add	r1, pc
    2586:	f7ff fbe5 	bl	1d54 <a_mcp794xx_print_error_msg>
        return 4;
    258a:	3403      	adds	r4, #3
    258c:	e7e9      	b.n	2562 <mcp794xx_get_pwr_fail_time_stamp+0x16>
            err = rtc_mcp794xx_i2c_read(pHandle, MCP794XX_PWR_DWN_MIN_REG, (uint8_t *)timeBuffer, MCP794XX_PWRFAIL_BUFFER_LENGTH);
    258e:	2304      	movs	r3, #4
    2590:	aa01      	add	r2, sp, #4
    2592:	2118      	movs	r1, #24
    2594:	f7ff fb67 	bl	1c66 <rtc_mcp794xx_i2c_read>
    2598:	4b28      	ldr	r3, [pc, #160]	; (263c <mcp794xx_get_pwr_fail_time_stamp+0xf0>)
    259a:	447b      	add	r3, pc
    259c:	7018      	strb	r0, [r3, #0]
            if(err)
    259e:	2800      	cmp	r0, #0
    25a0:	d11b      	bne.n	25da <mcp794xx_get_pwr_fail_time_stamp+0x8e>
    pTime->minute = a_pcf85xxx_bcd2dec(timeBuffer[0] & MCP794XX_PWRXX_MIN_BCD_MASK);         /**< read the power failure minute timestamp */
    25a2:	ab01      	add	r3, sp, #4
    25a4:	781b      	ldrb	r3, [r3, #0]
    25a6:	207f      	movs	r0, #127	; 0x7f
    25a8:	4018      	ands	r0, r3
    25aa:	f7ff fbe9 	bl	1d80 <a_pcf85xxx_bcd2dec>
    25ae:	7130      	strb	r0, [r6, #4]
    if(pHandle->time_param.time_Format == MCP794XX_24HR_FORMAT)                              /**< read the power failure hour timestamp in 24hr format*/
    25b0:	2370      	movs	r3, #112	; 0x70
    25b2:	5ceb      	ldrb	r3, [r5, r3]
    25b4:	2b00      	cmp	r3, #0
    25b6:	d026      	beq.n	2606 <mcp794xx_get_pwr_fail_time_stamp+0xba>
    else if(pHandle->time_param.time_Format == MCP794XX_12HR_FORMAT)                          /**< read the power failure hour timestamp in 12hr format*/
    25b8:	2b01      	cmp	r3, #1
    25ba:	d02c      	beq.n	2616 <mcp794xx_get_pwr_fail_time_stamp+0xca>
    pTime->date = a_pcf85xxx_bcd2dec(timeBuffer[2] & MCP794XX_PWRXX_DATE_BCD_MASK);          /**< read the power failure date */
    25bc:	ac01      	add	r4, sp, #4
    25be:	78a3      	ldrb	r3, [r4, #2]
    25c0:	203f      	movs	r0, #63	; 0x3f
    25c2:	4018      	ands	r0, r3
    25c4:	f7ff fbdc 	bl	1d80 <a_pcf85xxx_bcd2dec>
    25c8:	70b0      	strb	r0, [r6, #2]
    pTime->month = a_pcf85xxx_bcd2dec(timeBuffer[3] & MCP794XX_MONTH_BCD_MASK);              /**< read the power failure month timestamp */
    25ca:	78e3      	ldrb	r3, [r4, #3]
    25cc:	201f      	movs	r0, #31
    25ce:	4018      	ands	r0, r3
    25d0:	f7ff fbd6 	bl	1d80 <a_pcf85xxx_bcd2dec>
    25d4:	71b0      	strb	r0, [r6, #6]
    return 0;  /**< success */
    25d6:	2400      	movs	r4, #0
    25d8:	e7c3      	b.n	2562 <mcp794xx_get_pwr_fail_time_stamp+0x16>
                a_mcp794xx_print_error_msg(pHandle, "read power-down time stamp");
    25da:	4919      	ldr	r1, [pc, #100]	; (2640 <mcp794xx_get_pwr_fail_time_stamp+0xf4>)
    25dc:	4479      	add	r1, pc
    25de:	0028      	movs	r0, r5
    25e0:	f7ff fbb8 	bl	1d54 <a_mcp794xx_print_error_msg>
                return 1;           /**< failed error */
    25e4:	e7bd      	b.n	2562 <mcp794xx_get_pwr_fail_time_stamp+0x16>
            err = rtc_mcp794xx_i2c_read(pHandle, MCP794XX_PWR_UP_MIN_REG, (uint8_t *)timeBuffer, MCP794XX_PWRFAIL_BUFFER_LENGTH);
    25e6:	2304      	movs	r3, #4
    25e8:	aa01      	add	r2, sp, #4
    25ea:	211c      	movs	r1, #28
    25ec:	f7ff fb3b 	bl	1c66 <rtc_mcp794xx_i2c_read>
    25f0:	4b14      	ldr	r3, [pc, #80]	; (2644 <mcp794xx_get_pwr_fail_time_stamp+0xf8>)
    25f2:	447b      	add	r3, pc
    25f4:	7018      	strb	r0, [r3, #0]
            if(err)
    25f6:	2800      	cmp	r0, #0
    25f8:	d0d3      	beq.n	25a2 <mcp794xx_get_pwr_fail_time_stamp+0x56>
                a_mcp794xx_print_error_msg(pHandle, "read power-up time stamp");
    25fa:	4913      	ldr	r1, [pc, #76]	; (2648 <mcp794xx_get_pwr_fail_time_stamp+0xfc>)
    25fc:	4479      	add	r1, pc
    25fe:	0028      	movs	r0, r5
    2600:	f7ff fba8 	bl	1d54 <a_mcp794xx_print_error_msg>
                return 1;           /**< failed error */
    2604:	e7ad      	b.n	2562 <mcp794xx_get_pwr_fail_time_stamp+0x16>
        pTime->hour = a_pcf85xxx_bcd2dec(timeBuffer[1] & MCP794XX_PWRXX_24HR_FRMT_BCD_MASK);
    2606:	ab01      	add	r3, sp, #4
    2608:	785b      	ldrb	r3, [r3, #1]
    260a:	203f      	movs	r0, #63	; 0x3f
    260c:	4018      	ands	r0, r3
    260e:	f7ff fbb7 	bl	1d80 <a_pcf85xxx_bcd2dec>
    2612:	70f0      	strb	r0, [r6, #3]
    2614:	e7d2      	b.n	25bc <mcp794xx_get_pwr_fail_time_stamp+0x70>
        pTime->hour = a_pcf85xxx_bcd2dec(timeBuffer[1] & MCP794XX_PWRXX_12HR_FRMT_BCD_MASK);
    2616:	ac01      	add	r4, sp, #4
    2618:	7863      	ldrb	r3, [r4, #1]
    261a:	201f      	movs	r0, #31
    261c:	4018      	ands	r0, r3
    261e:	f7ff fbaf 	bl	1d80 <a_pcf85xxx_bcd2dec>
    2622:	70f0      	strb	r0, [r6, #3]
        pTime->am_pm_indicator = ((timeBuffer[1] & MCP794XX_PWRXX_TIME_AM_PM_MASK) >> 5) ;
    2624:	7862      	ldrb	r2, [r4, #1]
    2626:	1152      	asrs	r2, r2, #5
    2628:	2301      	movs	r3, #1
    262a:	4013      	ands	r3, r2
    262c:	7273      	strb	r3, [r6, #9]
    262e:	e7c5      	b.n	25bc <mcp794xx_get_pwr_fail_time_stamp+0x70>
        return 2;     /**< return failed error */
    2630:	2402      	movs	r4, #2
    2632:	e796      	b.n	2562 <mcp794xx_get_pwr_fail_time_stamp+0x16>
    2634:	0000507c 	.word	0x0000507c
    2638:	00004ff4 	.word	0x00004ff4
    263c:	1fffdd46 	.word	0x1fffdd46
    2640:	00004fe0 	.word	0x00004fe0
    2644:	1fffdcee 	.word	0x1fffdcee
    2648:	00004fdc 	.word	0x00004fdc

0000264c <mcp794xx_set_pwr_fail_time_param>:
 *          - 1 failed
            - 2 handle null
 *          - 3 handle is not initialized
 */
uint8_t mcp794xx_set_pwr_fail_time_param(mcp794xx_handle_t *const pHandle)
{
    264c:	b510      	push	{r4, lr}
    264e:	b082      	sub	sp, #8
    2650:	0004      	movs	r4, r0
	uint8_t format, am_pm_indicator;

    if(pHandle->device_variant == MCP7940M_VARIANT){
    2652:	7f83      	ldrb	r3, [r0, #30]
    2654:	2b03      	cmp	r3, #3
    2656:	d03f      	beq.n	26d8 <mcp794xx_set_pwr_fail_time_param+0x8c>
         a_mcp794xx_print_error_msg(pHandle, "pwr fail param, not supported for the mcp7940M variant");
        return 4;
    }

	err = mcp794xx_get_hour_format(pHandle, MCP794XX_RTC_HOUR_REG, &format);
    2658:	466b      	mov	r3, sp
    265a:	1dda      	adds	r2, r3, #7
    265c:	2102      	movs	r1, #2
    265e:	f7ff fcf3 	bl	2048 <mcp794xx_get_hour_format>
    2662:	4a21      	ldr	r2, [pc, #132]	; (26e8 <mcp794xx_set_pwr_fail_time_param+0x9c>)
    2664:	447a      	add	r2, pc
    2666:	7010      	strb	r0, [r2, #0]
	if(err){
    2668:	2800      	cmp	r0, #0
    266a:	d13a      	bne.n	26e2 <mcp794xx_set_pwr_fail_time_param+0x96>
	  return err;
	}

	err = mcp794xx_get_am_pm(pHandle, MCP794XX_RTC_HOUR_REG, &am_pm_indicator);
    266c:	466b      	mov	r3, sp
    266e:	1d9a      	adds	r2, r3, #6
    2670:	2102      	movs	r1, #2
    2672:	0020      	movs	r0, r4
    2674:	f7ff fefe 	bl	2474 <mcp794xx_get_am_pm>
    2678:	4a1c      	ldr	r2, [pc, #112]	; (26ec <mcp794xx_set_pwr_fail_time_param+0xa0>)
    267a:	447a      	add	r2, pc
    267c:	7010      	strb	r0, [r2, #0]
	if(err){
    267e:	2800      	cmp	r0, #0
    2680:	d12f      	bne.n	26e2 <mcp794xx_set_pwr_fail_time_param+0x96>
	  return err;
	}

	err = mcp794xx_set_hour_format(pHandle, MCP794XX_PWR_DWN_HOUR_REG, format);          /**< set time format for power down time stamp */
    2682:	466b      	mov	r3, sp
    2684:	79da      	ldrb	r2, [r3, #7]
    2686:	2119      	movs	r1, #25
    2688:	0020      	movs	r0, r4
    268a:	f7ff fc97 	bl	1fbc <mcp794xx_set_hour_format>
    268e:	4a18      	ldr	r2, [pc, #96]	; (26f0 <mcp794xx_set_pwr_fail_time_param+0xa4>)
    2690:	447a      	add	r2, pc
    2692:	7010      	strb	r0, [r2, #0]
	if(err){
    2694:	2800      	cmp	r0, #0
    2696:	d124      	bne.n	26e2 <mcp794xx_set_pwr_fail_time_param+0x96>
	  return err;
	}

	err = mcp794xx_set_hour_format(pHandle, MCP794XX_PWR_UP_HOUR_REG, format);          /**< set time format for power up time stamp */
    2698:	466b      	mov	r3, sp
    269a:	79da      	ldrb	r2, [r3, #7]
    269c:	211d      	movs	r1, #29
    269e:	0020      	movs	r0, r4
    26a0:	f7ff fc8c 	bl	1fbc <mcp794xx_set_hour_format>
    26a4:	4a13      	ldr	r2, [pc, #76]	; (26f4 <mcp794xx_set_pwr_fail_time_param+0xa8>)
    26a6:	447a      	add	r2, pc
    26a8:	7010      	strb	r0, [r2, #0]
	if(err){
    26aa:	2800      	cmp	r0, #0
    26ac:	d119      	bne.n	26e2 <mcp794xx_set_pwr_fail_time_param+0x96>
	  return err;
	}

	err = mcp794xx_set_am_pm(pHandle, MCP794XX_PWR_DWN_HOUR_REG,  am_pm_indicator);
    26ae:	466b      	mov	r3, sp
    26b0:	799a      	ldrb	r2, [r3, #6]
    26b2:	2119      	movs	r1, #25
    26b4:	0020      	movs	r0, r4
    26b6:	f7ff fcf5 	bl	20a4 <mcp794xx_set_am_pm>
    26ba:	4a0f      	ldr	r2, [pc, #60]	; (26f8 <mcp794xx_set_pwr_fail_time_param+0xac>)
    26bc:	447a      	add	r2, pc
    26be:	7010      	strb	r0, [r2, #0]
	if(err){
    26c0:	2800      	cmp	r0, #0
    26c2:	d10e      	bne.n	26e2 <mcp794xx_set_pwr_fail_time_param+0x96>
	  return err;
	}
	err = mcp794xx_set_am_pm(pHandle, MCP794XX_PWR_UP_HOUR_REG,  am_pm_indicator);
    26c4:	466b      	mov	r3, sp
    26c6:	799a      	ldrb	r2, [r3, #6]
    26c8:	211d      	movs	r1, #29
    26ca:	0020      	movs	r0, r4
    26cc:	f7ff fcea 	bl	20a4 <mcp794xx_set_am_pm>
    26d0:	4a0a      	ldr	r2, [pc, #40]	; (26fc <mcp794xx_set_pwr_fail_time_param+0xb0>)
    26d2:	447a      	add	r2, pc
    26d4:	7010      	strb	r0, [r2, #0]
    26d6:	e004      	b.n	26e2 <mcp794xx_set_pwr_fail_time_param+0x96>
         a_mcp794xx_print_error_msg(pHandle, "pwr fail param, not supported for the mcp7940M variant");
    26d8:	4909      	ldr	r1, [pc, #36]	; (2700 <mcp794xx_set_pwr_fail_time_param+0xb4>)
    26da:	4479      	add	r1, pc
    26dc:	f7ff fb3a 	bl	1d54 <a_mcp794xx_print_error_msg>
        return 4;
    26e0:	2004      	movs	r0, #4
	if(err){
	  return err;
	}
	return 0; 			/**< success */
}
    26e2:	b002      	add	sp, #8
    26e4:	bd10      	pop	{r4, pc}
    26e6:	46c0      	nop			; (mov r8, r8)
    26e8:	1fffdc7c 	.word	0x1fffdc7c
    26ec:	1fffdc66 	.word	0x1fffdc66
    26f0:	1fffdc50 	.word	0x1fffdc50
    26f4:	1fffdc3a 	.word	0x1fffdc3a
    26f8:	1fffdc24 	.word	0x1fffdc24
    26fc:	1fffdc0e 	.word	0x1fffdc0e
    2700:	00004f3a 	.word	0x00004f3a

00002704 <mcp794xx_set_alarm_enable_status>:
*          - 1 failed
           - 2 handle null
*          - 3 handle is not initialized
*/
uint8_t mcp794xx_set_alarm_enable_status(mcp794xx_handle_t *const pHandle, mcp794xx_alarm_t alarm, mcp794xx_bool_t status)
{
    2704:	b5f0      	push	{r4, r5, r6, r7, lr}
    2706:	b083      	sub	sp, #12
    2708:	0004      	movs	r4, r0
    270a:	000f      	movs	r7, r1
    270c:	0016      	movs	r6, r2
    uint8_t read_status;

    if(pHandle == NULL)
    270e:	2800      	cmp	r0, #0
    2710:	d04a      	beq.n	27a8 <mcp794xx_set_alarm_enable_status+0xa4>
        return 2;     /**< return failed error */
    if(pHandle->inited != 1)
    2712:	7fc5      	ldrb	r5, [r0, #31]
    2714:	2d01      	cmp	r5, #1
    2716:	d002      	beq.n	271e <mcp794xx_set_alarm_enable_status+0x1a>
        return 3;      /**< return failed error */
    2718:	2003      	movs	r0, #3
        a_mcp794xx_print_error_msg(pHandle, "invalid alarm selected");
        return 4;           /**< invalid alarm */
    }

    return 0;              /**< success */
}
    271a:	b003      	add	sp, #12
    271c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    err = rtc_mcp794xx_i2c_read(pHandle, MCP794XX_CONTROL_REG, (uint8_t *)&read_status, 1);
    271e:	2301      	movs	r3, #1
    2720:	466a      	mov	r2, sp
    2722:	3207      	adds	r2, #7
    2724:	2107      	movs	r1, #7
    2726:	f7ff fa9e 	bl	1c66 <rtc_mcp794xx_i2c_read>
    272a:	4b20      	ldr	r3, [pc, #128]	; (27ac <mcp794xx_set_alarm_enable_status+0xa8>)
    272c:	447b      	add	r3, pc
    272e:	7018      	strb	r0, [r3, #0]
    if(err)
    2730:	2800      	cmp	r0, #0
    2732:	d12b      	bne.n	278c <mcp794xx_set_alarm_enable_status+0x88>
    if(alarm == MCP794XX_ALARM0)
    2734:	2f00      	cmp	r7, #0
    2736:	d111      	bne.n	275c <mcp794xx_set_alarm_enable_status+0x58>
        read_status &= ~(1 << 4);           /**< clear alarm enable status */
    2738:	466b      	mov	r3, sp
    273a:	1dda      	adds	r2, r3, #7
    273c:	7813      	ldrb	r3, [r2, #0]
    273e:	2110      	movs	r1, #16
    2740:	438b      	bics	r3, r1
    2742:	0019      	movs	r1, r3
        read_status |= (status << 4);
    2744:	0133      	lsls	r3, r6, #4
    2746:	430b      	orrs	r3, r1
    2748:	7013      	strb	r3, [r2, #0]
        err = rtc_mcp794xx_i2c_write(pHandle, MCP794XX_CONTROL_REG, (uint8_t *)&read_status);
    274a:	2107      	movs	r1, #7
    274c:	0020      	movs	r0, r4
    274e:	f7ff fa71 	bl	1c34 <rtc_mcp794xx_i2c_write>
    2752:	4b17      	ldr	r3, [pc, #92]	; (27b0 <mcp794xx_set_alarm_enable_status+0xac>)
    2754:	447b      	add	r3, pc
    2756:	7018      	strb	r0, [r3, #0]
        if(err)
    2758:	2800      	cmp	r0, #0
    275a:	d11e      	bne.n	279a <mcp794xx_set_alarm_enable_status+0x96>
        read_status &= ~(1 << 5);           /**< clear alarm enable status */
    275c:	466b      	mov	r3, sp
    275e:	1dda      	adds	r2, r3, #7
    2760:	7813      	ldrb	r3, [r2, #0]
    2762:	2120      	movs	r1, #32
    2764:	438b      	bics	r3, r1
        read_status |= (status << 5);
    2766:	0176      	lsls	r6, r6, #5
    2768:	431e      	orrs	r6, r3
    276a:	7016      	strb	r6, [r2, #0]
        err = rtc_mcp794xx_i2c_write(pHandle, MCP794XX_CONTROL_REG, (uint8_t *)&read_status);
    276c:	3919      	subs	r1, #25
    276e:	0020      	movs	r0, r4
    2770:	f7ff fa60 	bl	1c34 <rtc_mcp794xx_i2c_write>
    2774:	4a0f      	ldr	r2, [pc, #60]	; (27b4 <mcp794xx_set_alarm_enable_status+0xb0>)
    2776:	447a      	add	r2, pc
    2778:	7010      	strb	r0, [r2, #0]
        if(err)
    277a:	2800      	cmp	r0, #0
    277c:	d0cd      	beq.n	271a <mcp794xx_set_alarm_enable_status+0x16>
            a_mcp794xx_print_error_msg(pHandle, "write alarm enable status");
    277e:	490e      	ldr	r1, [pc, #56]	; (27b8 <mcp794xx_set_alarm_enable_status+0xb4>)
    2780:	4479      	add	r1, pc
    2782:	0020      	movs	r0, r4
    2784:	f7ff fae6 	bl	1d54 <a_mcp794xx_print_error_msg>
            return 1;           /**< failed error */
    2788:	0028      	movs	r0, r5
    278a:	e7c6      	b.n	271a <mcp794xx_set_alarm_enable_status+0x16>
        a_mcp794xx_print_error_msg(pHandle, "read control register");
    278c:	490b      	ldr	r1, [pc, #44]	; (27bc <mcp794xx_set_alarm_enable_status+0xb8>)
    278e:	4479      	add	r1, pc
    2790:	0020      	movs	r0, r4
    2792:	f7ff fadf 	bl	1d54 <a_mcp794xx_print_error_msg>
        return 1;           /**< failed error */
    2796:	0028      	movs	r0, r5
    2798:	e7bf      	b.n	271a <mcp794xx_set_alarm_enable_status+0x16>
            a_mcp794xx_print_error_msg(pHandle, "write alarm enable status");
    279a:	4909      	ldr	r1, [pc, #36]	; (27c0 <mcp794xx_set_alarm_enable_status+0xbc>)
    279c:	4479      	add	r1, pc
    279e:	0020      	movs	r0, r4
    27a0:	f7ff fad8 	bl	1d54 <a_mcp794xx_print_error_msg>
            return 1;           /**< failed error */
    27a4:	0028      	movs	r0, r5
    27a6:	e7b8      	b.n	271a <mcp794xx_set_alarm_enable_status+0x16>
        return 2;     /**< return failed error */
    27a8:	2002      	movs	r0, #2
    27aa:	e7b6      	b.n	271a <mcp794xx_set_alarm_enable_status+0x16>
    27ac:	1fffdbb4 	.word	0x1fffdbb4
    27b0:	1fffdb8c 	.word	0x1fffdb8c
    27b4:	1fffdb6a 	.word	0x1fffdb6a
    27b8:	00004efc 	.word	0x00004efc
    27bc:	00004ed6 	.word	0x00004ed6
    27c0:	00004ee0 	.word	0x00004ee0

000027c4 <mcp794xx_set_alarm_interrupt_output_polarity>:
 *          - 3 handle is not initialized
 *          - 4 invalid alarm
 * @note none
 */
uint8_t mcp794xx_set_alarm_interrupt_output_polarity(mcp794xx_handle_t *const pHandle, mcp794xx_alarm_t alarm, mcp794xx_int_output_polarity_t polarity)
{
    27c4:	b570      	push	{r4, r5, r6, lr}
    27c6:	b082      	sub	sp, #8
    27c8:	0005      	movs	r5, r0
    27ca:	0016      	movs	r6, r2
    uint8_t read_status;

    if(pHandle == NULL)
    27cc:	2800      	cmp	r0, #0
    27ce:	d100      	bne.n	27d2 <mcp794xx_set_alarm_interrupt_output_polarity+0xe>
    27d0:	e064      	b.n	289c <mcp794xx_set_alarm_interrupt_output_polarity+0xd8>
        return 2;     /**< return failed error */
    if(pHandle->inited != 1)
    27d2:	7fc4      	ldrb	r4, [r0, #31]
    27d4:	2c01      	cmp	r4, #1
    27d6:	d003      	beq.n	27e0 <mcp794xx_set_alarm_interrupt_output_polarity+0x1c>
        return 3;      /**< return failed error */
    27d8:	2403      	movs	r4, #3
        }

    }

    return 0;              /**< success */
}
    27da:	0020      	movs	r0, r4
    27dc:	b002      	add	sp, #8
    27de:	bd70      	pop	{r4, r5, r6, pc}
    switch((int)alarm)
    27e0:	2900      	cmp	r1, #0
    27e2:	d007      	beq.n	27f4 <mcp794xx_set_alarm_interrupt_output_polarity+0x30>
    27e4:	2901      	cmp	r1, #1
    27e6:	d02f      	beq.n	2848 <mcp794xx_set_alarm_interrupt_output_polarity+0x84>
            a_mcp794xx_print_error_msg(pHandle, "invalid alarm selected");
    27e8:	492d      	ldr	r1, [pc, #180]	; (28a0 <mcp794xx_set_alarm_interrupt_output_polarity+0xdc>)
    27ea:	4479      	add	r1, pc
    27ec:	f7ff fab2 	bl	1d54 <a_mcp794xx_print_error_msg>
            return 4;
    27f0:	2404      	movs	r4, #4
    27f2:	e7f2      	b.n	27da <mcp794xx_set_alarm_interrupt_output_polarity+0x16>
            err = rtc_mcp794xx_i2c_read(pHandle, MCP794XX_ALM0_WKDAY_REG, (uint8_t *)&read_status, 1);
    27f4:	2301      	movs	r3, #1
    27f6:	466a      	mov	r2, sp
    27f8:	3207      	adds	r2, #7
    27fa:	210d      	movs	r1, #13
    27fc:	f7ff fa33 	bl	1c66 <rtc_mcp794xx_i2c_read>
    2800:	4b28      	ldr	r3, [pc, #160]	; (28a4 <mcp794xx_set_alarm_interrupt_output_polarity+0xe0>)
    2802:	447b      	add	r3, pc
    2804:	7018      	strb	r0, [r3, #0]
            if(err)
    2806:	2800      	cmp	r0, #0
    2808:	d112      	bne.n	2830 <mcp794xx_set_alarm_interrupt_output_polarity+0x6c>
            read_status &= ~(1 << 7);                                   /**< clear polarity bit */
    280a:	466b      	mov	r3, sp
    280c:	1dda      	adds	r2, r3, #7
    280e:	7811      	ldrb	r1, [r2, #0]
    2810:	237f      	movs	r3, #127	; 0x7f
    2812:	400b      	ands	r3, r1
            read_status |= (polarity << 7);
    2814:	01f6      	lsls	r6, r6, #7
    2816:	431e      	orrs	r6, r3
    2818:	7016      	strb	r6, [r2, #0]
            err = rtc_mcp794xx_i2c_write(pHandle, MCP794XX_ALM0_WKDAY_REG, (uint8_t *)&read_status);
    281a:	210d      	movs	r1, #13
    281c:	0028      	movs	r0, r5
    281e:	f7ff fa09 	bl	1c34 <rtc_mcp794xx_i2c_write>
    2822:	4b21      	ldr	r3, [pc, #132]	; (28a8 <mcp794xx_set_alarm_interrupt_output_polarity+0xe4>)
    2824:	447b      	add	r3, pc
    2826:	7018      	strb	r0, [r3, #0]
            if(err)
    2828:	2800      	cmp	r0, #0
    282a:	d107      	bne.n	283c <mcp794xx_set_alarm_interrupt_output_polarity+0x78>
    return 0;              /**< success */
    282c:	0004      	movs	r4, r0
    282e:	e7d4      	b.n	27da <mcp794xx_set_alarm_interrupt_output_polarity+0x16>
                a_mcp794xx_print_error_msg(pHandle, "read alarm 0 polarity register");
    2830:	491e      	ldr	r1, [pc, #120]	; (28ac <mcp794xx_set_alarm_interrupt_output_polarity+0xe8>)
    2832:	4479      	add	r1, pc
    2834:	0028      	movs	r0, r5
    2836:	f7ff fa8d 	bl	1d54 <a_mcp794xx_print_error_msg>
                return 1;           /**< failed error */
    283a:	e7ce      	b.n	27da <mcp794xx_set_alarm_interrupt_output_polarity+0x16>
                a_mcp794xx_print_error_msg(pHandle, "read alarm 0 polarity register");
    283c:	491c      	ldr	r1, [pc, #112]	; (28b0 <mcp794xx_set_alarm_interrupt_output_polarity+0xec>)
    283e:	4479      	add	r1, pc
    2840:	0028      	movs	r0, r5
    2842:	f7ff fa87 	bl	1d54 <a_mcp794xx_print_error_msg>
                return 1;           /**< failed error */
    2846:	e7c8      	b.n	27da <mcp794xx_set_alarm_interrupt_output_polarity+0x16>
            err = rtc_mcp794xx_i2c_read(pHandle, MCP794XX_ALM1_WKDAY_REG, (uint8_t *)&read_status, 1);
    2848:	2301      	movs	r3, #1
    284a:	466a      	mov	r2, sp
    284c:	3207      	adds	r2, #7
    284e:	2114      	movs	r1, #20
    2850:	f7ff fa09 	bl	1c66 <rtc_mcp794xx_i2c_read>
    2854:	4b17      	ldr	r3, [pc, #92]	; (28b4 <mcp794xx_set_alarm_interrupt_output_polarity+0xf0>)
    2856:	447b      	add	r3, pc
    2858:	7018      	strb	r0, [r3, #0]
            if(err)
    285a:	2800      	cmp	r0, #0
    285c:	d112      	bne.n	2884 <mcp794xx_set_alarm_interrupt_output_polarity+0xc0>
            read_status &= ~(1 << 7);                                   /**< clear polarity bit */
    285e:	466b      	mov	r3, sp
    2860:	1dda      	adds	r2, r3, #7
    2862:	7811      	ldrb	r1, [r2, #0]
    2864:	237f      	movs	r3, #127	; 0x7f
    2866:	400b      	ands	r3, r1
            read_status |= (polarity << 7);
    2868:	01f6      	lsls	r6, r6, #7
    286a:	431e      	orrs	r6, r3
    286c:	7016      	strb	r6, [r2, #0]
            err = rtc_mcp794xx_i2c_write(pHandle, MCP794XX_ALM1_WKDAY_REG, (uint8_t *)&read_status);
    286e:	2114      	movs	r1, #20
    2870:	0028      	movs	r0, r5
    2872:	f7ff f9df 	bl	1c34 <rtc_mcp794xx_i2c_write>
    2876:	4b10      	ldr	r3, [pc, #64]	; (28b8 <mcp794xx_set_alarm_interrupt_output_polarity+0xf4>)
    2878:	447b      	add	r3, pc
    287a:	7018      	strb	r0, [r3, #0]
            if(err)
    287c:	2800      	cmp	r0, #0
    287e:	d107      	bne.n	2890 <mcp794xx_set_alarm_interrupt_output_polarity+0xcc>
    return 0;              /**< success */
    2880:	0004      	movs	r4, r0
    2882:	e7aa      	b.n	27da <mcp794xx_set_alarm_interrupt_output_polarity+0x16>
                a_mcp794xx_print_error_msg(pHandle, "read alarm 1 polarity register");
    2884:	490d      	ldr	r1, [pc, #52]	; (28bc <mcp794xx_set_alarm_interrupt_output_polarity+0xf8>)
    2886:	4479      	add	r1, pc
    2888:	0028      	movs	r0, r5
    288a:	f7ff fa63 	bl	1d54 <a_mcp794xx_print_error_msg>
                return 1;           /**< failed error */
    288e:	e7a4      	b.n	27da <mcp794xx_set_alarm_interrupt_output_polarity+0x16>
                a_mcp794xx_print_error_msg(pHandle, "read alarm 0 polarity register");
    2890:	490b      	ldr	r1, [pc, #44]	; (28c0 <mcp794xx_set_alarm_interrupt_output_polarity+0xfc>)
    2892:	4479      	add	r1, pc
    2894:	0028      	movs	r0, r5
    2896:	f7ff fa5d 	bl	1d54 <a_mcp794xx_print_error_msg>
                return 1;           /**< failed error */
    289a:	e79e      	b.n	27da <mcp794xx_set_alarm_interrupt_output_polarity+0x16>
        return 2;     /**< return failed error */
    289c:	2402      	movs	r4, #2
    289e:	e79c      	b.n	27da <mcp794xx_set_alarm_interrupt_output_polarity+0x16>
    28a0:	00004f0a 	.word	0x00004f0a
    28a4:	1fffdade 	.word	0x1fffdade
    28a8:	1fffdabc 	.word	0x1fffdabc
    28ac:	00004e82 	.word	0x00004e82
    28b0:	00004e76 	.word	0x00004e76
    28b4:	1fffda8a 	.word	0x1fffda8a
    28b8:	1fffda68 	.word	0x1fffda68
    28bc:	00004e4e 	.word	0x00004e4e
    28c0:	00004e22 	.word	0x00004e22

000028c4 <mcp794xx_set_alarm_time_date>:
            - 2 handle null
 *          - 3 handle is not initialized
 *          - 5 invalid mask
 */
uint8_t mcp794xx_set_alarm_time_date(mcp794xx_handle_t *const pHandle, mcp794xx_alarm_t alarm, mcp794xx_time_t *pTime)
{
    28c4:	b5f0      	push	{r4, r5, r6, r7, lr}
    28c6:	b085      	sub	sp, #20
    28c8:	0005      	movs	r5, r0
    28ca:	000f      	movs	r7, r1
    28cc:	0016      	movs	r6, r2

    uint8_t ptimeBuffer[MCP794XX_TIME_BUFFER_SIZE];
    uint8_t status;

    if(pHandle == NULL)
    28ce:	2800      	cmp	r0, #0
    28d0:	d100      	bne.n	28d4 <mcp794xx_set_alarm_time_date+0x10>
    28d2:	e25f      	b.n	2d94 <mcp794xx_set_alarm_time_date+0x4d0>
        return 2;     /**< return failed error */
    if(pHandle->inited != 1)
    28d4:	7fc4      	ldrb	r4, [r0, #31]
    28d6:	2c01      	cmp	r4, #1
    28d8:	d003      	beq.n	28e2 <mcp794xx_set_alarm_time_date+0x1e>
        return 3;      /**< return failed error */
    28da:	2403      	movs	r4, #3
    }


    return 0;     /**< success */

}
    28dc:	0020      	movs	r0, r4
    28de:	b005      	add	sp, #20
    28e0:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if(pHandle->time_param.time_Format == MCP794XX_24HR_FORMAT)
    28e2:	2370      	movs	r3, #112	; 0x70
    28e4:	5cc3      	ldrb	r3, [r0, r3]
    28e6:	2b00      	cmp	r3, #0
    28e8:	d14c      	bne.n	2984 <mcp794xx_set_alarm_time_date+0xc0>
        if((pTime->month < 1) || (pTime->month > 12))
    28ea:	7993      	ldrb	r3, [r2, #6]
    28ec:	3b01      	subs	r3, #1
    28ee:	b2db      	uxtb	r3, r3
    28f0:	2b0b      	cmp	r3, #11
    28f2:	d823      	bhi.n	293c <mcp794xx_set_alarm_time_date+0x78>
        if((pTime->date < 1) || (pTime->date > 31))
    28f4:	7893      	ldrb	r3, [r2, #2]
    28f6:	3b01      	subs	r3, #1
    28f8:	b2db      	uxtb	r3, r3
    28fa:	2b1e      	cmp	r3, #30
    28fc:	d824      	bhi.n	2948 <mcp794xx_set_alarm_time_date+0x84>
        if((pTime->weekDay < 1) || (pTime->weekDay > 7))
    28fe:	79d3      	ldrb	r3, [r2, #7]
    2900:	3b01      	subs	r3, #1
    2902:	b2db      	uxtb	r3, r3
    2904:	2b06      	cmp	r3, #6
    2906:	d825      	bhi.n	2954 <mcp794xx_set_alarm_time_date+0x90>
        if((pTime->hour < 0) || (pTime->hour > 23))
    2908:	78d3      	ldrb	r3, [r2, #3]
    290a:	2b17      	cmp	r3, #23
    290c:	d828      	bhi.n	2960 <mcp794xx_set_alarm_time_date+0x9c>
        if((pTime->minute < 0) || (pTime->minute > 59))
    290e:	7913      	ldrb	r3, [r2, #4]
    2910:	2b3b      	cmp	r3, #59	; 0x3b
    2912:	d82b      	bhi.n	296c <mcp794xx_set_alarm_time_date+0xa8>
        if((pTime->second < 0) || (pTime->second > 59))
    2914:	7953      	ldrb	r3, [r2, #5]
    2916:	2b3b      	cmp	r3, #59	; 0x3b
    2918:	d82e      	bhi.n	2978 <mcp794xx_set_alarm_time_date+0xb4>
    memset(ptimeBuffer, 0, sizeof(ptimeBuffer));              /**< clear buffer */
    291a:	2207      	movs	r2, #7
    291c:	2100      	movs	r1, #0
    291e:	a802      	add	r0, sp, #8
    2920:	f003 fc47 	bl	61b2 <memset>
    if(alarm == MCP794XX_ALARM0)
    2924:	2f00      	cmp	r7, #0
    2926:	d071      	beq.n	2a0c <mcp794xx_set_alarm_time_date+0x148>
    else if(alarm == MCP794XX_ALARM1)
    2928:	2f01      	cmp	r7, #1
    292a:	d100      	bne.n	292e <mcp794xx_set_alarm_time_date+0x6a>
    292c:	e132      	b.n	2b94 <mcp794xx_set_alarm_time_date+0x2d0>
        a_mcp794xx_print_error_msg(pHandle, "invalid alarm selected");
    292e:	49a7      	ldr	r1, [pc, #668]	; (2bcc <mcp794xx_set_alarm_time_date+0x308>)
    2930:	4479      	add	r1, pc
    2932:	0028      	movs	r0, r5
    2934:	f7ff fa0e 	bl	1d54 <a_mcp794xx_print_error_msg>
        return 4;
    2938:	2404      	movs	r4, #4
    293a:	e7cf      	b.n	28dc <mcp794xx_set_alarm_time_date+0x18>
            a_mcp794xx_print_error_msg(pHandle, "set alarm time, month can not be less than 0 or greater than 12");
    293c:	49a4      	ldr	r1, [pc, #656]	; (2bd0 <mcp794xx_set_alarm_time_date+0x30c>)
    293e:	4479      	add	r1, pc
    2940:	f7ff fa08 	bl	1d54 <a_mcp794xx_print_error_msg>
            return 4;
    2944:	3403      	adds	r4, #3
    2946:	e7c9      	b.n	28dc <mcp794xx_set_alarm_time_date+0x18>
            a_mcp794xx_print_error_msg(pHandle, "set alarm time, date can not be less than 0 or greater than 31");
    2948:	49a2      	ldr	r1, [pc, #648]	; (2bd4 <mcp794xx_set_alarm_time_date+0x310>)
    294a:	4479      	add	r1, pc
    294c:	f7ff fa02 	bl	1d54 <a_mcp794xx_print_error_msg>
            return 4;
    2950:	2404      	movs	r4, #4
    2952:	e7c3      	b.n	28dc <mcp794xx_set_alarm_time_date+0x18>
            a_mcp794xx_print_error_msg(pHandle, "set alarm time, week day can not be less than 1 or greater than 7");
    2954:	49a0      	ldr	r1, [pc, #640]	; (2bd8 <mcp794xx_set_alarm_time_date+0x314>)
    2956:	4479      	add	r1, pc
    2958:	f7ff f9fc 	bl	1d54 <a_mcp794xx_print_error_msg>
            return 4;
    295c:	2404      	movs	r4, #4
    295e:	e7bd      	b.n	28dc <mcp794xx_set_alarm_time_date+0x18>
            a_mcp794xx_print_error_msg(pHandle, "set alarm time, hour can not be less than 0 or greater than 23");
    2960:	499e      	ldr	r1, [pc, #632]	; (2bdc <mcp794xx_set_alarm_time_date+0x318>)
    2962:	4479      	add	r1, pc
    2964:	f7ff f9f6 	bl	1d54 <a_mcp794xx_print_error_msg>
            return 4;
    2968:	2404      	movs	r4, #4
    296a:	e7b7      	b.n	28dc <mcp794xx_set_alarm_time_date+0x18>
            a_mcp794xx_print_error_msg(pHandle, "set alarm time, minute can not be less than 0 or greater than 59");
    296c:	499c      	ldr	r1, [pc, #624]	; (2be0 <mcp794xx_set_alarm_time_date+0x31c>)
    296e:	4479      	add	r1, pc
    2970:	f7ff f9f0 	bl	1d54 <a_mcp794xx_print_error_msg>
            return 4;
    2974:	2404      	movs	r4, #4
    2976:	e7b1      	b.n	28dc <mcp794xx_set_alarm_time_date+0x18>
            a_mcp794xx_print_error_msg(pHandle, "set alarm time, seconds can not be less than 0 or greater than 59");
    2978:	499a      	ldr	r1, [pc, #616]	; (2be4 <mcp794xx_set_alarm_time_date+0x320>)
    297a:	4479      	add	r1, pc
    297c:	f7ff f9ea 	bl	1d54 <a_mcp794xx_print_error_msg>
            return 4;
    2980:	2404      	movs	r4, #4
    2982:	e7ab      	b.n	28dc <mcp794xx_set_alarm_time_date+0x18>
    else if(pHandle->time_param.time_Format == MCP794XX_12HR_FORMAT)
    2984:	2b01      	cmp	r3, #1
    2986:	d005      	beq.n	2994 <mcp794xx_set_alarm_time_date+0xd0>
        a_mcp794xx_print_error_msg(pHandle, "set alarm time, invalid time format");
    2988:	4997      	ldr	r1, [pc, #604]	; (2be8 <mcp794xx_set_alarm_time_date+0x324>)
    298a:	4479      	add	r1, pc
    298c:	f7ff f9e2 	bl	1d54 <a_mcp794xx_print_error_msg>
        return 4;
    2990:	2404      	movs	r4, #4
    2992:	e7a3      	b.n	28dc <mcp794xx_set_alarm_time_date+0x18>
        if((pTime->month < 0) || (pTime->month > 12))
    2994:	7993      	ldrb	r3, [r2, #6]
    2996:	2b0c      	cmp	r3, #12
    2998:	d81a      	bhi.n	29d0 <mcp794xx_set_alarm_time_date+0x10c>
        if((pTime->date < 1) || (pTime->date > 31))
    299a:	7893      	ldrb	r3, [r2, #2]
    299c:	3b01      	subs	r3, #1
    299e:	b2db      	uxtb	r3, r3
    29a0:	2b1e      	cmp	r3, #30
    29a2:	d81b      	bhi.n	29dc <mcp794xx_set_alarm_time_date+0x118>
        if((pTime->weekDay < 1) || (pTime->weekDay > 7))
    29a4:	79d3      	ldrb	r3, [r2, #7]
    29a6:	3b01      	subs	r3, #1
    29a8:	b2db      	uxtb	r3, r3
    29aa:	2b06      	cmp	r3, #6
    29ac:	d81c      	bhi.n	29e8 <mcp794xx_set_alarm_time_date+0x124>
        if((pTime->hour < 1) || (pTime->hour > 12))
    29ae:	78d3      	ldrb	r3, [r2, #3]
    29b0:	3b01      	subs	r3, #1
    29b2:	b2db      	uxtb	r3, r3
    29b4:	2b0b      	cmp	r3, #11
    29b6:	d81d      	bhi.n	29f4 <mcp794xx_set_alarm_time_date+0x130>
        if((pTime->minute < 0) || (pTime->minute > 59))
    29b8:	7913      	ldrb	r3, [r2, #4]
    29ba:	2b3b      	cmp	r3, #59	; 0x3b
    29bc:	d820      	bhi.n	2a00 <mcp794xx_set_alarm_time_date+0x13c>
        if((pTime->second < 0) || (pTime->second > 59))
    29be:	7953      	ldrb	r3, [r2, #5]
    29c0:	2b3b      	cmp	r3, #59	; 0x3b
    29c2:	d9aa      	bls.n	291a <mcp794xx_set_alarm_time_date+0x56>
            a_mcp794xx_print_error_msg(pHandle, "set alarm time, seconds can not be less than 0 or greater than 59");
    29c4:	4989      	ldr	r1, [pc, #548]	; (2bec <mcp794xx_set_alarm_time_date+0x328>)
    29c6:	4479      	add	r1, pc
    29c8:	f7ff f9c4 	bl	1d54 <a_mcp794xx_print_error_msg>
            return 4;
    29cc:	2404      	movs	r4, #4
    29ce:	e785      	b.n	28dc <mcp794xx_set_alarm_time_date+0x18>
            a_mcp794xx_print_error_msg(pHandle, "set alarm time, month can not be less than 0 or greater than 12");
    29d0:	4987      	ldr	r1, [pc, #540]	; (2bf0 <mcp794xx_set_alarm_time_date+0x32c>)
    29d2:	4479      	add	r1, pc
    29d4:	f7ff f9be 	bl	1d54 <a_mcp794xx_print_error_msg>
            return 4;
    29d8:	2404      	movs	r4, #4
    29da:	e77f      	b.n	28dc <mcp794xx_set_alarm_time_date+0x18>
            a_mcp794xx_print_error_msg(pHandle, "set alarm time, date can not be less than 0 or greater than 31");
    29dc:	4985      	ldr	r1, [pc, #532]	; (2bf4 <mcp794xx_set_alarm_time_date+0x330>)
    29de:	4479      	add	r1, pc
    29e0:	f7ff f9b8 	bl	1d54 <a_mcp794xx_print_error_msg>
            return 4;
    29e4:	2404      	movs	r4, #4
    29e6:	e779      	b.n	28dc <mcp794xx_set_alarm_time_date+0x18>
            a_mcp794xx_print_error_msg(pHandle, "set alarm time, week day can not be less than 1 or greater than 7");
    29e8:	4983      	ldr	r1, [pc, #524]	; (2bf8 <mcp794xx_set_alarm_time_date+0x334>)
    29ea:	4479      	add	r1, pc
    29ec:	f7ff f9b2 	bl	1d54 <a_mcp794xx_print_error_msg>
            return 4;
    29f0:	2404      	movs	r4, #4
    29f2:	e773      	b.n	28dc <mcp794xx_set_alarm_time_date+0x18>
            a_mcp794xx_print_error_msg(pHandle, "set alarm time, hour can not be less than 0 or greater than 12");
    29f4:	4981      	ldr	r1, [pc, #516]	; (2bfc <mcp794xx_set_alarm_time_date+0x338>)
    29f6:	4479      	add	r1, pc
    29f8:	f7ff f9ac 	bl	1d54 <a_mcp794xx_print_error_msg>
            return 4;
    29fc:	2404      	movs	r4, #4
    29fe:	e76d      	b.n	28dc <mcp794xx_set_alarm_time_date+0x18>
            a_mcp794xx_print_error_msg(pHandle, "set alarm time, minute can not be less than 0 or greater than 59");
    2a00:	497f      	ldr	r1, [pc, #508]	; (2c00 <mcp794xx_set_alarm_time_date+0x33c>)
    2a02:	4479      	add	r1, pc
    2a04:	f7ff f9a6 	bl	1d54 <a_mcp794xx_print_error_msg>
            return 4;
    2a08:	2404      	movs	r4, #4
    2a0a:	e767      	b.n	28dc <mcp794xx_set_alarm_time_date+0x18>
        err = rtc_mcp794xx_i2c_read(pHandle, MCP794XX_ALM0_SEC_REG, (uint8_t *)ptimeBuffer, (MCP794XX_TIME_BUFFER_SIZE - 1) );
    2a0c:	2306      	movs	r3, #6
    2a0e:	aa02      	add	r2, sp, #8
    2a10:	210a      	movs	r1, #10
    2a12:	0028      	movs	r0, r5
    2a14:	f7ff f927 	bl	1c66 <rtc_mcp794xx_i2c_read>
    2a18:	4f7a      	ldr	r7, [pc, #488]	; (2c04 <mcp794xx_set_alarm_time_date+0x340>)
    2a1a:	447f      	add	r7, pc
    2a1c:	7038      	strb	r0, [r7, #0]
        status =  a_pcf85xxx_dec2bcd(pTime->second);
    2a1e:	7970      	ldrb	r0, [r6, #5]
    2a20:	f7ff f9a0 	bl	1d64 <a_pcf85xxx_dec2bcd>
    2a24:	466b      	mov	r3, sp
    2a26:	1dda      	adds	r2, r3, #7
    2a28:	7010      	strb	r0, [r2, #0]
        err =  rtc_mcp794xx_i2c_write(pHandle, MCP794XX_ALM0_SEC_REG,(uint8_t *)&status);
    2a2a:	210a      	movs	r1, #10
    2a2c:	0028      	movs	r0, r5
    2a2e:	f7ff f901 	bl	1c34 <rtc_mcp794xx_i2c_write>
    2a32:	7038      	strb	r0, [r7, #0]
        if(err)
    2a34:	2800      	cmp	r0, #0
    2a36:	d13f      	bne.n	2ab8 <mcp794xx_set_alarm_time_date+0x1f4>
        status = a_pcf85xxx_dec2bcd(pTime->minute);
    2a38:	7930      	ldrb	r0, [r6, #4]
    2a3a:	f7ff f993 	bl	1d64 <a_pcf85xxx_dec2bcd>
    2a3e:	466b      	mov	r3, sp
    2a40:	1dda      	adds	r2, r3, #7
    2a42:	7010      	strb	r0, [r2, #0]
        err = rtc_mcp794xx_i2c_write(pHandle, MCP794XX_ALM0_MIN_REG, (uint8_t *)&status);
    2a44:	210b      	movs	r1, #11
    2a46:	0028      	movs	r0, r5
    2a48:	f7ff f8f4 	bl	1c34 <rtc_mcp794xx_i2c_write>
    2a4c:	4b6e      	ldr	r3, [pc, #440]	; (2c08 <mcp794xx_set_alarm_time_date+0x344>)
    2a4e:	447b      	add	r3, pc
    2a50:	7018      	strb	r0, [r3, #0]
        if(err)
    2a52:	2800      	cmp	r0, #0
    2a54:	d136      	bne.n	2ac4 <mcp794xx_set_alarm_time_date+0x200>
        if(pHandle->time_param.time_Format == MCP794XX_24HR_FORMAT)
    2a56:	2370      	movs	r3, #112	; 0x70
    2a58:	5ceb      	ldrb	r3, [r5, r3]
    2a5a:	2b00      	cmp	r3, #0
    2a5c:	d038      	beq.n	2ad0 <mcp794xx_set_alarm_time_date+0x20c>
        else if(pHandle->time_param.time_Format == MCP794XX_12HR_FORMAT)
    2a5e:	2b01      	cmp	r3, #1
    2a60:	d052      	beq.n	2b08 <mcp794xx_set_alarm_time_date+0x244>
        status = a_pcf85xxx_dec2bcd(pTime->weekDay) | (ptimeBuffer[3] & (MCP794XX_ALARMx_INT_POL_MASK | MCP794XX_ALARMx_TYPE_MASK | MCP794XX_ALARMx_IF_MASK));
    2a62:	79f0      	ldrb	r0, [r6, #7]
    2a64:	f7ff f97e 	bl	1d64 <a_pcf85xxx_dec2bcd>
    2a68:	b240      	sxtb	r0, r0
    2a6a:	ab02      	add	r3, sp, #8
    2a6c:	78db      	ldrb	r3, [r3, #3]
    2a6e:	b25b      	sxtb	r3, r3
    2a70:	2207      	movs	r2, #7
    2a72:	4393      	bics	r3, r2
    2a74:	4318      	orrs	r0, r3
    2a76:	466b      	mov	r3, sp
    2a78:	189a      	adds	r2, r3, r2
    2a7a:	7010      	strb	r0, [r2, #0]
        err = rtc_mcp794xx_i2c_write(pHandle, MCP794XX_ALM0_WKDAY_REG, (uint8_t *)&status);
    2a7c:	210d      	movs	r1, #13
    2a7e:	0028      	movs	r0, r5
    2a80:	f7ff f8d8 	bl	1c34 <rtc_mcp794xx_i2c_write>
    2a84:	4b61      	ldr	r3, [pc, #388]	; (2c0c <mcp794xx_set_alarm_time_date+0x348>)
    2a86:	447b      	add	r3, pc
    2a88:	7018      	strb	r0, [r3, #0]
        if(err)
    2a8a:	2800      	cmp	r0, #0
    2a8c:	d165      	bne.n	2b5a <mcp794xx_set_alarm_time_date+0x296>
        status = a_pcf85xxx_dec2bcd(pTime->date);
    2a8e:	78b0      	ldrb	r0, [r6, #2]
    2a90:	f7ff f968 	bl	1d64 <a_pcf85xxx_dec2bcd>
    2a94:	466b      	mov	r3, sp
    2a96:	1dda      	adds	r2, r3, #7
    2a98:	7010      	strb	r0, [r2, #0]
        err = rtc_mcp794xx_i2c_write(pHandle, MCP794XX_ALM0_DATE_REG, (uint8_t *)&status);
    2a9a:	210e      	movs	r1, #14
    2a9c:	0028      	movs	r0, r5
    2a9e:	f7ff f8c9 	bl	1c34 <rtc_mcp794xx_i2c_write>
    2aa2:	4b5b      	ldr	r3, [pc, #364]	; (2c10 <mcp794xx_set_alarm_time_date+0x34c>)
    2aa4:	447b      	add	r3, pc
    2aa6:	7018      	strb	r0, [r3, #0]
        if(err)
    2aa8:	2800      	cmp	r0, #0
    2aaa:	d05c      	beq.n	2b66 <mcp794xx_set_alarm_time_date+0x2a2>
            a_mcp794xx_print_error_msg(pHandle, "to write alarm 0 date");
    2aac:	4959      	ldr	r1, [pc, #356]	; (2c14 <mcp794xx_set_alarm_time_date+0x350>)
    2aae:	4479      	add	r1, pc
    2ab0:	0028      	movs	r0, r5
    2ab2:	f7ff f94f 	bl	1d54 <a_mcp794xx_print_error_msg>
            return 1;
    2ab6:	e711      	b.n	28dc <mcp794xx_set_alarm_time_date+0x18>
            a_mcp794xx_print_error_msg(pHandle, "to write alarm 0 seconds");
    2ab8:	4957      	ldr	r1, [pc, #348]	; (2c18 <mcp794xx_set_alarm_time_date+0x354>)
    2aba:	4479      	add	r1, pc
    2abc:	0028      	movs	r0, r5
    2abe:	f7ff f949 	bl	1d54 <a_mcp794xx_print_error_msg>
            return 1;
    2ac2:	e70b      	b.n	28dc <mcp794xx_set_alarm_time_date+0x18>
            a_mcp794xx_print_error_msg(pHandle, "to write alarm 0 minutes");
    2ac4:	4955      	ldr	r1, [pc, #340]	; (2c1c <mcp794xx_set_alarm_time_date+0x358>)
    2ac6:	4479      	add	r1, pc
    2ac8:	0028      	movs	r0, r5
    2aca:	f7ff f943 	bl	1d54 <a_mcp794xx_print_error_msg>
            return 1;
    2ace:	e705      	b.n	28dc <mcp794xx_set_alarm_time_date+0x18>
            status = a_pcf85xxx_dec2bcd(pTime->hour) | (ptimeBuffer[2] & MCP794XX_ALARMx_12HR_24HR_FRMT_STAT_MASK);
    2ad0:	78f0      	ldrb	r0, [r6, #3]
    2ad2:	f7ff f947 	bl	1d64 <a_pcf85xxx_dec2bcd>
    2ad6:	b240      	sxtb	r0, r0
    2ad8:	ab02      	add	r3, sp, #8
    2ada:	789b      	ldrb	r3, [r3, #2]
    2adc:	b25b      	sxtb	r3, r3
    2ade:	2240      	movs	r2, #64	; 0x40
    2ae0:	4013      	ands	r3, r2
    2ae2:	4318      	orrs	r0, r3
    2ae4:	466b      	mov	r3, sp
    2ae6:	1dda      	adds	r2, r3, #7
    2ae8:	7010      	strb	r0, [r2, #0]
            err = rtc_mcp794xx_i2c_write(pHandle, MCP794XX_ALM0_HOUR_REG,(uint8_t *)&status);
    2aea:	210c      	movs	r1, #12
    2aec:	0028      	movs	r0, r5
    2aee:	f7ff f8a1 	bl	1c34 <rtc_mcp794xx_i2c_write>
    2af2:	4b4b      	ldr	r3, [pc, #300]	; (2c20 <mcp794xx_set_alarm_time_date+0x35c>)
    2af4:	447b      	add	r3, pc
    2af6:	7018      	strb	r0, [r3, #0]
            if(err)
    2af8:	2800      	cmp	r0, #0
    2afa:	d0b2      	beq.n	2a62 <mcp794xx_set_alarm_time_date+0x19e>
                a_mcp794xx_print_error_msg(pHandle, "to write alarm 0 hours");
    2afc:	4949      	ldr	r1, [pc, #292]	; (2c24 <mcp794xx_set_alarm_time_date+0x360>)
    2afe:	4479      	add	r1, pc
    2b00:	0028      	movs	r0, r5
    2b02:	f7ff f927 	bl	1d54 <a_mcp794xx_print_error_msg>
                return 1;
    2b06:	e6e9      	b.n	28dc <mcp794xx_set_alarm_time_date+0x18>
        	status = a_pcf85xxx_dec2bcd(pTime->hour) | (ptimeBuffer[2] & (MCP794XX_ALARMx_12HR_24HR_FRMT_STAT_MASK | MCP794XX_ALARMx_AM_PM_MASK));
    2b08:	78f0      	ldrb	r0, [r6, #3]
    2b0a:	f7ff f92b 	bl	1d64 <a_pcf85xxx_dec2bcd>
    2b0e:	b240      	sxtb	r0, r0
    2b10:	ab02      	add	r3, sp, #8
    2b12:	789b      	ldrb	r3, [r3, #2]
    2b14:	b25b      	sxtb	r3, r3
    2b16:	2260      	movs	r2, #96	; 0x60
    2b18:	4013      	ands	r3, r2
    2b1a:	4318      	orrs	r0, r3
    2b1c:	466b      	mov	r3, sp
    2b1e:	1dda      	adds	r2, r3, #7
    2b20:	7010      	strb	r0, [r2, #0]
            err = rtc_mcp794xx_i2c_write(pHandle, MCP794XX_ALM0_HOUR_REG, (uint8_t *)&status);
    2b22:	210c      	movs	r1, #12
    2b24:	0028      	movs	r0, r5
    2b26:	f7ff f885 	bl	1c34 <rtc_mcp794xx_i2c_write>
    2b2a:	4b3f      	ldr	r3, [pc, #252]	; (2c28 <mcp794xx_set_alarm_time_date+0x364>)
    2b2c:	447b      	add	r3, pc
    2b2e:	7018      	strb	r0, [r3, #0]
            if(err)
    2b30:	2800      	cmp	r0, #0
    2b32:	d005      	beq.n	2b40 <mcp794xx_set_alarm_time_date+0x27c>
                a_mcp794xx_print_error_msg(pHandle, "to write alarm 0 hours");
    2b34:	493d      	ldr	r1, [pc, #244]	; (2c2c <mcp794xx_set_alarm_time_date+0x368>)
    2b36:	4479      	add	r1, pc
    2b38:	0028      	movs	r0, r5
    2b3a:	f7ff f90b 	bl	1d54 <a_mcp794xx_print_error_msg>
                return 1;
    2b3e:	e6cd      	b.n	28dc <mcp794xx_set_alarm_time_date+0x18>
            err = mcp794xx_set_am_pm(pHandle, MCP794XX_ALM0_HOUR_REG, pTime->am_pm_indicator);
    2b40:	7a72      	ldrb	r2, [r6, #9]
    2b42:	210c      	movs	r1, #12
    2b44:	0028      	movs	r0, r5
    2b46:	f7ff faad 	bl	20a4 <mcp794xx_set_am_pm>
    2b4a:	4b39      	ldr	r3, [pc, #228]	; (2c30 <mcp794xx_set_alarm_time_date+0x36c>)
    2b4c:	447b      	add	r3, pc
    2b4e:	7018      	strb	r0, [r3, #0]
            if(err)
    2b50:	2800      	cmp	r0, #0
    2b52:	d100      	bne.n	2b56 <mcp794xx_set_alarm_time_date+0x292>
    2b54:	e785      	b.n	2a62 <mcp794xx_set_alarm_time_date+0x19e>
                return err;
    2b56:	0004      	movs	r4, r0
    2b58:	e6c0      	b.n	28dc <mcp794xx_set_alarm_time_date+0x18>
            a_mcp794xx_print_error_msg(pHandle, "to write alarm 0 week day");
    2b5a:	4936      	ldr	r1, [pc, #216]	; (2c34 <mcp794xx_set_alarm_time_date+0x370>)
    2b5c:	4479      	add	r1, pc
    2b5e:	0028      	movs	r0, r5
    2b60:	f7ff f8f8 	bl	1d54 <a_mcp794xx_print_error_msg>
            return 1;
    2b64:	e6ba      	b.n	28dc <mcp794xx_set_alarm_time_date+0x18>
        status =  a_pcf85xxx_dec2bcd(pTime->month);
    2b66:	79b0      	ldrb	r0, [r6, #6]
    2b68:	f7ff f8fc 	bl	1d64 <a_pcf85xxx_dec2bcd>
    2b6c:	466b      	mov	r3, sp
    2b6e:	1dda      	adds	r2, r3, #7
    2b70:	7010      	strb	r0, [r2, #0]
        err = rtc_mcp794xx_i2c_write(pHandle, MCP794XX_ALM0_MONTH_REG, (uint8_t *)&status);
    2b72:	210f      	movs	r1, #15
    2b74:	0028      	movs	r0, r5
    2b76:	f7ff f85d 	bl	1c34 <rtc_mcp794xx_i2c_write>
    2b7a:	4b2f      	ldr	r3, [pc, #188]	; (2c38 <mcp794xx_set_alarm_time_date+0x374>)
    2b7c:	447b      	add	r3, pc
    2b7e:	7018      	strb	r0, [r3, #0]
        if(err)
    2b80:	2800      	cmp	r0, #0
    2b82:	d101      	bne.n	2b88 <mcp794xx_set_alarm_time_date+0x2c4>
    return 0;     /**< success */
    2b84:	0004      	movs	r4, r0
    2b86:	e6a9      	b.n	28dc <mcp794xx_set_alarm_time_date+0x18>
            a_mcp794xx_print_error_msg(pHandle, "to write alarm 0 month");
    2b88:	492c      	ldr	r1, [pc, #176]	; (2c3c <mcp794xx_set_alarm_time_date+0x378>)
    2b8a:	4479      	add	r1, pc
    2b8c:	0028      	movs	r0, r5
    2b8e:	f7ff f8e1 	bl	1d54 <a_mcp794xx_print_error_msg>
            return 1;
    2b92:	e6a3      	b.n	28dc <mcp794xx_set_alarm_time_date+0x18>
        err = rtc_mcp794xx_i2c_read(pHandle, MCP794XX_ALM1_SEC_REG, (uint8_t *)ptimeBuffer, (MCP794XX_TIME_BUFFER_SIZE - 1) );
    2b94:	2306      	movs	r3, #6
    2b96:	aa02      	add	r2, sp, #8
    2b98:	2111      	movs	r1, #17
    2b9a:	0028      	movs	r0, r5
    2b9c:	f7ff f863 	bl	1c66 <rtc_mcp794xx_i2c_read>
    2ba0:	4f27      	ldr	r7, [pc, #156]	; (2c40 <mcp794xx_set_alarm_time_date+0x37c>)
    2ba2:	447f      	add	r7, pc
    2ba4:	7038      	strb	r0, [r7, #0]
        status =  a_pcf85xxx_dec2bcd(pTime->second);
    2ba6:	7970      	ldrb	r0, [r6, #5]
    2ba8:	f7ff f8dc 	bl	1d64 <a_pcf85xxx_dec2bcd>
    2bac:	466b      	mov	r3, sp
    2bae:	1dda      	adds	r2, r3, #7
    2bb0:	7010      	strb	r0, [r2, #0]
		err =  rtc_mcp794xx_i2c_write(pHandle, MCP794XX_ALM1_SEC_REG,(uint8_t *)&status);
    2bb2:	2111      	movs	r1, #17
    2bb4:	0028      	movs	r0, r5
    2bb6:	f7ff f83d 	bl	1c34 <rtc_mcp794xx_i2c_write>
    2bba:	7038      	strb	r0, [r7, #0]
		if(err)
    2bbc:	2800      	cmp	r0, #0
    2bbe:	d043      	beq.n	2c48 <mcp794xx_set_alarm_time_date+0x384>
			a_mcp794xx_print_error_msg(pHandle, "to write alarm 1 seconds");
    2bc0:	4920      	ldr	r1, [pc, #128]	; (2c44 <mcp794xx_set_alarm_time_date+0x380>)
    2bc2:	4479      	add	r1, pc
    2bc4:	0028      	movs	r0, r5
    2bc6:	f7ff f8c5 	bl	1d54 <a_mcp794xx_print_error_msg>
			return 1;
    2bca:	e687      	b.n	28dc <mcp794xx_set_alarm_time_date+0x18>
    2bcc:	00004dc4 	.word	0x00004dc4
    2bd0:	00004dce 	.word	0x00004dce
    2bd4:	00004e02 	.word	0x00004e02
    2bd8:	00004e36 	.word	0x00004e36
    2bdc:	00004e6e 	.word	0x00004e6e
    2be0:	00004ea2 	.word	0x00004ea2
    2be4:	00004eda 	.word	0x00004eda
    2be8:	00004f4e 	.word	0x00004f4e
    2bec:	00004e8e 	.word	0x00004e8e
    2bf0:	00004d3a 	.word	0x00004d3a
    2bf4:	00004d6e 	.word	0x00004d6e
    2bf8:	00004da2 	.word	0x00004da2
    2bfc:	00004ea2 	.word	0x00004ea2
    2c00:	00004e0e 	.word	0x00004e0e
    2c04:	1fffd8c6 	.word	0x1fffd8c6
    2c08:	1fffd892 	.word	0x1fffd892
    2c0c:	1fffd85a 	.word	0x1fffd85a
    2c10:	1fffd83c 	.word	0x1fffd83c
    2c14:	00004eba 	.word	0x00004eba
    2c18:	00004e42 	.word	0x00004e42
    2c1c:	00004e52 	.word	0x00004e52
    2c20:	1fffd7ec 	.word	0x1fffd7ec
    2c24:	00004e36 	.word	0x00004e36
    2c28:	1fffd7b4 	.word	0x1fffd7b4
    2c2c:	00004dfe 	.word	0x00004dfe
    2c30:	1fffd794 	.word	0x1fffd794
    2c34:	00004df0 	.word	0x00004df0
    2c38:	1fffd764 	.word	0x1fffd764
    2c3c:	00004df6 	.word	0x00004df6
    2c40:	1fffd73e 	.word	0x1fffd73e
    2c44:	00004dd6 	.word	0x00004dd6
		status = a_pcf85xxx_dec2bcd(pTime->minute);
    2c48:	7930      	ldrb	r0, [r6, #4]
    2c4a:	f7ff f88b 	bl	1d64 <a_pcf85xxx_dec2bcd>
    2c4e:	466b      	mov	r3, sp
    2c50:	1dda      	adds	r2, r3, #7
    2c52:	7010      	strb	r0, [r2, #0]
		err = rtc_mcp794xx_i2c_write(pHandle, MCP794XX_ALM1_MIN_REG, (uint8_t *)&status);
    2c54:	2112      	movs	r1, #18
    2c56:	0028      	movs	r0, r5
    2c58:	f7fe ffec 	bl	1c34 <rtc_mcp794xx_i2c_write>
    2c5c:	4b4f      	ldr	r3, [pc, #316]	; (2d9c <mcp794xx_set_alarm_time_date+0x4d8>)
    2c5e:	447b      	add	r3, pc
    2c60:	7018      	strb	r0, [r3, #0]
		if(err)
    2c62:	2800      	cmp	r0, #0
    2c64:	d13f      	bne.n	2ce6 <mcp794xx_set_alarm_time_date+0x422>
		if(pHandle->time_param.time_Format == MCP794XX_24HR_FORMAT)
    2c66:	2370      	movs	r3, #112	; 0x70
    2c68:	5ceb      	ldrb	r3, [r5, r3]
    2c6a:	2b00      	cmp	r3, #0
    2c6c:	d041      	beq.n	2cf2 <mcp794xx_set_alarm_time_date+0x42e>
		else if(pHandle->time_param.time_Format == MCP794XX_12HR_FORMAT)
    2c6e:	2b01      	cmp	r3, #1
    2c70:	d05b      	beq.n	2d2a <mcp794xx_set_alarm_time_date+0x466>
		status = a_pcf85xxx_dec2bcd(pTime->weekDay) | (ptimeBuffer[3] & (MCP794XX_ALARMx_INT_POL_MASK | MCP794XX_ALARMx_TYPE_MASK | MCP794XX_ALARMx_IF_MASK));
    2c72:	79f0      	ldrb	r0, [r6, #7]
    2c74:	f7ff f876 	bl	1d64 <a_pcf85xxx_dec2bcd>
    2c78:	b240      	sxtb	r0, r0
    2c7a:	ab02      	add	r3, sp, #8
    2c7c:	78db      	ldrb	r3, [r3, #3]
    2c7e:	b25b      	sxtb	r3, r3
    2c80:	2207      	movs	r2, #7
    2c82:	4393      	bics	r3, r2
    2c84:	4318      	orrs	r0, r3
    2c86:	466b      	mov	r3, sp
    2c88:	189a      	adds	r2, r3, r2
    2c8a:	7010      	strb	r0, [r2, #0]
		err = rtc_mcp794xx_i2c_write(pHandle, MCP794XX_ALM1_WKDAY_REG, (uint8_t *)&status);
    2c8c:	2114      	movs	r1, #20
    2c8e:	0028      	movs	r0, r5
    2c90:	f7fe ffd0 	bl	1c34 <rtc_mcp794xx_i2c_write>
    2c94:	4b42      	ldr	r3, [pc, #264]	; (2da0 <mcp794xx_set_alarm_time_date+0x4dc>)
    2c96:	447b      	add	r3, pc
    2c98:	7018      	strb	r0, [r3, #0]
		if(err)
    2c9a:	2800      	cmp	r0, #0
    2c9c:	d16e      	bne.n	2d7c <mcp794xx_set_alarm_time_date+0x4b8>
		status = a_pcf85xxx_dec2bcd(pTime->date);
    2c9e:	78b0      	ldrb	r0, [r6, #2]
    2ca0:	f7ff f860 	bl	1d64 <a_pcf85xxx_dec2bcd>
    2ca4:	466b      	mov	r3, sp
    2ca6:	1dda      	adds	r2, r3, #7
    2ca8:	7010      	strb	r0, [r2, #0]
		err = rtc_mcp794xx_i2c_write(pHandle, MCP794XX_ALM1_DATE_REG, (uint8_t *)&status);
    2caa:	2115      	movs	r1, #21
    2cac:	0028      	movs	r0, r5
    2cae:	f7fe ffc1 	bl	1c34 <rtc_mcp794xx_i2c_write>
    2cb2:	4b3c      	ldr	r3, [pc, #240]	; (2da4 <mcp794xx_set_alarm_time_date+0x4e0>)
    2cb4:	447b      	add	r3, pc
    2cb6:	7018      	strb	r0, [r3, #0]
		if(err)
    2cb8:	2800      	cmp	r0, #0
    2cba:	d165      	bne.n	2d88 <mcp794xx_set_alarm_time_date+0x4c4>
		status =  a_pcf85xxx_dec2bcd(pTime->month);
    2cbc:	79b0      	ldrb	r0, [r6, #6]
    2cbe:	f7ff f851 	bl	1d64 <a_pcf85xxx_dec2bcd>
    2cc2:	466b      	mov	r3, sp
    2cc4:	1dda      	adds	r2, r3, #7
    2cc6:	7010      	strb	r0, [r2, #0]
		err = rtc_mcp794xx_i2c_write(pHandle, MCP794XX_ALM1_MONTH_REG, (uint8_t *)&status);
    2cc8:	2116      	movs	r1, #22
    2cca:	0028      	movs	r0, r5
    2ccc:	f7fe ffb2 	bl	1c34 <rtc_mcp794xx_i2c_write>
    2cd0:	4b35      	ldr	r3, [pc, #212]	; (2da8 <mcp794xx_set_alarm_time_date+0x4e4>)
    2cd2:	447b      	add	r3, pc
    2cd4:	7018      	strb	r0, [r3, #0]
		if(err)
    2cd6:	2800      	cmp	r0, #0
    2cd8:	d05e      	beq.n	2d98 <mcp794xx_set_alarm_time_date+0x4d4>
			a_mcp794xx_print_error_msg(pHandle, "to write alarm 1 month");
    2cda:	4934      	ldr	r1, [pc, #208]	; (2dac <mcp794xx_set_alarm_time_date+0x4e8>)
    2cdc:	4479      	add	r1, pc
    2cde:	0028      	movs	r0, r5
    2ce0:	f7ff f838 	bl	1d54 <a_mcp794xx_print_error_msg>
			return 1;
    2ce4:	e5fa      	b.n	28dc <mcp794xx_set_alarm_time_date+0x18>
			a_mcp794xx_print_error_msg(pHandle, "to write alarm 1 minutes");
    2ce6:	4932      	ldr	r1, [pc, #200]	; (2db0 <mcp794xx_set_alarm_time_date+0x4ec>)
    2ce8:	4479      	add	r1, pc
    2cea:	0028      	movs	r0, r5
    2cec:	f7ff f832 	bl	1d54 <a_mcp794xx_print_error_msg>
			return 1;
    2cf0:	e5f4      	b.n	28dc <mcp794xx_set_alarm_time_date+0x18>
			status = a_pcf85xxx_dec2bcd(pTime->hour) | (ptimeBuffer[2] & MCP794XX_ALARMx_12HR_24HR_FRMT_STAT_MASK);
    2cf2:	78f0      	ldrb	r0, [r6, #3]
    2cf4:	f7ff f836 	bl	1d64 <a_pcf85xxx_dec2bcd>
    2cf8:	b240      	sxtb	r0, r0
    2cfa:	ab02      	add	r3, sp, #8
    2cfc:	789b      	ldrb	r3, [r3, #2]
    2cfe:	b25b      	sxtb	r3, r3
    2d00:	2240      	movs	r2, #64	; 0x40
    2d02:	4013      	ands	r3, r2
    2d04:	4318      	orrs	r0, r3
    2d06:	466b      	mov	r3, sp
    2d08:	1dda      	adds	r2, r3, #7
    2d0a:	7010      	strb	r0, [r2, #0]
			err = rtc_mcp794xx_i2c_write(pHandle, MCP794XX_ALM1_HOUR_REG,(uint8_t *)&status);
    2d0c:	2113      	movs	r1, #19
    2d0e:	0028      	movs	r0, r5
    2d10:	f7fe ff90 	bl	1c34 <rtc_mcp794xx_i2c_write>
    2d14:	4b27      	ldr	r3, [pc, #156]	; (2db4 <mcp794xx_set_alarm_time_date+0x4f0>)
    2d16:	447b      	add	r3, pc
    2d18:	7018      	strb	r0, [r3, #0]
			if(err)
    2d1a:	2800      	cmp	r0, #0
    2d1c:	d0a9      	beq.n	2c72 <mcp794xx_set_alarm_time_date+0x3ae>
				a_mcp794xx_print_error_msg(pHandle, "to write alarm 1 hours");
    2d1e:	4926      	ldr	r1, [pc, #152]	; (2db8 <mcp794xx_set_alarm_time_date+0x4f4>)
    2d20:	4479      	add	r1, pc
    2d22:	0028      	movs	r0, r5
    2d24:	f7ff f816 	bl	1d54 <a_mcp794xx_print_error_msg>
				return 1;
    2d28:	e5d8      	b.n	28dc <mcp794xx_set_alarm_time_date+0x18>
			status = a_pcf85xxx_dec2bcd(pTime->hour) | (ptimeBuffer[2] & (MCP794XX_ALARMx_12HR_24HR_FRMT_STAT_MASK | MCP794XX_ALARMx_AM_PM_MASK));
    2d2a:	78f0      	ldrb	r0, [r6, #3]
    2d2c:	f7ff f81a 	bl	1d64 <a_pcf85xxx_dec2bcd>
    2d30:	b240      	sxtb	r0, r0
    2d32:	ab02      	add	r3, sp, #8
    2d34:	789b      	ldrb	r3, [r3, #2]
    2d36:	b25b      	sxtb	r3, r3
    2d38:	2260      	movs	r2, #96	; 0x60
    2d3a:	4013      	ands	r3, r2
    2d3c:	4318      	orrs	r0, r3
    2d3e:	466b      	mov	r3, sp
    2d40:	1dda      	adds	r2, r3, #7
    2d42:	7010      	strb	r0, [r2, #0]
			err = rtc_mcp794xx_i2c_write(pHandle, MCP794XX_ALM1_HOUR_REG, (uint8_t *)&status);
    2d44:	2113      	movs	r1, #19
    2d46:	0028      	movs	r0, r5
    2d48:	f7fe ff74 	bl	1c34 <rtc_mcp794xx_i2c_write>
    2d4c:	4b1b      	ldr	r3, [pc, #108]	; (2dbc <mcp794xx_set_alarm_time_date+0x4f8>)
    2d4e:	447b      	add	r3, pc
    2d50:	7018      	strb	r0, [r3, #0]
			if(err)
    2d52:	2800      	cmp	r0, #0
    2d54:	d005      	beq.n	2d62 <mcp794xx_set_alarm_time_date+0x49e>
				a_mcp794xx_print_error_msg(pHandle, "to write alarm 1 hours");
    2d56:	491a      	ldr	r1, [pc, #104]	; (2dc0 <mcp794xx_set_alarm_time_date+0x4fc>)
    2d58:	4479      	add	r1, pc
    2d5a:	0028      	movs	r0, r5
    2d5c:	f7fe fffa 	bl	1d54 <a_mcp794xx_print_error_msg>
				return 1;
    2d60:	e5bc      	b.n	28dc <mcp794xx_set_alarm_time_date+0x18>
			err = mcp794xx_set_am_pm(pHandle, MCP794XX_ALM1_HOUR_REG, pTime->am_pm_indicator);
    2d62:	7a72      	ldrb	r2, [r6, #9]
    2d64:	2113      	movs	r1, #19
    2d66:	0028      	movs	r0, r5
    2d68:	f7ff f99c 	bl	20a4 <mcp794xx_set_am_pm>
    2d6c:	4b15      	ldr	r3, [pc, #84]	; (2dc4 <mcp794xx_set_alarm_time_date+0x500>)
    2d6e:	447b      	add	r3, pc
    2d70:	7018      	strb	r0, [r3, #0]
			if(err)
    2d72:	2800      	cmp	r0, #0
    2d74:	d100      	bne.n	2d78 <mcp794xx_set_alarm_time_date+0x4b4>
    2d76:	e77c      	b.n	2c72 <mcp794xx_set_alarm_time_date+0x3ae>
				return err;
    2d78:	0004      	movs	r4, r0
    2d7a:	e5af      	b.n	28dc <mcp794xx_set_alarm_time_date+0x18>
			a_mcp794xx_print_error_msg(pHandle, "to write alarm 1 week day");
    2d7c:	4912      	ldr	r1, [pc, #72]	; (2dc8 <mcp794xx_set_alarm_time_date+0x504>)
    2d7e:	4479      	add	r1, pc
    2d80:	0028      	movs	r0, r5
    2d82:	f7fe ffe7 	bl	1d54 <a_mcp794xx_print_error_msg>
			return 1;
    2d86:	e5a9      	b.n	28dc <mcp794xx_set_alarm_time_date+0x18>
			a_mcp794xx_print_error_msg(pHandle, "to write alarm 1 date");
    2d88:	4910      	ldr	r1, [pc, #64]	; (2dcc <mcp794xx_set_alarm_time_date+0x508>)
    2d8a:	4479      	add	r1, pc
    2d8c:	0028      	movs	r0, r5
    2d8e:	f7fe ffe1 	bl	1d54 <a_mcp794xx_print_error_msg>
			return 1;
    2d92:	e5a3      	b.n	28dc <mcp794xx_set_alarm_time_date+0x18>
        return 2;     /**< return failed error */
    2d94:	2402      	movs	r4, #2
    2d96:	e5a1      	b.n	28dc <mcp794xx_set_alarm_time_date+0x18>
    return 0;     /**< success */
    2d98:	0004      	movs	r4, r0
    2d9a:	e59f      	b.n	28dc <mcp794xx_set_alarm_time_date+0x18>
    2d9c:	1fffd682 	.word	0x1fffd682
    2da0:	1fffd64a 	.word	0x1fffd64a
    2da4:	1fffd62c 	.word	0x1fffd62c
    2da8:	1fffd60e 	.word	0x1fffd60e
    2dac:	00004d40 	.word	0x00004d40
    2db0:	00004ccc 	.word	0x00004ccc
    2db4:	1fffd5ca 	.word	0x1fffd5ca
    2db8:	00004cb0 	.word	0x00004cb0
    2dbc:	1fffd592 	.word	0x1fffd592
    2dc0:	00004c78 	.word	0x00004c78
    2dc4:	1fffd572 	.word	0x1fffd572
    2dc8:	00004c6a 	.word	0x00004c6a
    2dcc:	00004c7a 	.word	0x00004c7a

00002dd0 <mcp794xx_set_alarm>:
 *          - 3 handle is not initialized
 *          - 4 invalid alarm
 *          - 5 invalid mask
 */
uint8_t mcp794xx_set_alarm(mcp794xx_handle_t *const pHandle, mcp794xx_alarm_t alarm, mcp794xx_alarm_mask_t mask, mcp794xx_time_t *pTime)
{
    2dd0:	b5f0      	push	{r4, r5, r6, r7, lr}
    2dd2:	b085      	sub	sp, #20
    2dd4:	0007      	movs	r7, r0
    2dd6:	000e      	movs	r6, r1
    2dd8:	0015      	movs	r5, r2
    2dda:	9301      	str	r3, [sp, #4]
    uint8_t read_status;

    if(pHandle == NULL)
    2ddc:	2800      	cmp	r0, #0
    2dde:	d100      	bne.n	2de2 <mcp794xx_set_alarm+0x12>
    2de0:	e089      	b.n	2ef6 <mcp794xx_set_alarm+0x126>
        return 2;     /**< return failed error */
    if(pHandle->inited != 1)
    2de2:	7fc4      	ldrb	r4, [r0, #31]
    2de4:	2c01      	cmp	r4, #1
    2de6:	d003      	beq.n	2df0 <mcp794xx_set_alarm+0x20>
        return 3;      /**< return failed error */
    2de8:	2403      	movs	r4, #3

    }

    return 0;              /**< success */

}
    2dea:	0020      	movs	r0, r4
    2dec:	b005      	add	sp, #20
    2dee:	bdf0      	pop	{r4, r5, r6, r7, pc}
    switch((int)alarm)
    2df0:	2900      	cmp	r1, #0
    2df2:	d007      	beq.n	2e04 <mcp794xx_set_alarm+0x34>
    2df4:	2901      	cmp	r1, #1
    2df6:	d041      	beq.n	2e7c <mcp794xx_set_alarm+0xac>
            a_mcp794xx_print_error_msg(pHandle, "invalid alarm selected");
    2df8:	4940      	ldr	r1, [pc, #256]	; (2efc <mcp794xx_set_alarm+0x12c>)
    2dfa:	4479      	add	r1, pc
    2dfc:	f7fe ffaa 	bl	1d54 <a_mcp794xx_print_error_msg>
            return 4;
    2e00:	2404      	movs	r4, #4
    2e02:	e7f2      	b.n	2dea <mcp794xx_set_alarm+0x1a>
            err = rtc_mcp794xx_i2c_read(pHandle, MCP794XX_ALM0_WKDAY_REG, (uint8_t *)&read_status, 1);
    2e04:	2301      	movs	r3, #1
    2e06:	aa02      	add	r2, sp, #8
    2e08:	3207      	adds	r2, #7
    2e0a:	210d      	movs	r1, #13
    2e0c:	f7fe ff2b 	bl	1c66 <rtc_mcp794xx_i2c_read>
    2e10:	4b3b      	ldr	r3, [pc, #236]	; (2f00 <mcp794xx_set_alarm+0x130>)
    2e12:	447b      	add	r3, pc
    2e14:	7018      	strb	r0, [r3, #0]
            if(err)
    2e16:	2800      	cmp	r0, #0
    2e18:	d124      	bne.n	2e64 <mcp794xx_set_alarm+0x94>
            read_status &= ~(0b111 << 4);                           /**< clear alarm mask bit */
    2e1a:	ab02      	add	r3, sp, #8
    2e1c:	1dda      	adds	r2, r3, #7
    2e1e:	7813      	ldrb	r3, [r2, #0]
    2e20:	2170      	movs	r1, #112	; 0x70
    2e22:	438b      	bics	r3, r1
            read_status |= (mask << 4);
    2e24:	012d      	lsls	r5, r5, #4
    2e26:	431d      	orrs	r5, r3
    2e28:	7015      	strb	r5, [r2, #0]
            err = rtc_mcp794xx_i2c_write(pHandle, MCP794XX_ALM0_WKDAY_REG, (uint8_t *)&read_status);
    2e2a:	3963      	subs	r1, #99	; 0x63
    2e2c:	0038      	movs	r0, r7
    2e2e:	f7fe ff01 	bl	1c34 <rtc_mcp794xx_i2c_write>
    2e32:	4b34      	ldr	r3, [pc, #208]	; (2f04 <mcp794xx_set_alarm+0x134>)
    2e34:	447b      	add	r3, pc
    2e36:	7018      	strb	r0, [r3, #0]
            if(err)
    2e38:	2800      	cmp	r0, #0
    2e3a:	d119      	bne.n	2e70 <mcp794xx_set_alarm+0xa0>
            err = mcp794xx_set_alarm_time_date(pHandle, alarm, pTime);
    2e3c:	9a01      	ldr	r2, [sp, #4]
    2e3e:	0031      	movs	r1, r6
    2e40:	0038      	movs	r0, r7
    2e42:	f7ff fd3f 	bl	28c4 <mcp794xx_set_alarm_time_date>
    2e46:	0004      	movs	r4, r0
    2e48:	4b2f      	ldr	r3, [pc, #188]	; (2f08 <mcp794xx_set_alarm+0x138>)
    2e4a:	447b      	add	r3, pc
    2e4c:	7018      	strb	r0, [r3, #0]
            if(err)
    2e4e:	2800      	cmp	r0, #0
    2e50:	d0cb      	beq.n	2dea <mcp794xx_set_alarm+0x1a>
                a_mcp794xx_print_error_msg(pHandle, "failed to set alarm 0");
    2e52:	492e      	ldr	r1, [pc, #184]	; (2f0c <mcp794xx_set_alarm+0x13c>)
    2e54:	4479      	add	r1, pc
    2e56:	0038      	movs	r0, r7
    2e58:	f7fe ff7c 	bl	1d54 <a_mcp794xx_print_error_msg>
                return err;           /**< failed error */
    2e5c:	4b2c      	ldr	r3, [pc, #176]	; (2f10 <mcp794xx_set_alarm+0x140>)
    2e5e:	447b      	add	r3, pc
    2e60:	781c      	ldrb	r4, [r3, #0]
    2e62:	e7c2      	b.n	2dea <mcp794xx_set_alarm+0x1a>
                a_mcp794xx_print_error_msg(pHandle, "read alarm 0 mask register");
    2e64:	492b      	ldr	r1, [pc, #172]	; (2f14 <mcp794xx_set_alarm+0x144>)
    2e66:	4479      	add	r1, pc
    2e68:	0038      	movs	r0, r7
    2e6a:	f7fe ff73 	bl	1d54 <a_mcp794xx_print_error_msg>
                return 1;           /**< failed error */
    2e6e:	e7bc      	b.n	2dea <mcp794xx_set_alarm+0x1a>
                a_mcp794xx_print_error_msg(pHandle, "read alarm 0 mask register");
    2e70:	4929      	ldr	r1, [pc, #164]	; (2f18 <mcp794xx_set_alarm+0x148>)
    2e72:	4479      	add	r1, pc
    2e74:	0038      	movs	r0, r7
    2e76:	f7fe ff6d 	bl	1d54 <a_mcp794xx_print_error_msg>
                return 1;           /**< failed error */
    2e7a:	e7b6      	b.n	2dea <mcp794xx_set_alarm+0x1a>
            err = rtc_mcp794xx_i2c_read(pHandle, MCP794XX_ALM1_WKDAY_REG, (uint8_t *)&read_status, 1);
    2e7c:	2301      	movs	r3, #1
    2e7e:	aa02      	add	r2, sp, #8
    2e80:	3207      	adds	r2, #7
    2e82:	2114      	movs	r1, #20
    2e84:	f7fe feef 	bl	1c66 <rtc_mcp794xx_i2c_read>
    2e88:	4b24      	ldr	r3, [pc, #144]	; (2f1c <mcp794xx_set_alarm+0x14c>)
    2e8a:	447b      	add	r3, pc
    2e8c:	7018      	strb	r0, [r3, #0]
            if(err)
    2e8e:	2800      	cmp	r0, #0
    2e90:	d125      	bne.n	2ede <mcp794xx_set_alarm+0x10e>
            read_status &= ~(0b111 << 4);                           /**< clear alarm mask bit */
    2e92:	ab02      	add	r3, sp, #8
    2e94:	1dda      	adds	r2, r3, #7
    2e96:	7813      	ldrb	r3, [r2, #0]
    2e98:	2170      	movs	r1, #112	; 0x70
    2e9a:	438b      	bics	r3, r1
            read_status |= (mask << 4);
    2e9c:	012d      	lsls	r5, r5, #4
    2e9e:	431d      	orrs	r5, r3
    2ea0:	7015      	strb	r5, [r2, #0]
            err = rtc_mcp794xx_i2c_write(pHandle, MCP794XX_ALM1_WKDAY_REG, (uint8_t *)&read_status);
    2ea2:	395c      	subs	r1, #92	; 0x5c
    2ea4:	0038      	movs	r0, r7
    2ea6:	f7fe fec5 	bl	1c34 <rtc_mcp794xx_i2c_write>
    2eaa:	4b1d      	ldr	r3, [pc, #116]	; (2f20 <mcp794xx_set_alarm+0x150>)
    2eac:	447b      	add	r3, pc
    2eae:	7018      	strb	r0, [r3, #0]
            if(err)
    2eb0:	2800      	cmp	r0, #0
    2eb2:	d11a      	bne.n	2eea <mcp794xx_set_alarm+0x11a>
            err = mcp794xx_set_alarm_time_date(pHandle, alarm, pTime);
    2eb4:	9a01      	ldr	r2, [sp, #4]
    2eb6:	0031      	movs	r1, r6
    2eb8:	0038      	movs	r0, r7
    2eba:	f7ff fd03 	bl	28c4 <mcp794xx_set_alarm_time_date>
    2ebe:	0004      	movs	r4, r0
    2ec0:	4b18      	ldr	r3, [pc, #96]	; (2f24 <mcp794xx_set_alarm+0x154>)
    2ec2:	447b      	add	r3, pc
    2ec4:	7018      	strb	r0, [r3, #0]
            if(err)
    2ec6:	2800      	cmp	r0, #0
    2ec8:	d100      	bne.n	2ecc <mcp794xx_set_alarm+0xfc>
    2eca:	e78e      	b.n	2dea <mcp794xx_set_alarm+0x1a>
                a_mcp794xx_print_error_msg(pHandle, "failed to set alarm 1");
    2ecc:	4916      	ldr	r1, [pc, #88]	; (2f28 <mcp794xx_set_alarm+0x158>)
    2ece:	4479      	add	r1, pc
    2ed0:	0038      	movs	r0, r7
    2ed2:	f7fe ff3f 	bl	1d54 <a_mcp794xx_print_error_msg>
                return err;           /**< failed error */
    2ed6:	4b15      	ldr	r3, [pc, #84]	; (2f2c <mcp794xx_set_alarm+0x15c>)
    2ed8:	447b      	add	r3, pc
    2eda:	781c      	ldrb	r4, [r3, #0]
    2edc:	e785      	b.n	2dea <mcp794xx_set_alarm+0x1a>
                a_mcp794xx_print_error_msg(pHandle, "read alarm 1 mask register");
    2ede:	4914      	ldr	r1, [pc, #80]	; (2f30 <mcp794xx_set_alarm+0x160>)
    2ee0:	4479      	add	r1, pc
    2ee2:	0038      	movs	r0, r7
    2ee4:	f7fe ff36 	bl	1d54 <a_mcp794xx_print_error_msg>
                return 1;           /**< failed error */
    2ee8:	e77f      	b.n	2dea <mcp794xx_set_alarm+0x1a>
                a_mcp794xx_print_error_msg(pHandle, "read alarm 1 mask register");
    2eea:	4912      	ldr	r1, [pc, #72]	; (2f34 <mcp794xx_set_alarm+0x164>)
    2eec:	4479      	add	r1, pc
    2eee:	0038      	movs	r0, r7
    2ef0:	f7fe ff30 	bl	1d54 <a_mcp794xx_print_error_msg>
                return 1;           /**< failed error */
    2ef4:	e779      	b.n	2dea <mcp794xx_set_alarm+0x1a>
        return 2;     /**< return failed error */
    2ef6:	2402      	movs	r4, #2
    2ef8:	e777      	b.n	2dea <mcp794xx_set_alarm+0x1a>
    2efa:	46c0      	nop			; (mov r8, r8)
    2efc:	000048fa 	.word	0x000048fa
    2f00:	1fffd4ce 	.word	0x1fffd4ce
    2f04:	1fffd4ac 	.word	0x1fffd4ac
    2f08:	1fffd496 	.word	0x1fffd496
    2f0c:	00004bfc 	.word	0x00004bfc
    2f10:	1fffd482 	.word	0x1fffd482
    2f14:	00004bce 	.word	0x00004bce
    2f18:	00004bc2 	.word	0x00004bc2
    2f1c:	1fffd456 	.word	0x1fffd456
    2f20:	1fffd434 	.word	0x1fffd434
    2f24:	1fffd41e 	.word	0x1fffd41e
    2f28:	00004bb6 	.word	0x00004bb6
    2f2c:	1fffd408 	.word	0x1fffd408
    2f30:	00004b88 	.word	0x00004b88
    2f34:	00004b7c 	.word	0x00004b7c

00002f38 <mcp794xx_get_alarm_time_date>:
            - 2 handle null
 *          - 3 handle is not initialized
 *          - 4 invalid alarm
 */
uint8_t mcp794xx_get_alarm_time_date(mcp794xx_handle_t *const pHandle, mcp794xx_alarm_t alarm, mcp794xx_time_t *pTime)
{
    2f38:	b5f0      	push	{r4, r5, r6, r7, lr}
    2f3a:	b083      	sub	sp, #12
    2f3c:	0005      	movs	r5, r0
    2f3e:	000f      	movs	r7, r1
    2f40:	0016      	movs	r6, r2
    uint8_t timeBuffer[MCP794XX_TIME_BUFFER_SIZE];

    if(pHandle == NULL)
    2f42:	2800      	cmp	r0, #0
    2f44:	d100      	bne.n	2f48 <mcp794xx_get_alarm_time_date+0x10>
    2f46:	e072      	b.n	302e <mcp794xx_get_alarm_time_date+0xf6>
        return 2;     /**< return failed error */
    if(pHandle->inited != 1)
    2f48:	7fc4      	ldrb	r4, [r0, #31]
    2f4a:	2c01      	cmp	r4, #1
    2f4c:	d003      	beq.n	2f56 <mcp794xx_get_alarm_time_date+0x1e>
        return 3;      /**< return failed error */
    2f4e:	2403      	movs	r4, #3
    pTime->weekDay = a_pcf85xxx_bcd2dec(timeBuffer[3] & MCP794XX_ALARMx_WDAY_MASK);
    pTime->date = a_pcf85xxx_bcd2dec(timeBuffer[4] & MCP794XX_ALARMx_DATE_MASK);
    pTime->month = a_pcf85xxx_bcd2dec(timeBuffer[5] & MCP794XX_ALARMx_MONTH_MASK);

    return 0;              /**< success */
}
    2f50:	0020      	movs	r0, r4
    2f52:	b003      	add	sp, #12
    2f54:	bdf0      	pop	{r4, r5, r6, r7, pc}
    memset(timeBuffer, 0, sizeof(timeBuffer));              /**< clear buffer */
    2f56:	2207      	movs	r2, #7
    2f58:	2100      	movs	r1, #0
    2f5a:	4668      	mov	r0, sp
    2f5c:	f003 f929 	bl	61b2 <memset>
    if(alarm == MCP794XX_ALARM0)
    2f60:	2f00      	cmp	r7, #0
    2f62:	d008      	beq.n	2f76 <mcp794xx_get_alarm_time_date+0x3e>
    else if(alarm == MCP794XX_ALARM1)
    2f64:	2f01      	cmp	r7, #1
    2f66:	d03e      	beq.n	2fe6 <mcp794xx_get_alarm_time_date+0xae>
        a_mcp794xx_print_error_msg(pHandle, "invalid alarm selected");
    2f68:	4932      	ldr	r1, [pc, #200]	; (3034 <mcp794xx_get_alarm_time_date+0xfc>)
    2f6a:	4479      	add	r1, pc
    2f6c:	0028      	movs	r0, r5
    2f6e:	f7fe fef1 	bl	1d54 <a_mcp794xx_print_error_msg>
        return 4;
    2f72:	2404      	movs	r4, #4
    2f74:	e7ec      	b.n	2f50 <mcp794xx_get_alarm_time_date+0x18>
        err = rtc_mcp794xx_i2c_read(pHandle, MCP794XX_ALM0_SEC_REG, (uint8_t *)timeBuffer, (MCP794XX_TIME_BUFFER_SIZE - 1));    /**< read alarm time and date registers */
    2f76:	2306      	movs	r3, #6
    2f78:	466a      	mov	r2, sp
    2f7a:	210a      	movs	r1, #10
    2f7c:	0028      	movs	r0, r5
    2f7e:	f7fe fe72 	bl	1c66 <rtc_mcp794xx_i2c_read>
    2f82:	4b2d      	ldr	r3, [pc, #180]	; (3038 <mcp794xx_get_alarm_time_date+0x100>)
    2f84:	447b      	add	r3, pc
    2f86:	7018      	strb	r0, [r3, #0]
        if(err)
    2f88:	2800      	cmp	r0, #0
    2f8a:	d126      	bne.n	2fda <mcp794xx_get_alarm_time_date+0xa2>
    pTime->second = a_pcf85xxx_bcd2dec(timeBuffer[0] & MCP794XX_ALARMx_SEC_BCD_MASK);
    2f8c:	466f      	mov	r7, sp
    2f8e:	7838      	ldrb	r0, [r7, #0]
    2f90:	247f      	movs	r4, #127	; 0x7f
    2f92:	4020      	ands	r0, r4
    2f94:	f7fe fef4 	bl	1d80 <a_pcf85xxx_bcd2dec>
    2f98:	7170      	strb	r0, [r6, #5]
    pTime->minute = a_pcf85xxx_bcd2dec(timeBuffer[1] & MCP794XX_ALARMx_MIN_BCD_MASK);
    2f9a:	7878      	ldrb	r0, [r7, #1]
    2f9c:	4020      	ands	r0, r4
    2f9e:	f7fe feef 	bl	1d80 <a_pcf85xxx_bcd2dec>
    2fa2:	7130      	strb	r0, [r6, #4]
    if(pHandle->time_param.time_Format == MCP794XX_24HR_FORMAT)
    2fa4:	2370      	movs	r3, #112	; 0x70
    2fa6:	5ceb      	ldrb	r3, [r5, r3]
    2fa8:	2b00      	cmp	r3, #0
    2faa:	d02d      	beq.n	3008 <mcp794xx_get_alarm_time_date+0xd0>
    else if(pHandle->time_param.time_Format == MCP794XX_12HR_FORMAT)
    2fac:	2b01      	cmp	r3, #1
    2fae:	d032      	beq.n	3016 <mcp794xx_get_alarm_time_date+0xde>
    pTime->weekDay = a_pcf85xxx_bcd2dec(timeBuffer[3] & MCP794XX_ALARMx_WDAY_MASK);
    2fb0:	466c      	mov	r4, sp
    2fb2:	78e3      	ldrb	r3, [r4, #3]
    2fb4:	2007      	movs	r0, #7
    2fb6:	4018      	ands	r0, r3
    2fb8:	f7fe fee2 	bl	1d80 <a_pcf85xxx_bcd2dec>
    2fbc:	71f0      	strb	r0, [r6, #7]
    pTime->date = a_pcf85xxx_bcd2dec(timeBuffer[4] & MCP794XX_ALARMx_DATE_MASK);
    2fbe:	7923      	ldrb	r3, [r4, #4]
    2fc0:	203f      	movs	r0, #63	; 0x3f
    2fc2:	4018      	ands	r0, r3
    2fc4:	f7fe fedc 	bl	1d80 <a_pcf85xxx_bcd2dec>
    2fc8:	70b0      	strb	r0, [r6, #2]
    pTime->month = a_pcf85xxx_bcd2dec(timeBuffer[5] & MCP794XX_ALARMx_MONTH_MASK);
    2fca:	7963      	ldrb	r3, [r4, #5]
    2fcc:	201f      	movs	r0, #31
    2fce:	4018      	ands	r0, r3
    2fd0:	f7fe fed6 	bl	1d80 <a_pcf85xxx_bcd2dec>
    2fd4:	71b0      	strb	r0, [r6, #6]
    return 0;              /**< success */
    2fd6:	2400      	movs	r4, #0
    2fd8:	e7ba      	b.n	2f50 <mcp794xx_get_alarm_time_date+0x18>
            a_mcp794xx_print_error_msg(pHandle, "read alarm 0 time and date");
    2fda:	4918      	ldr	r1, [pc, #96]	; (303c <mcp794xx_get_alarm_time_date+0x104>)
    2fdc:	4479      	add	r1, pc
    2fde:	0028      	movs	r0, r5
    2fe0:	f7fe feb8 	bl	1d54 <a_mcp794xx_print_error_msg>
            return 1;                                        /**< failed error */
    2fe4:	e7b4      	b.n	2f50 <mcp794xx_get_alarm_time_date+0x18>
        err = rtc_mcp794xx_i2c_read(pHandle, MCP794XX_ALM1_SEC_REG, (uint8_t *)timeBuffer, (MCP794XX_TIME_BUFFER_SIZE - 1));    /**< read alarm time and date registers */
    2fe6:	2306      	movs	r3, #6
    2fe8:	466a      	mov	r2, sp
    2fea:	2111      	movs	r1, #17
    2fec:	0028      	movs	r0, r5
    2fee:	f7fe fe3a 	bl	1c66 <rtc_mcp794xx_i2c_read>
    2ff2:	4b13      	ldr	r3, [pc, #76]	; (3040 <mcp794xx_get_alarm_time_date+0x108>)
    2ff4:	447b      	add	r3, pc
    2ff6:	7018      	strb	r0, [r3, #0]
        if(err)
    2ff8:	2800      	cmp	r0, #0
    2ffa:	d0c7      	beq.n	2f8c <mcp794xx_get_alarm_time_date+0x54>
            a_mcp794xx_print_error_msg(pHandle, "read alarm 1 time and date");
    2ffc:	4911      	ldr	r1, [pc, #68]	; (3044 <mcp794xx_get_alarm_time_date+0x10c>)
    2ffe:	4479      	add	r1, pc
    3000:	0028      	movs	r0, r5
    3002:	f7fe fea7 	bl	1d54 <a_mcp794xx_print_error_msg>
            return 1;                                        /**< failed error */
    3006:	e7a3      	b.n	2f50 <mcp794xx_get_alarm_time_date+0x18>
        pTime->hour = a_pcf85xxx_bcd2dec(timeBuffer[2] & MCP794XX_ALARMx_24HR_FRMT_BCD_MASK);
    3008:	78bb      	ldrb	r3, [r7, #2]
    300a:	203f      	movs	r0, #63	; 0x3f
    300c:	4018      	ands	r0, r3
    300e:	f7fe feb7 	bl	1d80 <a_pcf85xxx_bcd2dec>
    3012:	70f0      	strb	r0, [r6, #3]
    3014:	e7cc      	b.n	2fb0 <mcp794xx_get_alarm_time_date+0x78>
        pTime->hour = a_pcf85xxx_bcd2dec(timeBuffer[2] & MCP794XX_ALARMx_12HR_FRMT_BCD_MASK);
    3016:	78bb      	ldrb	r3, [r7, #2]
    3018:	201f      	movs	r0, #31
    301a:	4018      	ands	r0, r3
    301c:	f7fe feb0 	bl	1d80 <a_pcf85xxx_bcd2dec>
    3020:	70f0      	strb	r0, [r6, #3]
        pTime->am_pm_indicator = ((timeBuffer[2] & MCP794XX_ALARMx_AM_PM_MASK) >> 5) ;
    3022:	78ba      	ldrb	r2, [r7, #2]
    3024:	1152      	asrs	r2, r2, #5
    3026:	2301      	movs	r3, #1
    3028:	4013      	ands	r3, r2
    302a:	7273      	strb	r3, [r6, #9]
    302c:	e7c0      	b.n	2fb0 <mcp794xx_get_alarm_time_date+0x78>
        return 2;     /**< return failed error */
    302e:	2402      	movs	r4, #2
    3030:	e78e      	b.n	2f50 <mcp794xx_get_alarm_time_date+0x18>
    3032:	46c0      	nop			; (mov r8, r8)
    3034:	0000478a 	.word	0x0000478a
    3038:	1fffd35c 	.word	0x1fffd35c
    303c:	00004ac0 	.word	0x00004ac0
    3040:	1fffd2ec 	.word	0x1fffd2ec
    3044:	00004aba 	.word	0x00004aba

00003048 <mcp794xx_get_alarm>:
            - 2 handle null
 *          - 3 handle is not initialized
 *          - 4 invalid alarm
 */
uint8_t mcp794xx_get_alarm(mcp794xx_handle_t *const pHandle, mcp794xx_alarm_t alarm, mcp794xx_alarm_mask_t *pMask, mcp794xx_time_t *pTime)
{
    3048:	b5f0      	push	{r4, r5, r6, r7, lr}
    304a:	b083      	sub	sp, #12
    304c:	0004      	movs	r4, r0
    304e:	000e      	movs	r6, r1
    3050:	0017      	movs	r7, r2
    uint8_t read_status;

    if(pHandle == NULL)
    3052:	2800      	cmp	r0, #0
    3054:	d055      	beq.n	3102 <mcp794xx_get_alarm+0xba>
        return 2;     /**< return failed error */
    if(pHandle->inited != 1)
    3056:	7fc1      	ldrb	r1, [r0, #31]
    3058:	2901      	cmp	r1, #1
    305a:	d003      	beq.n	3064 <mcp794xx_get_alarm+0x1c>
        return 3;      /**< return failed error */
    305c:	2503      	movs	r5, #3
    }

    *pMask = (mcp794xx_alarm_mask_t)((read_status & MCP794XX_ALARMx_TYPE_MASK) >> 4);

    return 0;
}
    305e:	0028      	movs	r0, r5
    3060:	b003      	add	sp, #12
    3062:	bdf0      	pop	{r4, r5, r6, r7, pc}
    err = mcp794xx_get_alarm_time_date(pHandle, alarm, pTime);
    3064:	001a      	movs	r2, r3
    3066:	0031      	movs	r1, r6
    3068:	f7ff ff66 	bl	2f38 <mcp794xx_get_alarm_time_date>
    306c:	0005      	movs	r5, r0
    306e:	4b26      	ldr	r3, [pc, #152]	; (3108 <mcp794xx_get_alarm+0xc0>)
    3070:	447b      	add	r3, pc
    3072:	7018      	strb	r0, [r3, #0]
    if(err){
    3074:	2800      	cmp	r0, #0
    3076:	d10a      	bne.n	308e <mcp794xx_get_alarm+0x46>
    if(alarm == MCP794XX_ALARM0)
    3078:	2e00      	cmp	r6, #0
    307a:	d011      	beq.n	30a0 <mcp794xx_get_alarm+0x58>
    else if(alarm == MCP794XX_ALARM1)
    307c:	2e01      	cmp	r6, #1
    307e:	d02b      	beq.n	30d8 <mcp794xx_get_alarm+0x90>
        a_mcp794xx_print_error_msg(pHandle, "invalid alarm selected");
    3080:	4922      	ldr	r1, [pc, #136]	; (310c <mcp794xx_get_alarm+0xc4>)
    3082:	4479      	add	r1, pc
    3084:	0020      	movs	r0, r4
    3086:	f7fe fe65 	bl	1d54 <a_mcp794xx_print_error_msg>
        return 4;
    308a:	2504      	movs	r5, #4
    308c:	e7e7      	b.n	305e <mcp794xx_get_alarm+0x16>
         a_mcp794xx_print_error_msg(pHandle, "failed to get alarm time and date");
    308e:	4920      	ldr	r1, [pc, #128]	; (3110 <mcp794xx_get_alarm+0xc8>)
    3090:	4479      	add	r1, pc
    3092:	0020      	movs	r0, r4
    3094:	f7fe fe5e 	bl	1d54 <a_mcp794xx_print_error_msg>
        return err;
    3098:	4b1e      	ldr	r3, [pc, #120]	; (3114 <mcp794xx_get_alarm+0xcc>)
    309a:	447b      	add	r3, pc
    309c:	781d      	ldrb	r5, [r3, #0]
    309e:	e7de      	b.n	305e <mcp794xx_get_alarm+0x16>
        err = rtc_mcp794xx_i2c_read(pHandle, MCP794XX_ALM0_WKDAY_REG, (uint8_t *)&read_status, 1);
    30a0:	2301      	movs	r3, #1
    30a2:	466a      	mov	r2, sp
    30a4:	3207      	adds	r2, #7
    30a6:	210d      	movs	r1, #13
    30a8:	0020      	movs	r0, r4
    30aa:	f7fe fddc 	bl	1c66 <rtc_mcp794xx_i2c_read>
    30ae:	4b1a      	ldr	r3, [pc, #104]	; (3118 <mcp794xx_get_alarm+0xd0>)
    30b0:	447b      	add	r3, pc
    30b2:	7018      	strb	r0, [r3, #0]
        if(err)
    30b4:	2800      	cmp	r0, #0
    30b6:	d106      	bne.n	30c6 <mcp794xx_get_alarm+0x7e>
    *pMask = (mcp794xx_alarm_mask_t)((read_status & MCP794XX_ALARMx_TYPE_MASK) >> 4);
    30b8:	466b      	mov	r3, sp
    30ba:	79da      	ldrb	r2, [r3, #7]
    30bc:	1112      	asrs	r2, r2, #4
    30be:	2307      	movs	r3, #7
    30c0:	4013      	ands	r3, r2
    30c2:	703b      	strb	r3, [r7, #0]
    return 0;
    30c4:	e7cb      	b.n	305e <mcp794xx_get_alarm+0x16>
            a_mcp794xx_print_error_msg(pHandle, "failed read alarm mask");
    30c6:	4915      	ldr	r1, [pc, #84]	; (311c <mcp794xx_get_alarm+0xd4>)
    30c8:	4479      	add	r1, pc
    30ca:	0020      	movs	r0, r4
    30cc:	f7fe fe42 	bl	1d54 <a_mcp794xx_print_error_msg>
            return err;
    30d0:	4b13      	ldr	r3, [pc, #76]	; (3120 <mcp794xx_get_alarm+0xd8>)
    30d2:	447b      	add	r3, pc
    30d4:	781d      	ldrb	r5, [r3, #0]
    30d6:	e7c2      	b.n	305e <mcp794xx_get_alarm+0x16>
        err = rtc_mcp794xx_i2c_read(pHandle, MCP794XX_ALM1_WKDAY_REG, (uint8_t *)&read_status, 1);
    30d8:	2301      	movs	r3, #1
    30da:	466a      	mov	r2, sp
    30dc:	3207      	adds	r2, #7
    30de:	2114      	movs	r1, #20
    30e0:	0020      	movs	r0, r4
    30e2:	f7fe fdc0 	bl	1c66 <rtc_mcp794xx_i2c_read>
    30e6:	4b0f      	ldr	r3, [pc, #60]	; (3124 <mcp794xx_get_alarm+0xdc>)
    30e8:	447b      	add	r3, pc
    30ea:	7018      	strb	r0, [r3, #0]
        if(err)
    30ec:	2800      	cmp	r0, #0
    30ee:	d0e3      	beq.n	30b8 <mcp794xx_get_alarm+0x70>
            a_mcp794xx_print_error_msg(pHandle, "failed read alarm mask");
    30f0:	490d      	ldr	r1, [pc, #52]	; (3128 <mcp794xx_get_alarm+0xe0>)
    30f2:	4479      	add	r1, pc
    30f4:	0020      	movs	r0, r4
    30f6:	f7fe fe2d 	bl	1d54 <a_mcp794xx_print_error_msg>
            return err;
    30fa:	4b0c      	ldr	r3, [pc, #48]	; (312c <mcp794xx_get_alarm+0xe4>)
    30fc:	447b      	add	r3, pc
    30fe:	781d      	ldrb	r5, [r3, #0]
    3100:	e7ad      	b.n	305e <mcp794xx_get_alarm+0x16>
        return 2;     /**< return failed error */
    3102:	2502      	movs	r5, #2
    3104:	e7ab      	b.n	305e <mcp794xx_get_alarm+0x16>
    3106:	46c0      	nop			; (mov r8, r8)
    3108:	1fffd270 	.word	0x1fffd270
    310c:	00004672 	.word	0x00004672
    3110:	00004a44 	.word	0x00004a44
    3114:	1fffd246 	.word	0x1fffd246
    3118:	1fffd230 	.word	0x1fffd230
    311c:	00004a30 	.word	0x00004a30
    3120:	1fffd20e 	.word	0x1fffd20e
    3124:	1fffd1f8 	.word	0x1fffd1f8
    3128:	00004a06 	.word	0x00004a06
    312c:	1fffd1e4 	.word	0x1fffd1e4

00003130 <mcp794xx_get_alarm_interrupt_flag>:
            - 2 handle null
 *          - 3 handle is not initialized
 *          - 4 invalid alarm
 */
uint8_t mcp794xx_get_alarm_interrupt_flag(mcp794xx_handle_t *const pHandle, mcp794xx_alarm_t alarm, mcp794xx_alarm_int_flag_t *pFlag)
{
    3130:	b570      	push	{r4, r5, r6, lr}
    3132:	b082      	sub	sp, #8
    3134:	0004      	movs	r4, r0
    3136:	0016      	movs	r6, r2
    uint8_t read_status;

    if(pHandle == NULL)
    3138:	2800      	cmp	r0, #0
    313a:	d041      	beq.n	31c0 <mcp794xx_get_alarm_interrupt_flag+0x90>
        return 2;     /**< return failed error */
    if(pHandle->inited != 1)
    313c:	7fc5      	ldrb	r5, [r0, #31]
    313e:	2d01      	cmp	r5, #1
    3140:	d002      	beq.n	3148 <mcp794xx_get_alarm_interrupt_flag+0x18>
        return 3;      /**< return failed error */
    3142:	2003      	movs	r0, #3
        a_mcp794xx_print_error_msg(pHandle, "invalid alarm selected");
        return 4;
    }

    return 0;              /**< success */
}
    3144:	b002      	add	sp, #8
    3146:	bd70      	pop	{r4, r5, r6, pc}
    if(alarm == MCP794XX_ALARM0)
    3148:	2900      	cmp	r1, #0
    314a:	d007      	beq.n	315c <mcp794xx_get_alarm_interrupt_flag+0x2c>
    else if(alarm == MCP794XX_ALARM1)
    314c:	2901      	cmp	r1, #1
    314e:	d01e      	beq.n	318e <mcp794xx_get_alarm_interrupt_flag+0x5e>
        a_mcp794xx_print_error_msg(pHandle, "invalid alarm selected");
    3150:	491c      	ldr	r1, [pc, #112]	; (31c4 <mcp794xx_get_alarm_interrupt_flag+0x94>)
    3152:	4479      	add	r1, pc
    3154:	f7fe fdfe 	bl	1d54 <a_mcp794xx_print_error_msg>
        return 4;
    3158:	2004      	movs	r0, #4
    315a:	e7f3      	b.n	3144 <mcp794xx_get_alarm_interrupt_flag+0x14>
         err = rtc_mcp794xx_i2c_read(pHandle,MCP794XX_ALM0_WKDAY_REG, (uint8_t *)&read_status, 1);
    315c:	2301      	movs	r3, #1
    315e:	466a      	mov	r2, sp
    3160:	3207      	adds	r2, #7
    3162:	310d      	adds	r1, #13
    3164:	f7fe fd7f 	bl	1c66 <rtc_mcp794xx_i2c_read>
    3168:	4a17      	ldr	r2, [pc, #92]	; (31c8 <mcp794xx_get_alarm_interrupt_flag+0x98>)
    316a:	447a      	add	r2, pc
    316c:	7010      	strb	r0, [r2, #0]
        if(err)
    316e:	2800      	cmp	r0, #0
    3170:	d106      	bne.n	3180 <mcp794xx_get_alarm_interrupt_flag+0x50>
       *pFlag = (mcp794xx_alarm_int_flag_t)((read_status & MCP794XX_ALARMx_IF_MASK ) >> 3);
    3172:	466b      	mov	r3, sp
    3174:	79da      	ldrb	r2, [r3, #7]
    3176:	10d2      	asrs	r2, r2, #3
    3178:	2301      	movs	r3, #1
    317a:	4013      	ands	r3, r2
    317c:	7033      	strb	r3, [r6, #0]
    317e:	e7e1      	b.n	3144 <mcp794xx_get_alarm_interrupt_flag+0x14>
            a_mcp794xx_print_error_msg(pHandle, "failed to read alarm 0 interrupt flag");
    3180:	4912      	ldr	r1, [pc, #72]	; (31cc <mcp794xx_get_alarm_interrupt_flag+0x9c>)
    3182:	4479      	add	r1, pc
    3184:	0020      	movs	r0, r4
    3186:	f7fe fde5 	bl	1d54 <a_mcp794xx_print_error_msg>
            return 1;           /**< failed error */
    318a:	0028      	movs	r0, r5
    318c:	e7da      	b.n	3144 <mcp794xx_get_alarm_interrupt_flag+0x14>
        err = rtc_mcp794xx_i2c_read(pHandle,MCP794XX_ALM1_WKDAY_REG, (uint8_t *)&read_status, 1);
    318e:	2301      	movs	r3, #1
    3190:	466a      	mov	r2, sp
    3192:	3207      	adds	r2, #7
    3194:	3113      	adds	r1, #19
    3196:	f7fe fd66 	bl	1c66 <rtc_mcp794xx_i2c_read>
    319a:	4a0d      	ldr	r2, [pc, #52]	; (31d0 <mcp794xx_get_alarm_interrupt_flag+0xa0>)
    319c:	447a      	add	r2, pc
    319e:	7010      	strb	r0, [r2, #0]
        if(err)
    31a0:	2800      	cmp	r0, #0
    31a2:	d106      	bne.n	31b2 <mcp794xx_get_alarm_interrupt_flag+0x82>
       *pFlag = (mcp794xx_alarm_int_flag_t)((read_status & MCP794XX_ALARMx_IF_MASK ) >> 3);
    31a4:	466b      	mov	r3, sp
    31a6:	79da      	ldrb	r2, [r3, #7]
    31a8:	10d2      	asrs	r2, r2, #3
    31aa:	2301      	movs	r3, #1
    31ac:	4013      	ands	r3, r2
    31ae:	7033      	strb	r3, [r6, #0]
    31b0:	e7c8      	b.n	3144 <mcp794xx_get_alarm_interrupt_flag+0x14>
            a_mcp794xx_print_error_msg(pHandle, "failed to read alarm 1 interrupt flag");
    31b2:	4908      	ldr	r1, [pc, #32]	; (31d4 <mcp794xx_get_alarm_interrupt_flag+0xa4>)
    31b4:	4479      	add	r1, pc
    31b6:	0020      	movs	r0, r4
    31b8:	f7fe fdcc 	bl	1d54 <a_mcp794xx_print_error_msg>
            return 1;           /**< failed error */
    31bc:	0028      	movs	r0, r5
    31be:	e7c1      	b.n	3144 <mcp794xx_get_alarm_interrupt_flag+0x14>
        return 2;     /**< return failed error */
    31c0:	2002      	movs	r0, #2
    31c2:	e7bf      	b.n	3144 <mcp794xx_get_alarm_interrupt_flag+0x14>
    31c4:	000045a2 	.word	0x000045a2
    31c8:	1fffd176 	.word	0x1fffd176
    31cc:	0000498e 	.word	0x0000498e
    31d0:	1fffd144 	.word	0x1fffd144
    31d4:	00004984 	.word	0x00004984

000031d8 <mcp794xx_clr_alarm_interrupt_flag>:
            - 2 handle null
 *          - 3 handle is not initialized
 *          - 4 invalid alarm
 */
uint8_t mcp794xx_clr_alarm_interrupt_flag(mcp794xx_handle_t *const pHandle, mcp794xx_alarm_t alarm)
{
    31d8:	b530      	push	{r4, r5, lr}
    31da:	b083      	sub	sp, #12
    31dc:	1e04      	subs	r4, r0, #0
    uint8_t read_status;

    if(pHandle == NULL)
    31de:	d05f      	beq.n	32a0 <mcp794xx_clr_alarm_interrupt_flag+0xc8>
        return 2;     /**< return failed error */
    if(pHandle->inited != 1)
    31e0:	7fc5      	ldrb	r5, [r0, #31]
    31e2:	2d01      	cmp	r5, #1
    31e4:	d002      	beq.n	31ec <mcp794xx_clr_alarm_interrupt_flag+0x14>
        return 3;      /**< return failed error */
    31e6:	2003      	movs	r0, #3
        a_mcp794xx_print_error_msg(pHandle, "invalid alarm selected");
        return 4;
    }

    return 0;              /**< success */
}
    31e8:	b003      	add	sp, #12
    31ea:	bd30      	pop	{r4, r5, pc}
    if(alarm == MCP794XX_ALARM0)
    31ec:	2900      	cmp	r1, #0
    31ee:	d007      	beq.n	3200 <mcp794xx_clr_alarm_interrupt_flag+0x28>
    else if(alarm == MCP794XX_ALARM1)
    31f0:	2901      	cmp	r1, #1
    31f2:	d02d      	beq.n	3250 <mcp794xx_clr_alarm_interrupt_flag+0x78>
        a_mcp794xx_print_error_msg(pHandle, "invalid alarm selected");
    31f4:	492b      	ldr	r1, [pc, #172]	; (32a4 <mcp794xx_clr_alarm_interrupt_flag+0xcc>)
    31f6:	4479      	add	r1, pc
    31f8:	f7fe fdac 	bl	1d54 <a_mcp794xx_print_error_msg>
        return 4;
    31fc:	2004      	movs	r0, #4
    31fe:	e7f3      	b.n	31e8 <mcp794xx_clr_alarm_interrupt_flag+0x10>
        err = rtc_mcp794xx_i2c_read(pHandle, MCP794XX_ALM0_WKDAY_REG, (uint8_t *)&read_status, 1);
    3200:	2301      	movs	r3, #1
    3202:	466a      	mov	r2, sp
    3204:	3207      	adds	r2, #7
    3206:	310d      	adds	r1, #13
    3208:	f7fe fd2d 	bl	1c66 <rtc_mcp794xx_i2c_read>
    320c:	4b26      	ldr	r3, [pc, #152]	; (32a8 <mcp794xx_clr_alarm_interrupt_flag+0xd0>)
    320e:	447b      	add	r3, pc
    3210:	7018      	strb	r0, [r3, #0]
        if(err)
    3212:	2800      	cmp	r0, #0
    3214:	d115      	bne.n	3242 <mcp794xx_clr_alarm_interrupt_flag+0x6a>
        read_status &= ~(1 << 3);
    3216:	466b      	mov	r3, sp
    3218:	1dda      	adds	r2, r3, #7
    321a:	7813      	ldrb	r3, [r2, #0]
    321c:	2108      	movs	r1, #8
    321e:	438b      	bics	r3, r1
    3220:	7013      	strb	r3, [r2, #0]
        err = rtc_mcp794xx_i2c_write(pHandle, MCP794XX_ALM0_WKDAY_REG, (uint8_t *)&read_status);
    3222:	3105      	adds	r1, #5
    3224:	0020      	movs	r0, r4
    3226:	f7fe fd05 	bl	1c34 <rtc_mcp794xx_i2c_write>
    322a:	4a20      	ldr	r2, [pc, #128]	; (32ac <mcp794xx_clr_alarm_interrupt_flag+0xd4>)
    322c:	447a      	add	r2, pc
    322e:	7010      	strb	r0, [r2, #0]
        if(err)
    3230:	2800      	cmp	r0, #0
    3232:	d0d9      	beq.n	31e8 <mcp794xx_clr_alarm_interrupt_flag+0x10>
            a_mcp794xx_print_error_msg(pHandle, "clear alarm 0 interrupt flag bit");
    3234:	491e      	ldr	r1, [pc, #120]	; (32b0 <mcp794xx_clr_alarm_interrupt_flag+0xd8>)
    3236:	4479      	add	r1, pc
    3238:	0020      	movs	r0, r4
    323a:	f7fe fd8b 	bl	1d54 <a_mcp794xx_print_error_msg>
            return 1;           /**< failed error */
    323e:	0028      	movs	r0, r5
    3240:	e7d2      	b.n	31e8 <mcp794xx_clr_alarm_interrupt_flag+0x10>
            a_mcp794xx_print_error_msg(pHandle, "read alarm 0 interrupt flag register");
    3242:	491c      	ldr	r1, [pc, #112]	; (32b4 <mcp794xx_clr_alarm_interrupt_flag+0xdc>)
    3244:	4479      	add	r1, pc
    3246:	0020      	movs	r0, r4
    3248:	f7fe fd84 	bl	1d54 <a_mcp794xx_print_error_msg>
            return 1;           /**< failed error */
    324c:	0028      	movs	r0, r5
    324e:	e7cb      	b.n	31e8 <mcp794xx_clr_alarm_interrupt_flag+0x10>
        err = rtc_mcp794xx_i2c_read(pHandle, MCP794XX_ALM1_WKDAY_REG, (uint8_t *)&read_status, 1);
    3250:	2301      	movs	r3, #1
    3252:	466a      	mov	r2, sp
    3254:	3207      	adds	r2, #7
    3256:	3113      	adds	r1, #19
    3258:	f7fe fd05 	bl	1c66 <rtc_mcp794xx_i2c_read>
    325c:	4b16      	ldr	r3, [pc, #88]	; (32b8 <mcp794xx_clr_alarm_interrupt_flag+0xe0>)
    325e:	447b      	add	r3, pc
    3260:	7018      	strb	r0, [r3, #0]
        if(err)
    3262:	2800      	cmp	r0, #0
    3264:	d115      	bne.n	3292 <mcp794xx_clr_alarm_interrupt_flag+0xba>
        read_status &= ~(1 << 3);
    3266:	466b      	mov	r3, sp
    3268:	1dda      	adds	r2, r3, #7
    326a:	7813      	ldrb	r3, [r2, #0]
    326c:	2108      	movs	r1, #8
    326e:	438b      	bics	r3, r1
    3270:	7013      	strb	r3, [r2, #0]
        err = rtc_mcp794xx_i2c_write(pHandle, MCP794XX_ALM1_WKDAY_REG, (uint8_t *)&read_status);
    3272:	310c      	adds	r1, #12
    3274:	0020      	movs	r0, r4
    3276:	f7fe fcdd 	bl	1c34 <rtc_mcp794xx_i2c_write>
    327a:	4a10      	ldr	r2, [pc, #64]	; (32bc <mcp794xx_clr_alarm_interrupt_flag+0xe4>)
    327c:	447a      	add	r2, pc
    327e:	7010      	strb	r0, [r2, #0]
        if(err)
    3280:	2800      	cmp	r0, #0
    3282:	d0b1      	beq.n	31e8 <mcp794xx_clr_alarm_interrupt_flag+0x10>
            a_mcp794xx_print_error_msg(pHandle, "clear alarm 1 interrupt flag bit");
    3284:	490e      	ldr	r1, [pc, #56]	; (32c0 <mcp794xx_clr_alarm_interrupt_flag+0xe8>)
    3286:	4479      	add	r1, pc
    3288:	0020      	movs	r0, r4
    328a:	f7fe fd63 	bl	1d54 <a_mcp794xx_print_error_msg>
            return 1;           /**< failed error */
    328e:	0028      	movs	r0, r5
    3290:	e7aa      	b.n	31e8 <mcp794xx_clr_alarm_interrupt_flag+0x10>
            a_mcp794xx_print_error_msg(pHandle, "read alarm 1 interrupt flag register");
    3292:	490c      	ldr	r1, [pc, #48]	; (32c4 <mcp794xx_clr_alarm_interrupt_flag+0xec>)
    3294:	4479      	add	r1, pc
    3296:	0020      	movs	r0, r4
    3298:	f7fe fd5c 	bl	1d54 <a_mcp794xx_print_error_msg>
            return 1;           /**< failed error */
    329c:	0028      	movs	r0, r5
    329e:	e7a3      	b.n	31e8 <mcp794xx_clr_alarm_interrupt_flag+0x10>
        return 2;     /**< return failed error */
    32a0:	2002      	movs	r0, #2
    32a2:	e7a1      	b.n	31e8 <mcp794xx_clr_alarm_interrupt_flag+0x10>
    32a4:	000044fe 	.word	0x000044fe
    32a8:	1fffd0d2 	.word	0x1fffd0d2
    32ac:	1fffd0b4 	.word	0x1fffd0b4
    32b0:	00004952 	.word	0x00004952
    32b4:	0000491c 	.word	0x0000491c
    32b8:	1fffd082 	.word	0x1fffd082
    32bc:	1fffd064 	.word	0x1fffd064
    32c0:	0000494e 	.word	0x0000494e
    32c4:	00004918 	.word	0x00004918

000032c8 <mcp794xx_set_mfp_logic_level>:
 *          - 1 failed
            - 2 handle null
 *          - 3 handle is not initialized
 */
uint8_t mcp794xx_set_mfp_logic_level(mcp794xx_handle_t *const pHandle, mcp794xx_mfp_logic_level_t logicLevel)
{
    32c8:	b570      	push	{r4, r5, r6, lr}
    32ca:	b082      	sub	sp, #8
    32cc:	0004      	movs	r4, r0
    32ce:	000e      	movs	r6, r1
    uint8_t read_status;

    if(pHandle == NULL)
    32d0:	2800      	cmp	r0, #0
    32d2:	d02f      	beq.n	3334 <mcp794xx_set_mfp_logic_level+0x6c>
        return 2;     /**< return failed error */
    if(pHandle->inited != 1)
    32d4:	7fc5      	ldrb	r5, [r0, #31]
    32d6:	2d01      	cmp	r5, #1
    32d8:	d002      	beq.n	32e0 <mcp794xx_set_mfp_logic_level+0x18>
        return 3;      /**< return failed error */
    32da:	2003      	movs	r0, #3
        a_mcp794xx_print_error_msg(pHandle, "write ctrl register");
        return 1;           /**< failed error */
    }

    return 0;              /**< success */
}
    32dc:	b002      	add	sp, #8
    32de:	bd70      	pop	{r4, r5, r6, pc}
    err = rtc_mcp794xx_i2c_read(pHandle, MCP794XX_CONTROL_REG, (uint8_t *)&read_status, 1);
    32e0:	2301      	movs	r3, #1
    32e2:	466a      	mov	r2, sp
    32e4:	3207      	adds	r2, #7
    32e6:	2107      	movs	r1, #7
    32e8:	f7fe fcbd 	bl	1c66 <rtc_mcp794xx_i2c_read>
    32ec:	4b12      	ldr	r3, [pc, #72]	; (3338 <mcp794xx_set_mfp_logic_level+0x70>)
    32ee:	447b      	add	r3, pc
    32f0:	7018      	strb	r0, [r3, #0]
    if(err)
    32f2:	2800      	cmp	r0, #0
    32f4:	d117      	bne.n	3326 <mcp794xx_set_mfp_logic_level+0x5e>
    read_status &= ~(1 << 7);
    32f6:	466b      	mov	r3, sp
    32f8:	1dda      	adds	r2, r3, #7
    32fa:	7811      	ldrb	r1, [r2, #0]
    32fc:	237f      	movs	r3, #127	; 0x7f
    32fe:	400b      	ands	r3, r1
    read_status |= (logicLevel << 7);
    3300:	01f6      	lsls	r6, r6, #7
    3302:	431e      	orrs	r6, r3
    3304:	7016      	strb	r6, [r2, #0]
    err = rtc_mcp794xx_i2c_write(pHandle, MCP794XX_CONTROL_REG, (uint8_t *)&read_status);
    3306:	2107      	movs	r1, #7
    3308:	0020      	movs	r0, r4
    330a:	f7fe fc93 	bl	1c34 <rtc_mcp794xx_i2c_write>
    330e:	4a0b      	ldr	r2, [pc, #44]	; (333c <mcp794xx_set_mfp_logic_level+0x74>)
    3310:	447a      	add	r2, pc
    3312:	7010      	strb	r0, [r2, #0]
    if(err)
    3314:	2800      	cmp	r0, #0
    3316:	d0e1      	beq.n	32dc <mcp794xx_set_mfp_logic_level+0x14>
        a_mcp794xx_print_error_msg(pHandle, "write ctrl register");
    3318:	4909      	ldr	r1, [pc, #36]	; (3340 <mcp794xx_set_mfp_logic_level+0x78>)
    331a:	4479      	add	r1, pc
    331c:	0020      	movs	r0, r4
    331e:	f7fe fd19 	bl	1d54 <a_mcp794xx_print_error_msg>
        return 1;           /**< failed error */
    3322:	0028      	movs	r0, r5
    3324:	e7da      	b.n	32dc <mcp794xx_set_mfp_logic_level+0x14>
        a_mcp794xx_print_error_msg(pHandle, "read ctrl register");
    3326:	4907      	ldr	r1, [pc, #28]	; (3344 <mcp794xx_set_mfp_logic_level+0x7c>)
    3328:	4479      	add	r1, pc
    332a:	0020      	movs	r0, r4
    332c:	f7fe fd12 	bl	1d54 <a_mcp794xx_print_error_msg>
        return 1;           /**< failed error */
    3330:	0028      	movs	r0, r5
    3332:	e7d3      	b.n	32dc <mcp794xx_set_mfp_logic_level+0x14>
        return 2;     /**< return failed error */
    3334:	2002      	movs	r0, #2
    3336:	e7d1      	b.n	32dc <mcp794xx_set_mfp_logic_level+0x14>
    3338:	1fffcff2 	.word	0x1fffcff2
    333c:	1fffcfd0 	.word	0x1fffcfd0
    3340:	000048f2 	.word	0x000048f2
    3344:	000048d0 	.word	0x000048d0

00003348 <mcp94xx_set_sqr_wave_output_freq>:
            - 2 handle null
 *          - 3 handle is not initialized
 * @note prior to setting frequency output, the "mcp794xx_set_sqr_wave_enable_status" must called first to enable this feature.
 */
uint8_t mcp94xx_set_sqr_wave_output_freq(mcp794xx_handle_t *const pHandle, mcp94xx_sqr_wave_freq_t freq)
{
    3348:	b570      	push	{r4, r5, r6, lr}
    334a:	b082      	sub	sp, #8
    334c:	0004      	movs	r4, r0
    334e:	000e      	movs	r6, r1
    uint8_t read_status;

    if(pHandle == NULL)
    3350:	2800      	cmp	r0, #0
    3352:	d02e      	beq.n	33b2 <mcp94xx_set_sqr_wave_output_freq+0x6a>
        return 2;     /**< return failed error */
    if(pHandle->inited != 1)
    3354:	7fc5      	ldrb	r5, [r0, #31]
    3356:	2d01      	cmp	r5, #1
    3358:	d002      	beq.n	3360 <mcp94xx_set_sqr_wave_output_freq+0x18>
        return 3;      /**< return failed error */
    335a:	2003      	movs	r0, #3
        a_mcp794xx_print_error_msg(pHandle, "write ctrl register");
        return 1;           /**< failed error */
    }

    return 0;              /**< success */
}
    335c:	b002      	add	sp, #8
    335e:	bd70      	pop	{r4, r5, r6, pc}
    err = rtc_mcp794xx_i2c_read(pHandle, MCP794XX_CONTROL_REG, (uint8_t *)&read_status, 1);
    3360:	2301      	movs	r3, #1
    3362:	466a      	mov	r2, sp
    3364:	3207      	adds	r2, #7
    3366:	2107      	movs	r1, #7
    3368:	f7fe fc7d 	bl	1c66 <rtc_mcp794xx_i2c_read>
    336c:	4b12      	ldr	r3, [pc, #72]	; (33b8 <mcp94xx_set_sqr_wave_output_freq+0x70>)
    336e:	447b      	add	r3, pc
    3370:	7018      	strb	r0, [r3, #0]
    if(err)
    3372:	2800      	cmp	r0, #0
    3374:	d116      	bne.n	33a4 <mcp94xx_set_sqr_wave_output_freq+0x5c>
    read_status &= ~ (0b11 << 0);
    3376:	466b      	mov	r3, sp
    3378:	1dda      	adds	r2, r3, #7
    337a:	7813      	ldrb	r3, [r2, #0]
    337c:	2103      	movs	r1, #3
    337e:	438b      	bics	r3, r1
    read_status |= (freq << 0);
    3380:	431e      	orrs	r6, r3
    3382:	7016      	strb	r6, [r2, #0]
    err = rtc_mcp794xx_i2c_write(pHandle, MCP794XX_CONTROL_REG, (uint8_t *)&read_status);
    3384:	3104      	adds	r1, #4
    3386:	0020      	movs	r0, r4
    3388:	f7fe fc54 	bl	1c34 <rtc_mcp794xx_i2c_write>
    338c:	4a0b      	ldr	r2, [pc, #44]	; (33bc <mcp94xx_set_sqr_wave_output_freq+0x74>)
    338e:	447a      	add	r2, pc
    3390:	7010      	strb	r0, [r2, #0]
    if(err)
    3392:	2800      	cmp	r0, #0
    3394:	d0e2      	beq.n	335c <mcp94xx_set_sqr_wave_output_freq+0x14>
        a_mcp794xx_print_error_msg(pHandle, "write ctrl register");
    3396:	490a      	ldr	r1, [pc, #40]	; (33c0 <mcp94xx_set_sqr_wave_output_freq+0x78>)
    3398:	4479      	add	r1, pc
    339a:	0020      	movs	r0, r4
    339c:	f7fe fcda 	bl	1d54 <a_mcp794xx_print_error_msg>
        return 1;           /**< failed error */
    33a0:	0028      	movs	r0, r5
    33a2:	e7db      	b.n	335c <mcp94xx_set_sqr_wave_output_freq+0x14>
        a_mcp794xx_print_error_msg(pHandle, "read ctrl register");
    33a4:	4907      	ldr	r1, [pc, #28]	; (33c4 <mcp94xx_set_sqr_wave_output_freq+0x7c>)
    33a6:	4479      	add	r1, pc
    33a8:	0020      	movs	r0, r4
    33aa:	f7fe fcd3 	bl	1d54 <a_mcp794xx_print_error_msg>
        return 1;           /**< failed error */
    33ae:	0028      	movs	r0, r5
    33b0:	e7d4      	b.n	335c <mcp94xx_set_sqr_wave_output_freq+0x14>
        return 2;     /**< return failed error */
    33b2:	2002      	movs	r0, #2
    33b4:	e7d2      	b.n	335c <mcp94xx_set_sqr_wave_output_freq+0x14>
    33b6:	46c0      	nop			; (mov r8, r8)
    33b8:	1fffcf72 	.word	0x1fffcf72
    33bc:	1fffcf52 	.word	0x1fffcf52
    33c0:	00004874 	.word	0x00004874
    33c4:	00004852 	.word	0x00004852

000033c8 <mcp794xx_set_sqr_wave_enable_status>:
 *          - 1 failed
            - 2 handle null
 *          - 3 handle is not initialized
 */
uint8_t mcp794xx_set_sqr_wave_enable_status(mcp794xx_handle_t *const pHandle, mcp794xx_bool_t enable)
{
    33c8:	b570      	push	{r4, r5, r6, lr}
    33ca:	b082      	sub	sp, #8
    33cc:	0004      	movs	r4, r0
    33ce:	000e      	movs	r6, r1
    uint8_t read_status;

    if(pHandle == NULL)
    33d0:	2800      	cmp	r0, #0
    33d2:	d02f      	beq.n	3434 <mcp794xx_set_sqr_wave_enable_status+0x6c>
        return 2;     /**< return failed error */
    if(pHandle->inited != 1)
    33d4:	7fc5      	ldrb	r5, [r0, #31]
    33d6:	2d01      	cmp	r5, #1
    33d8:	d002      	beq.n	33e0 <mcp794xx_set_sqr_wave_enable_status+0x18>
        return 3;      /**< return failed error */
    33da:	2003      	movs	r0, #3
        a_mcp794xx_print_error_msg(pHandle, "write ctrl register");
        return 1;           /**< failed error */
    }

    return 0;           /**< success */
}
    33dc:	b002      	add	sp, #8
    33de:	bd70      	pop	{r4, r5, r6, pc}
    err = rtc_mcp794xx_i2c_read(pHandle, MCP794XX_CONTROL_REG, (uint8_t *)&read_status, 1);
    33e0:	2301      	movs	r3, #1
    33e2:	466a      	mov	r2, sp
    33e4:	3207      	adds	r2, #7
    33e6:	2107      	movs	r1, #7
    33e8:	f7fe fc3d 	bl	1c66 <rtc_mcp794xx_i2c_read>
    33ec:	4b12      	ldr	r3, [pc, #72]	; (3438 <mcp794xx_set_sqr_wave_enable_status+0x70>)
    33ee:	447b      	add	r3, pc
    33f0:	7018      	strb	r0, [r3, #0]
    if(err)
    33f2:	2800      	cmp	r0, #0
    33f4:	d117      	bne.n	3426 <mcp794xx_set_sqr_wave_enable_status+0x5e>
    read_status &= ~ (1 << 6);
    33f6:	466b      	mov	r3, sp
    33f8:	1dda      	adds	r2, r3, #7
    33fa:	7813      	ldrb	r3, [r2, #0]
    33fc:	2140      	movs	r1, #64	; 0x40
    33fe:	438b      	bics	r3, r1
    read_status |= (enable << 6);
    3400:	01b6      	lsls	r6, r6, #6
    3402:	431e      	orrs	r6, r3
    3404:	7016      	strb	r6, [r2, #0]
    err = rtc_mcp794xx_i2c_write(pHandle, MCP794XX_CONTROL_REG, (uint8_t *)&read_status);
    3406:	3939      	subs	r1, #57	; 0x39
    3408:	0020      	movs	r0, r4
    340a:	f7fe fc13 	bl	1c34 <rtc_mcp794xx_i2c_write>
    340e:	4a0b      	ldr	r2, [pc, #44]	; (343c <mcp794xx_set_sqr_wave_enable_status+0x74>)
    3410:	447a      	add	r2, pc
    3412:	7010      	strb	r0, [r2, #0]
    if(err)
    3414:	2800      	cmp	r0, #0
    3416:	d0e1      	beq.n	33dc <mcp794xx_set_sqr_wave_enable_status+0x14>
        a_mcp794xx_print_error_msg(pHandle, "write ctrl register");
    3418:	4909      	ldr	r1, [pc, #36]	; (3440 <mcp794xx_set_sqr_wave_enable_status+0x78>)
    341a:	4479      	add	r1, pc
    341c:	0020      	movs	r0, r4
    341e:	f7fe fc99 	bl	1d54 <a_mcp794xx_print_error_msg>
        return 1;           /**< failed error */
    3422:	0028      	movs	r0, r5
    3424:	e7da      	b.n	33dc <mcp794xx_set_sqr_wave_enable_status+0x14>
        a_mcp794xx_print_error_msg(pHandle, "read ctrl register");
    3426:	4907      	ldr	r1, [pc, #28]	; (3444 <mcp794xx_set_sqr_wave_enable_status+0x7c>)
    3428:	4479      	add	r1, pc
    342a:	0020      	movs	r0, r4
    342c:	f7fe fc92 	bl	1d54 <a_mcp794xx_print_error_msg>
        return 1;           /**< failed error */
    3430:	0028      	movs	r0, r5
    3432:	e7d3      	b.n	33dc <mcp794xx_set_sqr_wave_enable_status+0x14>
        return 2;     /**< return failed error */
    3434:	2002      	movs	r0, #2
    3436:	e7d1      	b.n	33dc <mcp794xx_set_sqr_wave_enable_status+0x14>
    3438:	1fffcef2 	.word	0x1fffcef2
    343c:	1fffced0 	.word	0x1fffced0
    3440:	000047f2 	.word	0x000047f2
    3444:	000047d0 	.word	0x000047d0

00003448 <mcp794xx_set_coarse_trim_mode_status>:
            - 2 handle null
 *          - 3 handle is not initialized
 * @note Coarse Trim mode results in the MCP7941X applying digital trimming every 64 Hz clock cycle.
 */
uint8_t mcp794xx_set_coarse_trim_mode_status(mcp794xx_handle_t *const pHandle, mcp794xx_bool_t status)
{
    3448:	b570      	push	{r4, r5, r6, lr}
    344a:	b082      	sub	sp, #8
    344c:	0004      	movs	r4, r0
    344e:	000e      	movs	r6, r1

    uint8_t read_status;

    if(pHandle == NULL)
    3450:	2800      	cmp	r0, #0
    3452:	d02f      	beq.n	34b4 <mcp794xx_set_coarse_trim_mode_status+0x6c>
        return 2;     /**< return failed error */
    if(pHandle->inited != 1)
    3454:	7fc5      	ldrb	r5, [r0, #31]
    3456:	2d01      	cmp	r5, #1
    3458:	d002      	beq.n	3460 <mcp794xx_set_coarse_trim_mode_status+0x18>
        return 3;      /**< return failed error */
    345a:	2003      	movs	r0, #3
        a_mcp794xx_print_error_msg(pHandle, "write ctrl register");
        return 1;           /**< failed error */
    }

    return 0;           /**< success */
}
    345c:	b002      	add	sp, #8
    345e:	bd70      	pop	{r4, r5, r6, pc}
    err = rtc_mcp794xx_i2c_read(pHandle, MCP794XX_CONTROL_REG, (uint8_t *)&read_status, 1);
    3460:	2301      	movs	r3, #1
    3462:	466a      	mov	r2, sp
    3464:	3207      	adds	r2, #7
    3466:	2107      	movs	r1, #7
    3468:	f7fe fbfd 	bl	1c66 <rtc_mcp794xx_i2c_read>
    346c:	4b12      	ldr	r3, [pc, #72]	; (34b8 <mcp794xx_set_coarse_trim_mode_status+0x70>)
    346e:	447b      	add	r3, pc
    3470:	7018      	strb	r0, [r3, #0]
    if(err)
    3472:	2800      	cmp	r0, #0
    3474:	d117      	bne.n	34a6 <mcp794xx_set_coarse_trim_mode_status+0x5e>
    read_status &= ~ (1 << 2);
    3476:	466b      	mov	r3, sp
    3478:	1dda      	adds	r2, r3, #7
    347a:	7813      	ldrb	r3, [r2, #0]
    347c:	2104      	movs	r1, #4
    347e:	438b      	bics	r3, r1
    read_status |= (status << 2);
    3480:	00b6      	lsls	r6, r6, #2
    3482:	431e      	orrs	r6, r3
    3484:	7016      	strb	r6, [r2, #0]
    err = rtc_mcp794xx_i2c_write(pHandle, MCP794XX_CONTROL_REG, (uint8_t *)&read_status);
    3486:	3103      	adds	r1, #3
    3488:	0020      	movs	r0, r4
    348a:	f7fe fbd3 	bl	1c34 <rtc_mcp794xx_i2c_write>
    348e:	4a0b      	ldr	r2, [pc, #44]	; (34bc <mcp794xx_set_coarse_trim_mode_status+0x74>)
    3490:	447a      	add	r2, pc
    3492:	7010      	strb	r0, [r2, #0]
    if(err)
    3494:	2800      	cmp	r0, #0
    3496:	d0e1      	beq.n	345c <mcp794xx_set_coarse_trim_mode_status+0x14>
        a_mcp794xx_print_error_msg(pHandle, "write ctrl register");
    3498:	4909      	ldr	r1, [pc, #36]	; (34c0 <mcp794xx_set_coarse_trim_mode_status+0x78>)
    349a:	4479      	add	r1, pc
    349c:	0020      	movs	r0, r4
    349e:	f7fe fc59 	bl	1d54 <a_mcp794xx_print_error_msg>
        return 1;           /**< failed error */
    34a2:	0028      	movs	r0, r5
    34a4:	e7da      	b.n	345c <mcp794xx_set_coarse_trim_mode_status+0x14>
        a_mcp794xx_print_error_msg(pHandle, "read ctrl register");
    34a6:	4907      	ldr	r1, [pc, #28]	; (34c4 <mcp794xx_set_coarse_trim_mode_status+0x7c>)
    34a8:	4479      	add	r1, pc
    34aa:	0020      	movs	r0, r4
    34ac:	f7fe fc52 	bl	1d54 <a_mcp794xx_print_error_msg>
        return 1;           /**< failed error */
    34b0:	0028      	movs	r0, r5
    34b2:	e7d3      	b.n	345c <mcp794xx_set_coarse_trim_mode_status+0x14>
        return 2;     /**< return failed error */
    34b4:	2002      	movs	r0, #2
    34b6:	e7d1      	b.n	345c <mcp794xx_set_coarse_trim_mode_status+0x14>
    34b8:	1fffce72 	.word	0x1fffce72
    34bc:	1fffce50 	.word	0x1fffce50
    34c0:	00004772 	.word	0x00004772
    34c4:	00004750 	.word	0x00004750

000034c8 <mcp794xx_set_ext_batt_enable_status>:
            - 2 handle null
 *          - 3 handle is not initialized
 *          - 4 variant not supported
 */
uint8_t  mcp794xx_set_ext_batt_enable_status(mcp794xx_handle_t *const pHandle, mcp794xx_bool_t status)
{
    34c8:	b570      	push	{r4, r5, r6, lr}
    34ca:	b082      	sub	sp, #8
    34cc:	0004      	movs	r4, r0
    34ce:	000e      	movs	r6, r1

    uint8_t read_status;

    if(pHandle == NULL)
    34d0:	2800      	cmp	r0, #0
    34d2:	d038      	beq.n	3546 <mcp794xx_set_ext_batt_enable_status+0x7e>
        return 2;     /**< return failed error */
    if(pHandle->inited != 1)
    34d4:	7fc5      	ldrb	r5, [r0, #31]
    34d6:	2d01      	cmp	r5, #1
    34d8:	d002      	beq.n	34e0 <mcp794xx_set_ext_batt_enable_status+0x18>
        return 3;      /**< return failed error */
    34da:	2003      	movs	r0, #3
        a_mcp794xx_print_error_msg(pHandle, "set external battery bckup status");
        return 1;           /**< failed error */
    }

    return 0;           /**< success */
}
    34dc:	b002      	add	sp, #8
    34de:	bd70      	pop	{r4, r5, r6, pc}
    if(pHandle->device_variant == MCP7940M_VARIANT){
    34e0:	7f83      	ldrb	r3, [r0, #30]
    34e2:	2b03      	cmp	r3, #3
    34e4:	d022      	beq.n	352c <mcp794xx_set_ext_batt_enable_status+0x64>
    err = rtc_mcp794xx_i2c_read(pHandle, MCP794XX_RTC_WKDAY_REG, (uint8_t *)&read_status, 1);
    34e6:	2301      	movs	r3, #1
    34e8:	466a      	mov	r2, sp
    34ea:	3207      	adds	r2, #7
    34ec:	2103      	movs	r1, #3
    34ee:	f7fe fbba 	bl	1c66 <rtc_mcp794xx_i2c_read>
    34f2:	4b16      	ldr	r3, [pc, #88]	; (354c <mcp794xx_set_ext_batt_enable_status+0x84>)
    34f4:	447b      	add	r3, pc
    34f6:	7018      	strb	r0, [r3, #0]
    if(err)
    34f8:	2800      	cmp	r0, #0
    34fa:	d11d      	bne.n	3538 <mcp794xx_set_ext_batt_enable_status+0x70>
    read_status &= ~ (1 << 3);
    34fc:	466b      	mov	r3, sp
    34fe:	1dda      	adds	r2, r3, #7
    3500:	7813      	ldrb	r3, [r2, #0]
    3502:	2108      	movs	r1, #8
    3504:	438b      	bics	r3, r1
    read_status |= (status << 3);
    3506:	00f6      	lsls	r6, r6, #3
    3508:	431e      	orrs	r6, r3
    350a:	7016      	strb	r6, [r2, #0]
    err = rtc_mcp794xx_i2c_write(pHandle, MCP794XX_RTC_WKDAY_REG, (uint8_t *)&read_status);
    350c:	3905      	subs	r1, #5
    350e:	0020      	movs	r0, r4
    3510:	f7fe fb90 	bl	1c34 <rtc_mcp794xx_i2c_write>
    3514:	4a0e      	ldr	r2, [pc, #56]	; (3550 <mcp794xx_set_ext_batt_enable_status+0x88>)
    3516:	447a      	add	r2, pc
    3518:	7010      	strb	r0, [r2, #0]
    if(err)
    351a:	2800      	cmp	r0, #0
    351c:	d0de      	beq.n	34dc <mcp794xx_set_ext_batt_enable_status+0x14>
        a_mcp794xx_print_error_msg(pHandle, "set external battery bckup status");
    351e:	490d      	ldr	r1, [pc, #52]	; (3554 <mcp794xx_set_ext_batt_enable_status+0x8c>)
    3520:	4479      	add	r1, pc
    3522:	0020      	movs	r0, r4
    3524:	f7fe fc16 	bl	1d54 <a_mcp794xx_print_error_msg>
        return 1;           /**< failed error */
    3528:	0028      	movs	r0, r5
    352a:	e7d7      	b.n	34dc <mcp794xx_set_ext_batt_enable_status+0x14>
         a_mcp794xx_print_error_msg(pHandle, "set external battery bckup, not supported for the mcp7940M variant");
    352c:	490a      	ldr	r1, [pc, #40]	; (3558 <mcp794xx_set_ext_batt_enable_status+0x90>)
    352e:	4479      	add	r1, pc
    3530:	f7fe fc10 	bl	1d54 <a_mcp794xx_print_error_msg>
        return 4;
    3534:	2004      	movs	r0, #4
    3536:	e7d1      	b.n	34dc <mcp794xx_set_ext_batt_enable_status+0x14>
        a_mcp794xx_print_error_msg(pHandle, "set external battery bckup");
    3538:	4908      	ldr	r1, [pc, #32]	; (355c <mcp794xx_set_ext_batt_enable_status+0x94>)
    353a:	4479      	add	r1, pc
    353c:	0020      	movs	r0, r4
    353e:	f7fe fc09 	bl	1d54 <a_mcp794xx_print_error_msg>
        return 1;           /**< failed error */
    3542:	0028      	movs	r0, r5
    3544:	e7ca      	b.n	34dc <mcp794xx_set_ext_batt_enable_status+0x14>
        return 2;     /**< return failed error */
    3546:	2002      	movs	r0, #2
    3548:	e7c8      	b.n	34dc <mcp794xx_set_ext_batt_enable_status+0x14>
    354a:	46c0      	nop			; (mov r8, r8)
    354c:	1fffcdec 	.word	0x1fffcdec
    3550:	1fffcdca 	.word	0x1fffcdca
    3554:	000047d0 	.word	0x000047d0
    3558:	00004762 	.word	0x00004762
    355c:	0000479a 	.word	0x0000479a

00003560 <mcp794xx_set_ext_osc_enable_status>:
 *          - 1 failed
            - 2 handle null
 *          - 3 handle is not initialized
 */
uint8_t mcp794xx_set_ext_osc_enable_status(mcp794xx_handle_t *const pHandle, mcp794xx_osc_status_t status)
{
    3560:	b570      	push	{r4, r5, r6, lr}
    3562:	b082      	sub	sp, #8
    3564:	0004      	movs	r4, r0
    3566:	000e      	movs	r6, r1

    uint8_t read_status;

    if(pHandle == NULL)
    3568:	2800      	cmp	r0, #0
    356a:	d02f      	beq.n	35cc <mcp794xx_set_ext_osc_enable_status+0x6c>
        return 2;     /**< return failed error */
    if(pHandle->inited != 1)
    356c:	7fc5      	ldrb	r5, [r0, #31]
    356e:	2d01      	cmp	r5, #1
    3570:	d002      	beq.n	3578 <mcp794xx_set_ext_osc_enable_status+0x18>
        return 3;      /**< return failed error */
    3572:	2003      	movs	r0, #3
        a_mcp794xx_print_error_msg(pHandle, "set external oscillator");
        return 1;           /**< failed error */
    }

    return 0;           /**< success */
}
    3574:	b002      	add	sp, #8
    3576:	bd70      	pop	{r4, r5, r6, pc}
    err = rtc_mcp794xx_i2c_read(pHandle, MCP794XX_CONTROL_REG, (uint8_t *)&read_status, 1);
    3578:	2301      	movs	r3, #1
    357a:	466a      	mov	r2, sp
    357c:	3207      	adds	r2, #7
    357e:	2107      	movs	r1, #7
    3580:	f7fe fb71 	bl	1c66 <rtc_mcp794xx_i2c_read>
    3584:	4b12      	ldr	r3, [pc, #72]	; (35d0 <mcp794xx_set_ext_osc_enable_status+0x70>)
    3586:	447b      	add	r3, pc
    3588:	7018      	strb	r0, [r3, #0]
    if(err)
    358a:	2800      	cmp	r0, #0
    358c:	d117      	bne.n	35be <mcp794xx_set_ext_osc_enable_status+0x5e>
    read_status &= ~ (1 << 3);
    358e:	466b      	mov	r3, sp
    3590:	1dda      	adds	r2, r3, #7
    3592:	7813      	ldrb	r3, [r2, #0]
    3594:	2108      	movs	r1, #8
    3596:	438b      	bics	r3, r1
    read_status |= (status << 3);
    3598:	00f6      	lsls	r6, r6, #3
    359a:	431e      	orrs	r6, r3
    359c:	7016      	strb	r6, [r2, #0]
    err = rtc_mcp794xx_i2c_write(pHandle, MCP794XX_CONTROL_REG, (uint8_t *)&read_status);
    359e:	3901      	subs	r1, #1
    35a0:	0020      	movs	r0, r4
    35a2:	f7fe fb47 	bl	1c34 <rtc_mcp794xx_i2c_write>
    35a6:	4a0b      	ldr	r2, [pc, #44]	; (35d4 <mcp794xx_set_ext_osc_enable_status+0x74>)
    35a8:	447a      	add	r2, pc
    35aa:	7010      	strb	r0, [r2, #0]
    if(err)
    35ac:	2800      	cmp	r0, #0
    35ae:	d0e1      	beq.n	3574 <mcp794xx_set_ext_osc_enable_status+0x14>
        a_mcp794xx_print_error_msg(pHandle, "set external oscillator");
    35b0:	4909      	ldr	r1, [pc, #36]	; (35d8 <mcp794xx_set_ext_osc_enable_status+0x78>)
    35b2:	4479      	add	r1, pc
    35b4:	0020      	movs	r0, r4
    35b6:	f7fe fbcd 	bl	1d54 <a_mcp794xx_print_error_msg>
        return 1;           /**< failed error */
    35ba:	0028      	movs	r0, r5
    35bc:	e7da      	b.n	3574 <mcp794xx_set_ext_osc_enable_status+0x14>
        a_mcp794xx_print_error_msg(pHandle, "set external oscillator");
    35be:	4907      	ldr	r1, [pc, #28]	; (35dc <mcp794xx_set_ext_osc_enable_status+0x7c>)
    35c0:	4479      	add	r1, pc
    35c2:	0020      	movs	r0, r4
    35c4:	f7fe fbc6 	bl	1d54 <a_mcp794xx_print_error_msg>
        return 1;           /**< failed error */
    35c8:	0028      	movs	r0, r5
    35ca:	e7d3      	b.n	3574 <mcp794xx_set_ext_osc_enable_status+0x14>
        return 2;     /**< return failed error */
    35cc:	2002      	movs	r0, #2
    35ce:	e7d1      	b.n	3574 <mcp794xx_set_ext_osc_enable_status+0x14>
    35d0:	1fffcd5a 	.word	0x1fffcd5a
    35d4:	1fffcd38 	.word	0x1fffcd38
    35d8:	00004786 	.word	0x00004786
    35dc:	00004778 	.word	0x00004778

000035e0 <mcp794xx_set_osc_start_bit>:
 *            - 2 pHandle is NULL
 *            - 3 pHandle is not initialized
 * @note      none
 */
uint8_t mcp794xx_set_osc_start_bit(mcp794xx_handle_t *const pHandle, mcp794xx_bool_t status)
{
    35e0:	b570      	push	{r4, r5, r6, lr}
    35e2:	b082      	sub	sp, #8
    35e4:	0004      	movs	r4, r0
    35e6:	000e      	movs	r6, r1
    uint8_t read_status;

    if(pHandle == NULL)
    35e8:	2800      	cmp	r0, #0
    35ea:	d02f      	beq.n	364c <mcp794xx_set_osc_start_bit+0x6c>
        return 2;     /**< return failed error */
    if(pHandle->inited != 1)
    35ec:	7fc5      	ldrb	r5, [r0, #31]
    35ee:	2d01      	cmp	r5, #1
    35f0:	d002      	beq.n	35f8 <mcp794xx_set_osc_start_bit+0x18>
        return 3;      /**< return failed error */
    35f2:	2003      	movs	r0, #3
    {
        a_mcp794xx_print_error_msg(pHandle, "set osc start bit");
        return 1;           /**< failed error */
    }
     return 0;  /**< success */
}
    35f4:	b002      	add	sp, #8
    35f6:	bd70      	pop	{r4, r5, r6, pc}
    err = rtc_mcp794xx_i2c_read(pHandle, MCP794XX_RTC_SECOND_REG, (uint8_t *)&read_status, 1);
    35f8:	2301      	movs	r3, #1
    35fa:	466a      	mov	r2, sp
    35fc:	3207      	adds	r2, #7
    35fe:	2100      	movs	r1, #0
    3600:	f7fe fb31 	bl	1c66 <rtc_mcp794xx_i2c_read>
    3604:	4b12      	ldr	r3, [pc, #72]	; (3650 <mcp794xx_set_osc_start_bit+0x70>)
    3606:	447b      	add	r3, pc
    3608:	7018      	strb	r0, [r3, #0]
    if(err)
    360a:	2800      	cmp	r0, #0
    360c:	d117      	bne.n	363e <mcp794xx_set_osc_start_bit+0x5e>
    read_status &= ~ (1 << 7);
    360e:	466b      	mov	r3, sp
    3610:	1dda      	adds	r2, r3, #7
    3612:	7811      	ldrb	r1, [r2, #0]
    3614:	237f      	movs	r3, #127	; 0x7f
    3616:	400b      	ands	r3, r1
    read_status |= (status << 7);
    3618:	01f6      	lsls	r6, r6, #7
    361a:	431e      	orrs	r6, r3
    361c:	7016      	strb	r6, [r2, #0]
    err = rtc_mcp794xx_i2c_write(pHandle, MCP794XX_RTC_SECOND_REG, (uint8_t *)&read_status);
    361e:	2100      	movs	r1, #0
    3620:	0020      	movs	r0, r4
    3622:	f7fe fb07 	bl	1c34 <rtc_mcp794xx_i2c_write>
    3626:	4a0b      	ldr	r2, [pc, #44]	; (3654 <mcp794xx_set_osc_start_bit+0x74>)
    3628:	447a      	add	r2, pc
    362a:	7010      	strb	r0, [r2, #0]
    if(err)
    362c:	2800      	cmp	r0, #0
    362e:	d0e1      	beq.n	35f4 <mcp794xx_set_osc_start_bit+0x14>
        a_mcp794xx_print_error_msg(pHandle, "set osc start bit");
    3630:	4909      	ldr	r1, [pc, #36]	; (3658 <mcp794xx_set_osc_start_bit+0x78>)
    3632:	4479      	add	r1, pc
    3634:	0020      	movs	r0, r4
    3636:	f7fe fb8d 	bl	1d54 <a_mcp794xx_print_error_msg>
        return 1;           /**< failed error */
    363a:	0028      	movs	r0, r5
    363c:	e7da      	b.n	35f4 <mcp794xx_set_osc_start_bit+0x14>
        a_mcp794xx_print_error_msg(pHandle, "set osc start bit");
    363e:	4907      	ldr	r1, [pc, #28]	; (365c <mcp794xx_set_osc_start_bit+0x7c>)
    3640:	4479      	add	r1, pc
    3642:	0020      	movs	r0, r4
    3644:	f7fe fb86 	bl	1d54 <a_mcp794xx_print_error_msg>
        return 1;           /**< failed error */
    3648:	0028      	movs	r0, r5
    364a:	e7d3      	b.n	35f4 <mcp794xx_set_osc_start_bit+0x14>
        return 2;     /**< return failed error */
    364c:	2002      	movs	r0, #2
    364e:	e7d1      	b.n	35f4 <mcp794xx_set_osc_start_bit+0x14>
    3650:	1fffccda 	.word	0x1fffccda
    3654:	1fffccb8 	.word	0x1fffccb8
    3658:	0000473a 	.word	0x0000473a
    365c:	0000472c 	.word	0x0000472c

00003660 <mcp794xx_read_epoch_unix_time_stamp>:
 *            - 2 pHandle is NULL
 *            - 3 pHandle is not initialized
 * @note      This function will fail to execute from January 19, 2038
 */
uint8_t mcp794xx_read_epoch_unix_time_stamp(mcp794xx_handle_t *const pHandle, mcp794xx_time_t *pTime, uint32_t *pEpoch_time)
{
    3660:	b5f0      	push	{r4, r5, r6, r7, lr}
	 uint8_t num_years,num_months,num_days = 0;
     uint32_t total_days_from_years = 0;
     uint32_t total_days_from_months = 0;
     uint32_t total_num_days = 0;

    if(pHandle == NULL)
    3662:	2800      	cmp	r0, #0
    3664:	d038      	beq.n	36d8 <mcp794xx_read_epoch_unix_time_stamp+0x78>
        return 2;     /**< return failed error */
    if(pHandle->inited != 1)
    3666:	7fc3      	ldrb	r3, [r0, #31]
    3668:	2b01      	cmp	r3, #1
    366a:	d001      	beq.n	3670 <mcp794xx_read_epoch_unix_time_stamp+0x10>
        return 3;      /**< return failed error */
    366c:	2003      	movs	r0, #3
    total_num_days = (total_days_from_years + total_days_from_months + num_days) - 1;                     /**< calculate total number of days since 1 January 1970 */

    *pEpoch_time = total_num_days * 86400 + pTime->hour * 3600 + pTime->minute * 60 + pTime->second;      /**< calculate number of seconds from current time and date */

	return 0;   /**< success */
}
    366e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    num_years = pTime->year - 1970;   /**< number years since 1970*/
    3670:	780d      	ldrb	r5, [r1, #0]
    3672:	354e      	adds	r5, #78	; 0x4e
    3674:	b2ed      	uxtb	r5, r5
    num_months = pTime->month - 1;    /**< number of months from January */
    3676:	798e      	ldrb	r6, [r1, #6]
    3678:	3e01      	subs	r6, #1
    367a:	b2f6      	uxtb	r6, r6
    num_days = pTime->date - 1;		  /**< number of days since the 1st of the current month*/
    367c:	7888      	ldrb	r0, [r1, #2]
    367e:	3801      	subs	r0, #1
    3680:	b2c7      	uxtb	r7, r0
    for(int index = 0; index < num_years; index++)
    3682:	2300      	movs	r3, #0
     uint32_t total_days_from_years = 0;
    3684:	2400      	movs	r4, #0
    for(int index = 0; index < num_years; index++)
    3686:	e002      	b.n	368e <mcp794xx_read_epoch_unix_time_stamp+0x2e>
    		total_days_from_years += 366;
    3688:	346f      	adds	r4, #111	; 0x6f
    368a:	34ff      	adds	r4, #255	; 0xff
    for(int index = 0; index < num_years; index++)
    368c:	3301      	adds	r3, #1
    368e:	42ab      	cmp	r3, r5
    3690:	da04      	bge.n	369c <mcp794xx_read_epoch_unix_time_stamp+0x3c>
    	if(index % 4)
    3692:	0798      	lsls	r0, r3, #30
    3694:	d0f8      	beq.n	3688 <mcp794xx_read_epoch_unix_time_stamp+0x28>
    		total_days_from_years += 365;
    3696:	346e      	adds	r4, #110	; 0x6e
    3698:	34ff      	adds	r4, #255	; 0xff
    369a:	e7f7      	b.n	368c <mcp794xx_read_epoch_unix_time_stamp+0x2c>
    369c:	2300      	movs	r3, #0
    369e:	2000      	movs	r0, #0
    36a0:	e004      	b.n	36ac <mcp794xx_read_epoch_unix_time_stamp+0x4c>
       total_days_from_months += days_in_month[index];
    36a2:	4d0e      	ldr	r5, [pc, #56]	; (36dc <mcp794xx_read_epoch_unix_time_stamp+0x7c>)
    36a4:	447d      	add	r5, pc
    36a6:	5ced      	ldrb	r5, [r5, r3]
    36a8:	1940      	adds	r0, r0, r5
    for(int index = 0; index < num_months; index++)
    36aa:	3301      	adds	r3, #1
    36ac:	42b3      	cmp	r3, r6
    36ae:	dbf8      	blt.n	36a2 <mcp794xx_read_epoch_unix_time_stamp+0x42>
    total_num_days = (total_days_from_years + total_days_from_months + num_days) - 1;                     /**< calculate total number of days since 1 January 1970 */
    36b0:	1820      	adds	r0, r4, r0
    36b2:	1838      	adds	r0, r7, r0
    36b4:	3801      	subs	r0, #1
    *pEpoch_time = total_num_days * 86400 + pTime->hour * 3600 + pTime->minute * 60 + pTime->second;      /**< calculate number of seconds from current time and date */
    36b6:	4b0a      	ldr	r3, [pc, #40]	; (36e0 <mcp794xx_read_epoch_unix_time_stamp+0x80>)
    36b8:	4343      	muls	r3, r0
    36ba:	78cc      	ldrb	r4, [r1, #3]
    36bc:	20e1      	movs	r0, #225	; 0xe1
    36be:	0100      	lsls	r0, r0, #4
    36c0:	4360      	muls	r0, r4
    36c2:	181b      	adds	r3, r3, r0
    36c4:	790c      	ldrb	r4, [r1, #4]
    36c6:	0120      	lsls	r0, r4, #4
    36c8:	1b00      	subs	r0, r0, r4
    36ca:	0084      	lsls	r4, r0, #2
    36cc:	191b      	adds	r3, r3, r4
    36ce:	7949      	ldrb	r1, [r1, #5]
    36d0:	185b      	adds	r3, r3, r1
    36d2:	6013      	str	r3, [r2, #0]
	return 0;   /**< success */
    36d4:	2000      	movs	r0, #0
    36d6:	e7ca      	b.n	366e <mcp794xx_read_epoch_unix_time_stamp+0xe>
        return 2;     /**< return failed error */
    36d8:	2002      	movs	r0, #2
    36da:	e7c8      	b.n	366e <mcp794xx_read_epoch_unix_time_stamp+0xe>
    36dc:	00003934 	.word	0x00003934
    36e0:	00015180 	.word	0x00015180

000036e4 <mcp794xx_convert_epoch_unix_time_stamp>:
 *            - 2 pHandle is NULL
 *            - 3 pHandle is not initialized
 * @note      This function will fail to execute from January 19, 2038
 */
uint8_t mcp794xx_convert_epoch_unix_time_stamp(mcp794xx_handle_t *const pHandle, uint32_t u32Epoch_time, mcp794xx_time_t *pTime_out)
{
    36e4:	b5f0      	push	{r4, r5, r6, r7, lr}
    36e6:	46c6      	mov	lr, r8
    36e8:	b500      	push	{lr}
    36ea:	000c      	movs	r4, r1
    36ec:	0015      	movs	r5, r2
    uint32_t sec_of_day;
    uint16_t num_days;

	if(pHandle == NULL)
    36ee:	2800      	cmp	r0, #0
    36f0:	d100      	bne.n	36f4 <mcp794xx_convert_epoch_unix_time_stamp+0x10>
    36f2:	e0bd      	b.n	3870 <mcp794xx_convert_epoch_unix_time_stamp+0x18c>
	return 2;     /**< return failed error */
	if(pHandle->inited != 1)
    36f4:	7fc3      	ldrb	r3, [r0, #31]
    36f6:	2b01      	cmp	r3, #1
    36f8:	d003      	beq.n	3702 <mcp794xx_convert_epoch_unix_time_stamp+0x1e>
	return 3;      /**< return failed error */
    36fa:	2003      	movs	r0, #3
//		a_mcp794xx_print_error_msg(pHandle, "convert epoch time to human readable time");
//		return 1;						/**< failed */
//	}

    return 0;							/**< success */
}
    36fc:	bc04      	pop	{r2}
    36fe:	4690      	mov	r8, r2
    3700:	bdf0      	pop	{r4, r5, r6, r7, pc}
    sec_of_day = u32Epoch_time % (24 * 60 * 60);
    3702:	495c      	ldr	r1, [pc, #368]	; (3874 <mcp794xx_convert_epoch_unix_time_stamp+0x190>)
    3704:	0020      	movs	r0, r4
    3706:	f001 fadb 	bl	4cc0 <__aeabi_uidivmod>
    370a:	000e      	movs	r6, r1
    pTime_out->hour       = sec_of_day / (60 * 60);
    370c:	21e1      	movs	r1, #225	; 0xe1
    370e:	0109      	lsls	r1, r1, #4
    3710:	0030      	movs	r0, r6
    3712:	f001 fa4f 	bl	4bb4 <__udivsi3>
    3716:	70e8      	strb	r0, [r5, #3]
    pTime_out->minute     = sec_of_day % (60 * 60) / 60;
    3718:	21e1      	movs	r1, #225	; 0xe1
    371a:	0109      	lsls	r1, r1, #4
    371c:	0030      	movs	r0, r6
    371e:	f001 facf 	bl	4cc0 <__aeabi_uidivmod>
    3722:	0008      	movs	r0, r1
    3724:	213c      	movs	r1, #60	; 0x3c
    3726:	f001 fa45 	bl	4bb4 <__udivsi3>
    372a:	7128      	strb	r0, [r5, #4]
    pTime_out->second     = u32Epoch_time % 60;
    372c:	213c      	movs	r1, #60	; 0x3c
    372e:	0020      	movs	r0, r4
    3730:	f001 fac6 	bl	4cc0 <__aeabi_uidivmod>
    3734:	7169      	strb	r1, [r5, #5]
    num_days = (u32Epoch_time - SECONDS_FROM_Y1970_TO_Y2000) / 86400;
    3736:	4b50      	ldr	r3, [pc, #320]	; (3878 <mcp794xx_convert_epoch_unix_time_stamp+0x194>)
    3738:	18e0      	adds	r0, r4, r3
    373a:	494e      	ldr	r1, [pc, #312]	; (3874 <mcp794xx_convert_epoch_unix_time_stamp+0x190>)
    373c:	f001 fa3a 	bl	4bb4 <__udivsi3>
    3740:	b280      	uxth	r0, r0
    num_days += 1401;           			/**< move starting point to 1996-03-01 */
    3742:	4b4e      	ldr	r3, [pc, #312]	; (387c <mcp794xx_convert_epoch_unix_time_stamp+0x198>)
    3744:	469c      	mov	ip, r3
    3746:	4460      	add	r0, ip
    3748:	b284      	uxth	r4, r0
    pTime_out->year = (num_days/1461)*4;    /**< take care of 4-year intervals */
    374a:	494d      	ldr	r1, [pc, #308]	; (3880 <mcp794xx_convert_epoch_unix_time_stamp+0x19c>)
    374c:	0020      	movs	r0, r4
    374e:	f001 fa31 	bl	4bb4 <__udivsi3>
    3752:	0080      	lsls	r0, r0, #2
    3754:	b286      	uxth	r6, r0
    3756:	802e      	strh	r6, [r5, #0]
    num_days%=1461; 						/**< max 3 years 365 days (not 4 years!) remaining */
    3758:	4949      	ldr	r1, [pc, #292]	; (3880 <mcp794xx_convert_epoch_unix_time_stamp+0x19c>)
    375a:	0020      	movs	r0, r4
    375c:	f001 fab0 	bl	4cc0 <__aeabi_uidivmod>
    3760:	b289      	uxth	r1, r1
    if (num_days>=730) {num_days-=730; pTime_out->year+=2;} /**< 2 years */
    3762:	4b48      	ldr	r3, [pc, #288]	; (3884 <mcp794xx_convert_epoch_unix_time_stamp+0x1a0>)
    3764:	4299      	cmp	r1, r3
    3766:	d905      	bls.n	3774 <mcp794xx_convert_epoch_unix_time_stamp+0x90>
    3768:	4b47      	ldr	r3, [pc, #284]	; (3888 <mcp794xx_convert_epoch_unix_time_stamp+0x1a4>)
    376a:	469c      	mov	ip, r3
    376c:	4461      	add	r1, ip
    376e:	b289      	uxth	r1, r1
    3770:	3602      	adds	r6, #2
    3772:	802e      	strh	r6, [r5, #0]
    if (num_days>=365) {num_days-=365; pTime_out->year++;}  /**< 1 year */
    3774:	23b6      	movs	r3, #182	; 0xb6
    3776:	005b      	lsls	r3, r3, #1
    3778:	4299      	cmp	r1, r3
    377a:	d905      	bls.n	3788 <mcp794xx_convert_epoch_unix_time_stamp+0xa4>
    377c:	396e      	subs	r1, #110	; 0x6e
    377e:	39ff      	subs	r1, #255	; 0xff
    3780:	b289      	uxth	r1, r1
    3782:	882b      	ldrh	r3, [r5, #0]
    3784:	3301      	adds	r3, #1
    3786:	802b      	strh	r3, [r5, #0]
    pTime_out->month = 3; 									/**< get started on the month */
    3788:	2303      	movs	r3, #3
    378a:	71ab      	strb	r3, [r5, #6]
    if (num_days>=306) {num_days-=306; pTime_out->year++; pTime_out->month=1;}  /**< for Jan. and Feb. */
    378c:	2332      	movs	r3, #50	; 0x32
    378e:	33ff      	adds	r3, #255	; 0xff
    3790:	4299      	cmp	r1, r3
    3792:	d95e      	bls.n	3852 <mcp794xx_convert_epoch_unix_time_stamp+0x16e>
    3794:	3933      	subs	r1, #51	; 0x33
    3796:	39ff      	subs	r1, #255	; 0xff
    3798:	b289      	uxth	r1, r1
    379a:	882b      	ldrh	r3, [r5, #0]
    379c:	3301      	adds	r3, #1
    379e:	802b      	strh	r3, [r5, #0]
    37a0:	2301      	movs	r3, #1
    37a2:	71ab      	strb	r3, [r5, #6]
    if (num_days>=122) {num_days-=122; pTime_out->month+=4;} 					/**< here, 122 days mean 4 months */
    37a4:	2979      	cmp	r1, #121	; 0x79
    37a6:	d95b      	bls.n	3860 <mcp794xx_convert_epoch_unix_time_stamp+0x17c>
    37a8:	397a      	subs	r1, #122	; 0x7a
    37aa:	b289      	uxth	r1, r1
    37ac:	79ab      	ldrb	r3, [r5, #6]
    37ae:	3304      	adds	r3, #4
    37b0:	71ab      	strb	r3, [r5, #6]
    if (num_days>=31) {num_days-=31; pTime_out->month++;} 						/**< 31 days means exactly 1 month */
    37b2:	291e      	cmp	r1, #30
    37b4:	d904      	bls.n	37c0 <mcp794xx_convert_epoch_unix_time_stamp+0xdc>
    37b6:	391f      	subs	r1, #31
    37b8:	b289      	uxth	r1, r1
    37ba:	79ab      	ldrb	r3, [r5, #6]
    37bc:	3301      	adds	r3, #1
    37be:	71ab      	strb	r3, [r5, #6]
    pTime_out->date = num_days + 1; 											/**< get the day of the month */
    37c0:	3101      	adds	r1, #1
    37c2:	b2cc      	uxtb	r4, r1
    37c4:	70ac      	strb	r4, [r5, #2]
    pTime_out->year+=(2000 - 4); 												/**< make y be 0 for AD 2000 */
    37c6:	882e      	ldrh	r6, [r5, #0]
    37c8:	4b30      	ldr	r3, [pc, #192]	; (388c <mcp794xx_convert_epoch_unix_time_stamp+0x1a8>)
    37ca:	469c      	mov	ip, r3
    37cc:	4466      	add	r6, ip
    37ce:	b2b6      	uxth	r6, r6
    37d0:	802e      	strh	r6, [r5, #0]
    pTime_out->weekDay = ((pTime_out->date + ((153 * (pTime_out->month + 12 * ((14 - pTime_out->month) / 12) - 3) + 2) / 5)
    37d2:	79ab      	ldrb	r3, [r5, #6]
    37d4:	4698      	mov	r8, r3
    37d6:	270e      	movs	r7, #14
    37d8:	1aff      	subs	r7, r7, r3
    37da:	210c      	movs	r1, #12
    37dc:	0038      	movs	r0, r7
    37de:	f001 fa73 	bl	4cc8 <__divsi3>
    37e2:	0043      	lsls	r3, r0, #1
    37e4:	1818      	adds	r0, r3, r0
    37e6:	0083      	lsls	r3, r0, #2
    37e8:	4443      	add	r3, r8
    37ea:	3b03      	subs	r3, #3
    37ec:	00d8      	lsls	r0, r3, #3
    37ee:	18c0      	adds	r0, r0, r3
    37f0:	0103      	lsls	r3, r0, #4
    37f2:	18c0      	adds	r0, r0, r3
    37f4:	3002      	adds	r0, #2
    37f6:	2105      	movs	r1, #5
    37f8:	f001 fa66 	bl	4cc8 <__divsi3>
    37fc:	1824      	adds	r4, r4, r0
               + (365 * (pTime_out->year + 4800 - ((14 - pTime_out->month) / 12)))
    37fe:	2396      	movs	r3, #150	; 0x96
    3800:	015b      	lsls	r3, r3, #5
    3802:	469c      	mov	ip, r3
    3804:	4466      	add	r6, ip
    3806:	210c      	movs	r1, #12
    3808:	4249      	negs	r1, r1
    380a:	0038      	movs	r0, r7
    380c:	f001 fa5c 	bl	4cc8 <__divsi3>
    3810:	1836      	adds	r6, r6, r0
    3812:	206e      	movs	r0, #110	; 0x6e
    3814:	30ff      	adds	r0, #255	; 0xff
    3816:	4370      	muls	r0, r6
    3818:	1824      	adds	r4, r4, r0
               + ((pTime_out->year + 4800 - ((14 - pTime_out->month) / 12)) / 4)
    381a:	17f3      	asrs	r3, r6, #31
    381c:	2003      	movs	r0, #3
    381e:	4018      	ands	r0, r3
    3820:	1980      	adds	r0, r0, r6
    3822:	1080      	asrs	r0, r0, #2
    3824:	1824      	adds	r4, r4, r0
               - ((pTime_out->year + 4800 - ((14 - pTime_out->month) / 12)) / 100)
    3826:	2164      	movs	r1, #100	; 0x64
    3828:	4249      	negs	r1, r1
    382a:	0030      	movs	r0, r6
    382c:	f001 fa4c 	bl	4cc8 <__divsi3>
    3830:	1824      	adds	r4, r4, r0
               + ((pTime_out->year + 4800 - ((14 - pTime_out->month) / 12)) / 400)
    3832:	21c8      	movs	r1, #200	; 0xc8
    3834:	0049      	lsls	r1, r1, #1
    3836:	0030      	movs	r0, r6
    3838:	f001 fa46 	bl	4cc8 <__divsi3>
    383c:	1820      	adds	r0, r4, r0
               - 32045)
    383e:	4b14      	ldr	r3, [pc, #80]	; (3890 <mcp794xx_convert_epoch_unix_time_stamp+0x1ac>)
    3840:	469c      	mov	ip, r3
    3842:	4460      	add	r0, ip
        % 7) + 2;
    3844:	2107      	movs	r1, #7
    3846:	f001 fb25 	bl	4e94 <__aeabi_idivmod>
    384a:	3102      	adds	r1, #2
    pTime_out->weekDay = ((pTime_out->date + ((153 * (pTime_out->month + 12 * ((14 - pTime_out->month) / 12) - 3) + 2) / 5)
    384c:	71e9      	strb	r1, [r5, #7]
    return 0;							/**< success */
    384e:	2000      	movs	r0, #0
    3850:	e754      	b.n	36fc <mcp794xx_convert_epoch_unix_time_stamp+0x18>
    else if (num_days>=153) {num_days-=153; pTime_out->month=8;} 				/**< for Aug. thru Dec. */
    3852:	2998      	cmp	r1, #152	; 0x98
    3854:	d9a6      	bls.n	37a4 <mcp794xx_convert_epoch_unix_time_stamp+0xc0>
    3856:	3999      	subs	r1, #153	; 0x99
    3858:	b289      	uxth	r1, r1
    385a:	2308      	movs	r3, #8
    385c:	71ab      	strb	r3, [r5, #6]
    385e:	e7a1      	b.n	37a4 <mcp794xx_convert_epoch_unix_time_stamp+0xc0>
    else if (num_days>=61) {num_days-=61; pTime_out->month+=2;} 				/**< 61 days mean 2 months */
    3860:	293c      	cmp	r1, #60	; 0x3c
    3862:	d9a6      	bls.n	37b2 <mcp794xx_convert_epoch_unix_time_stamp+0xce>
    3864:	393d      	subs	r1, #61	; 0x3d
    3866:	b289      	uxth	r1, r1
    3868:	79ab      	ldrb	r3, [r5, #6]
    386a:	3302      	adds	r3, #2
    386c:	71ab      	strb	r3, [r5, #6]
    386e:	e7a0      	b.n	37b2 <mcp794xx_convert_epoch_unix_time_stamp+0xce>
	return 2;     /**< return failed error */
    3870:	2002      	movs	r0, #2
    3872:	e743      	b.n	36fc <mcp794xx_convert_epoch_unix_time_stamp+0x18>
    3874:	00015180 	.word	0x00015180
    3878:	c792bc80 	.word	0xc792bc80
    387c:	00000579 	.word	0x00000579
    3880:	000005b5 	.word	0x000005b5
    3884:	000002d9 	.word	0x000002d9
    3888:	fffffd26 	.word	0xfffffd26
    388c:	000007cc 	.word	0x000007cc
    3890:	ffff82d3 	.word	0xffff82d3

00003894 <mcp794xx_get_compile_time_date>:
 *             - 2 handle or time is NULL
 *             - 3 handle is not initialized
 * @note       this function returns time in 24Hr format
 */
uint8_t mcp794xx_get_compile_time_date(mcp794xx_handle_t *const pHandle, char *pCompile_time_date, mcp794xx_time_t *pTime)
{
    3894:	b530      	push	{r4, r5, lr}
    3896:	b089      	sub	sp, #36	; 0x24
    3898:	0014      	movs	r4, r2
    char year_string[3], month_string[3], date_string[3], week_day_string[1], hour_string[3], minute_string[3], second_string[3];
    uint32_t epoch_time;
    uint8_t sec_offset = 15;      /**< this is an offset time to compensate lost seconds during compiling and programming the device,
    									purely depends on how fast your computer does the job */

    if(pHandle == NULL)
    389a:	2800      	cmp	r0, #0
    389c:	d100      	bne.n	38a0 <mcp794xx_get_compile_time_date+0xc>
    389e:	e0f7      	b.n	3a90 <mcp794xx_get_compile_time_date+0x1fc>
        return 2;     /**< return failed error */
    if(pHandle->inited != 1)
    38a0:	7fc3      	ldrb	r3, [r0, #31]
    38a2:	2b01      	cmp	r3, #1
    38a4:	d002      	beq.n	38ac <mcp794xx_get_compile_time_date+0x18>
        return 3;      /**< return failed error */
    38a6:	2003      	movs	r0, #3
			pTime->minute = 0;
		}
	}

    return 0;
}
    38a8:	b009      	add	sp, #36	; 0x24
    38aa:	bd30      	pop	{r4, r5, pc}
    year_string[0] = BUILD_YEAR_CH2(pCompile_time_date);
    38ac:	7d8a      	ldrb	r2, [r1, #22]
    38ae:	ab07      	add	r3, sp, #28
    38b0:	701a      	strb	r2, [r3, #0]
    year_string[1] = BUILD_YEAR_CH3(pCompile_time_date);
    38b2:	7dca      	ldrb	r2, [r1, #23]
    38b4:	705a      	strb	r2, [r3, #1]
    month_string[0] = BUILD_MONTH_CH0(pCompile_time_date);
    38b6:	790b      	ldrb	r3, [r1, #4]
    38b8:	001a      	movs	r2, r3
    38ba:	3a4e      	subs	r2, #78	; 0x4e
    38bc:	b2d2      	uxtb	r2, r2
    38be:	2a01      	cmp	r2, #1
    38c0:	d920      	bls.n	3904 <mcp794xx_get_compile_time_date+0x70>
    38c2:	2b44      	cmp	r3, #68	; 0x44
    38c4:	d01c      	beq.n	3900 <mcp794xx_get_compile_time_date+0x6c>
    38c6:	2030      	movs	r0, #48	; 0x30
    38c8:	aa06      	add	r2, sp, #24
    38ca:	7010      	strb	r0, [r2, #0]
    month_string[1] = BUILD_MONTH_CH1(pCompile_time_date);
    38cc:	2b4a      	cmp	r3, #74	; 0x4a
    38ce:	d01b      	beq.n	3908 <mcp794xx_get_compile_time_date+0x74>
    38d0:	2b46      	cmp	r3, #70	; 0x46
    38d2:	d04d      	beq.n	3970 <mcp794xx_get_compile_time_date+0xdc>
    38d4:	2b4d      	cmp	r3, #77	; 0x4d
    38d6:	d01f      	beq.n	3918 <mcp794xx_get_compile_time_date+0x84>
    38d8:	2b41      	cmp	r3, #65	; 0x41
    38da:	d025      	beq.n	3928 <mcp794xx_get_compile_time_date+0x94>
    38dc:	2b4d      	cmp	r3, #77	; 0x4d
    38de:	d028      	beq.n	3932 <mcp794xx_get_compile_time_date+0x9e>
    38e0:	2b4a      	cmp	r3, #74	; 0x4a
    38e2:	d02e      	beq.n	3942 <mcp794xx_get_compile_time_date+0xae>
    38e4:	2b4a      	cmp	r3, #74	; 0x4a
    38e6:	d034      	beq.n	3952 <mcp794xx_get_compile_time_date+0xbe>
    38e8:	2b41      	cmp	r3, #65	; 0x41
    38ea:	d03a      	beq.n	3962 <mcp794xx_get_compile_time_date+0xce>
    38ec:	2b53      	cmp	r3, #83	; 0x53
    38ee:	d06b      	beq.n	39c8 <mcp794xx_get_compile_time_date+0x134>
    38f0:	2b4f      	cmp	r3, #79	; 0x4f
    38f2:	d06b      	beq.n	39cc <mcp794xx_get_compile_time_date+0x138>
    38f4:	2b4e      	cmp	r3, #78	; 0x4e
    38f6:	d06b      	beq.n	39d0 <mcp794xx_get_compile_time_date+0x13c>
    38f8:	2b44      	cmp	r3, #68	; 0x44
    38fa:	d037      	beq.n	396c <mcp794xx_get_compile_time_date+0xd8>
    38fc:	223f      	movs	r2, #63	; 0x3f
    38fe:	e038      	b.n	3972 <mcp794xx_get_compile_time_date+0xde>
    month_string[0] = BUILD_MONTH_CH0(pCompile_time_date);
    3900:	2031      	movs	r0, #49	; 0x31
    3902:	e7e1      	b.n	38c8 <mcp794xx_get_compile_time_date+0x34>
    3904:	2031      	movs	r0, #49	; 0x31
    3906:	e7df      	b.n	38c8 <mcp794xx_get_compile_time_date+0x34>
    month_string[1] = BUILD_MONTH_CH1(pCompile_time_date);
    3908:	794a      	ldrb	r2, [r1, #5]
    390a:	2a61      	cmp	r2, #97	; 0x61
    390c:	d1e0      	bne.n	38d0 <mcp794xx_get_compile_time_date+0x3c>
    390e:	798a      	ldrb	r2, [r1, #6]
    3910:	2a6e      	cmp	r2, #110	; 0x6e
    3912:	d1dd      	bne.n	38d0 <mcp794xx_get_compile_time_date+0x3c>
    3914:	2231      	movs	r2, #49	; 0x31
    3916:	e02c      	b.n	3972 <mcp794xx_get_compile_time_date+0xde>
    3918:	794a      	ldrb	r2, [r1, #5]
    391a:	2a61      	cmp	r2, #97	; 0x61
    391c:	d1dc      	bne.n	38d8 <mcp794xx_get_compile_time_date+0x44>
    391e:	798a      	ldrb	r2, [r1, #6]
    3920:	2a72      	cmp	r2, #114	; 0x72
    3922:	d1d9      	bne.n	38d8 <mcp794xx_get_compile_time_date+0x44>
    3924:	2233      	movs	r2, #51	; 0x33
    3926:	e024      	b.n	3972 <mcp794xx_get_compile_time_date+0xde>
    3928:	794a      	ldrb	r2, [r1, #5]
    392a:	2a70      	cmp	r2, #112	; 0x70
    392c:	d1d6      	bne.n	38dc <mcp794xx_get_compile_time_date+0x48>
    392e:	2234      	movs	r2, #52	; 0x34
    3930:	e01f      	b.n	3972 <mcp794xx_get_compile_time_date+0xde>
    3932:	794a      	ldrb	r2, [r1, #5]
    3934:	2a61      	cmp	r2, #97	; 0x61
    3936:	d1d3      	bne.n	38e0 <mcp794xx_get_compile_time_date+0x4c>
    3938:	798a      	ldrb	r2, [r1, #6]
    393a:	2a79      	cmp	r2, #121	; 0x79
    393c:	d1d0      	bne.n	38e0 <mcp794xx_get_compile_time_date+0x4c>
    393e:	2235      	movs	r2, #53	; 0x35
    3940:	e017      	b.n	3972 <mcp794xx_get_compile_time_date+0xde>
    3942:	794a      	ldrb	r2, [r1, #5]
    3944:	2a75      	cmp	r2, #117	; 0x75
    3946:	d1cd      	bne.n	38e4 <mcp794xx_get_compile_time_date+0x50>
    3948:	798a      	ldrb	r2, [r1, #6]
    394a:	2a6e      	cmp	r2, #110	; 0x6e
    394c:	d1ca      	bne.n	38e4 <mcp794xx_get_compile_time_date+0x50>
    394e:	2236      	movs	r2, #54	; 0x36
    3950:	e00f      	b.n	3972 <mcp794xx_get_compile_time_date+0xde>
    3952:	794a      	ldrb	r2, [r1, #5]
    3954:	2a75      	cmp	r2, #117	; 0x75
    3956:	d1c7      	bne.n	38e8 <mcp794xx_get_compile_time_date+0x54>
    3958:	798a      	ldrb	r2, [r1, #6]
    395a:	2a6c      	cmp	r2, #108	; 0x6c
    395c:	d1c4      	bne.n	38e8 <mcp794xx_get_compile_time_date+0x54>
    395e:	2237      	movs	r2, #55	; 0x37
    3960:	e007      	b.n	3972 <mcp794xx_get_compile_time_date+0xde>
    3962:	794a      	ldrb	r2, [r1, #5]
    3964:	2a75      	cmp	r2, #117	; 0x75
    3966:	d1c1      	bne.n	38ec <mcp794xx_get_compile_time_date+0x58>
    3968:	2238      	movs	r2, #56	; 0x38
    396a:	e002      	b.n	3972 <mcp794xx_get_compile_time_date+0xde>
    396c:	2232      	movs	r2, #50	; 0x32
    396e:	e000      	b.n	3972 <mcp794xx_get_compile_time_date+0xde>
    3970:	2232      	movs	r2, #50	; 0x32
    3972:	ab06      	add	r3, sp, #24
    3974:	705a      	strb	r2, [r3, #1]
    date_string[0] = BUILD_DATE_CH0(pCompile_time_date);
    3976:	7a0b      	ldrb	r3, [r1, #8]
    3978:	1c1a      	adds	r2, r3, #0
    397a:	2b2f      	cmp	r3, #47	; 0x2f
    397c:	d800      	bhi.n	3980 <mcp794xx_get_compile_time_date+0xec>
    397e:	2230      	movs	r2, #48	; 0x30
    3980:	ab05      	add	r3, sp, #20
    3982:	701a      	strb	r2, [r3, #0]
    date_string[1] = BUILD_DATE_CH1(pCompile_time_date);
    3984:	7a4a      	ldrb	r2, [r1, #9]
    3986:	705a      	strb	r2, [r3, #1]
    hour_string[0] = BUILD_HOUR_CH0(pCompile_time_date);
    3988:	7aca      	ldrb	r2, [r1, #11]
    398a:	ab03      	add	r3, sp, #12
    398c:	701a      	strb	r2, [r3, #0]
    hour_string[1] = BUILD_HOUR_CH1(pCompile_time_date);
    398e:	7b0a      	ldrb	r2, [r1, #12]
    3990:	705a      	strb	r2, [r3, #1]
    minute_string[0] = BUILD_MIN_CH0(pCompile_time_date);
    3992:	7b8a      	ldrb	r2, [r1, #14]
    3994:	ab02      	add	r3, sp, #8
    3996:	701a      	strb	r2, [r3, #0]
    minute_string[1] = BUILD_MIN_CH1(pCompile_time_date);
    3998:	7bca      	ldrb	r2, [r1, #15]
    399a:	705a      	strb	r2, [r3, #1]
    second_string[0] = BUILD_SEC_CH0(pCompile_time_date);
    399c:	7c4a      	ldrb	r2, [r1, #17]
    399e:	ab01      	add	r3, sp, #4
    39a0:	701a      	strb	r2, [r3, #0]
    second_string[1] = BUILD_SEC_CH1(pCompile_time_date);
    39a2:	7c8a      	ldrb	r2, [r1, #18]
    39a4:	705a      	strb	r2, [r3, #1]
    week_day_string[0] = BUILD_WEEK_DAY_CH(pCompile_time_date);
    39a6:	780b      	ldrb	r3, [r1, #0]
    39a8:	2b53      	cmp	r3, #83	; 0x53
    39aa:	d013      	beq.n	39d4 <mcp794xx_get_compile_time_date+0x140>
    39ac:	2b4d      	cmp	r3, #77	; 0x4d
    39ae:	d033      	beq.n	3a18 <mcp794xx_get_compile_time_date+0x184>
    39b0:	2b54      	cmp	r3, #84	; 0x54
    39b2:	d017      	beq.n	39e4 <mcp794xx_get_compile_time_date+0x150>
    39b4:	2b57      	cmp	r3, #87	; 0x57
    39b6:	d05d      	beq.n	3a74 <mcp794xx_get_compile_time_date+0x1e0>
    39b8:	2b54      	cmp	r3, #84	; 0x54
    39ba:	d01b      	beq.n	39f4 <mcp794xx_get_compile_time_date+0x160>
    39bc:	2b46      	cmp	r3, #70	; 0x46
    39be:	d05b      	beq.n	3a78 <mcp794xx_get_compile_time_date+0x1e4>
    39c0:	2b53      	cmp	r3, #83	; 0x53
    39c2:	d01f      	beq.n	3a04 <mcp794xx_get_compile_time_date+0x170>
    39c4:	233f      	movs	r3, #63	; 0x3f
    39c6:	e028      	b.n	3a1a <mcp794xx_get_compile_time_date+0x186>
    month_string[1] = BUILD_MONTH_CH1(pCompile_time_date);
    39c8:	2239      	movs	r2, #57	; 0x39
    39ca:	e7d2      	b.n	3972 <mcp794xx_get_compile_time_date+0xde>
    39cc:	2230      	movs	r2, #48	; 0x30
    39ce:	e7d0      	b.n	3972 <mcp794xx_get_compile_time_date+0xde>
    39d0:	2231      	movs	r2, #49	; 0x31
    39d2:	e7ce      	b.n	3972 <mcp794xx_get_compile_time_date+0xde>
    week_day_string[0] = BUILD_WEEK_DAY_CH(pCompile_time_date);
    39d4:	784a      	ldrb	r2, [r1, #1]
    39d6:	2a75      	cmp	r2, #117	; 0x75
    39d8:	d1e8      	bne.n	39ac <mcp794xx_get_compile_time_date+0x118>
    39da:	788a      	ldrb	r2, [r1, #2]
    39dc:	2a6e      	cmp	r2, #110	; 0x6e
    39de:	d1e5      	bne.n	39ac <mcp794xx_get_compile_time_date+0x118>
    39e0:	2331      	movs	r3, #49	; 0x31
    39e2:	e01a      	b.n	3a1a <mcp794xx_get_compile_time_date+0x186>
    39e4:	784a      	ldrb	r2, [r1, #1]
    39e6:	2a75      	cmp	r2, #117	; 0x75
    39e8:	d1e4      	bne.n	39b4 <mcp794xx_get_compile_time_date+0x120>
    39ea:	788a      	ldrb	r2, [r1, #2]
    39ec:	2a65      	cmp	r2, #101	; 0x65
    39ee:	d1e1      	bne.n	39b4 <mcp794xx_get_compile_time_date+0x120>
    39f0:	2333      	movs	r3, #51	; 0x33
    39f2:	e012      	b.n	3a1a <mcp794xx_get_compile_time_date+0x186>
    39f4:	784a      	ldrb	r2, [r1, #1]
    39f6:	2a68      	cmp	r2, #104	; 0x68
    39f8:	d1e0      	bne.n	39bc <mcp794xx_get_compile_time_date+0x128>
    39fa:	788a      	ldrb	r2, [r1, #2]
    39fc:	2a75      	cmp	r2, #117	; 0x75
    39fe:	d1dd      	bne.n	39bc <mcp794xx_get_compile_time_date+0x128>
    3a00:	2335      	movs	r3, #53	; 0x35
    3a02:	e00a      	b.n	3a1a <mcp794xx_get_compile_time_date+0x186>
    3a04:	784b      	ldrb	r3, [r1, #1]
    3a06:	2b61      	cmp	r3, #97	; 0x61
    3a08:	d001      	beq.n	3a0e <mcp794xx_get_compile_time_date+0x17a>
    3a0a:	233f      	movs	r3, #63	; 0x3f
    3a0c:	e005      	b.n	3a1a <mcp794xx_get_compile_time_date+0x186>
    3a0e:	788b      	ldrb	r3, [r1, #2]
    3a10:	2b74      	cmp	r3, #116	; 0x74
    3a12:	d033      	beq.n	3a7c <mcp794xx_get_compile_time_date+0x1e8>
    3a14:	233f      	movs	r3, #63	; 0x3f
    3a16:	e000      	b.n	3a1a <mcp794xx_get_compile_time_date+0x186>
    3a18:	2332      	movs	r3, #50	; 0x32
    3a1a:	ad04      	add	r5, sp, #16
    3a1c:	702b      	strb	r3, [r5, #0]
    pTime->year = atoi((const char *)year_string);
    3a1e:	a807      	add	r0, sp, #28
    3a20:	f002 fb80 	bl	6124 <atoi>
    3a24:	8020      	strh	r0, [r4, #0]
    pTime->month = atoi((const char *) month_string);
    3a26:	a806      	add	r0, sp, #24
    3a28:	f002 fb7c 	bl	6124 <atoi>
    3a2c:	71a0      	strb	r0, [r4, #6]
    pTime->date = atoi((const char *) date_string);
    3a2e:	a805      	add	r0, sp, #20
    3a30:	f002 fb78 	bl	6124 <atoi>
    3a34:	70a0      	strb	r0, [r4, #2]
    pTime->weekDay = atoi((const char *) week_day_string);
    3a36:	0028      	movs	r0, r5
    3a38:	f002 fb74 	bl	6124 <atoi>
    3a3c:	71e0      	strb	r0, [r4, #7]
    pTime->hour = atoi((const char *) hour_string);
    3a3e:	a803      	add	r0, sp, #12
    3a40:	f002 fb70 	bl	6124 <atoi>
    3a44:	70e0      	strb	r0, [r4, #3]
    pTime->minute = atoi((const char *) minute_string);
    3a46:	a802      	add	r0, sp, #8
    3a48:	f002 fb6c 	bl	6124 <atoi>
    3a4c:	7120      	strb	r0, [r4, #4]
    pTime->second = atoi((const char *) second_string);
    3a4e:	a801      	add	r0, sp, #4
    3a50:	f002 fb68 	bl	6124 <atoi>
    3a54:	b2c0      	uxtb	r0, r0
    3a56:	7160      	strb	r0, [r4, #5]
	if(pTime->second < 45){
    3a58:	282c      	cmp	r0, #44	; 0x2c
    3a5a:	d911      	bls.n	3a80 <mcp794xx_get_compile_time_date+0x1ec>
		pTime->second = (pTime->second + sec_offset) - 60;
    3a5c:	382d      	subs	r0, #45	; 0x2d
    3a5e:	7160      	strb	r0, [r4, #5]
		if(pTime->minute < 58){
    3a60:	7923      	ldrb	r3, [r4, #4]
    3a62:	2b39      	cmp	r3, #57	; 0x39
    3a64:	d910      	bls.n	3a88 <mcp794xx_get_compile_time_date+0x1f4>
			pTime->hour += 1;
    3a66:	78e3      	ldrb	r3, [r4, #3]
    3a68:	3301      	adds	r3, #1
    3a6a:	70e3      	strb	r3, [r4, #3]
			pTime->minute = 0;
    3a6c:	2300      	movs	r3, #0
    3a6e:	7123      	strb	r3, [r4, #4]
    return 0;
    3a70:	2000      	movs	r0, #0
    3a72:	e719      	b.n	38a8 <mcp794xx_get_compile_time_date+0x14>
    week_day_string[0] = BUILD_WEEK_DAY_CH(pCompile_time_date);
    3a74:	2334      	movs	r3, #52	; 0x34
    3a76:	e7d0      	b.n	3a1a <mcp794xx_get_compile_time_date+0x186>
    3a78:	2336      	movs	r3, #54	; 0x36
    3a7a:	e7ce      	b.n	3a1a <mcp794xx_get_compile_time_date+0x186>
    3a7c:	2337      	movs	r3, #55	; 0x37
    3a7e:	e7cc      	b.n	3a1a <mcp794xx_get_compile_time_date+0x186>
		pTime->second += sec_offset;
    3a80:	300f      	adds	r0, #15
    3a82:	7160      	strb	r0, [r4, #5]
    return 0;
    3a84:	2000      	movs	r0, #0
    3a86:	e70f      	b.n	38a8 <mcp794xx_get_compile_time_date+0x14>
			pTime->minute += 1;
    3a88:	3301      	adds	r3, #1
    3a8a:	7123      	strb	r3, [r4, #4]
    return 0;
    3a8c:	2000      	movs	r0, #0
    3a8e:	e70b      	b.n	38a8 <mcp794xx_get_compile_time_date+0x14>
        return 2;     /**< return failed error */
    3a90:	2002      	movs	r0, #2
    3a92:	e709      	b.n	38a8 <mcp794xx_get_compile_time_date+0x14>

00003a94 <mcp794xx_set_countdown_interrupt_enable_status>:
 *            - 2 pHandle is NULL
 *            - 3 pHandle is not initialized
 * @note      This function use ALARM1 and disables ALARM 0
 */
uint8_t mcp794xx_set_countdown_interrupt_enable_status(mcp794xx_handle_t *const pHandle, mcp794xx_bool_t status)
{
    3a94:	b570      	push	{r4, r5, r6, lr}
    3a96:	0004      	movs	r4, r0
    3a98:	000e      	movs	r6, r1
    if(pHandle == NULL)
    3a9a:	2800      	cmp	r0, #0
    3a9c:	d025      	beq.n	3aea <mcp794xx_set_countdown_interrupt_enable_status+0x56>
        return 2;     /**< return failed error */
    if(pHandle->inited != 1)
    3a9e:	7fc5      	ldrb	r5, [r0, #31]
    3aa0:	2d01      	cmp	r5, #1
    3aa2:	d001      	beq.n	3aa8 <mcp794xx_set_countdown_interrupt_enable_status+0x14>
        return 3;      /**< return failed error */
    3aa4:	2003      	movs	r0, #3
        a_mcp794xx_print_error_msg(pHandle, "set countdown interrupt");
        return 1;
    }

    return 0;
}
    3aa6:	bd70      	pop	{r4, r5, r6, pc}
	err = mcp794xx_set_alarm_enable_status(pHandle, MCP794XX_ALARM0, MCP794XX_BOOL_FALSE);
    3aa8:	2200      	movs	r2, #0
    3aaa:	2100      	movs	r1, #0
    3aac:	f7fe fe2a 	bl	2704 <mcp794xx_set_alarm_enable_status>
    3ab0:	4b0f      	ldr	r3, [pc, #60]	; (3af0 <mcp794xx_set_countdown_interrupt_enable_status+0x5c>)
    3ab2:	447b      	add	r3, pc
    3ab4:	7018      	strb	r0, [r3, #0]
	if(err != MCP794XX_DRV_OK)
    3ab6:	2800      	cmp	r0, #0
    3ab8:	d110      	bne.n	3adc <mcp794xx_set_countdown_interrupt_enable_status+0x48>
    err = mcp794xx_set_alarm_enable_status(pHandle, MCP794XX_ALARM1, status);
    3aba:	0032      	movs	r2, r6
    3abc:	2101      	movs	r1, #1
    3abe:	0020      	movs	r0, r4
    3ac0:	f7fe fe20 	bl	2704 <mcp794xx_set_alarm_enable_status>
    3ac4:	4a0b      	ldr	r2, [pc, #44]	; (3af4 <mcp794xx_set_countdown_interrupt_enable_status+0x60>)
    3ac6:	447a      	add	r2, pc
    3ac8:	7010      	strb	r0, [r2, #0]
    if(err != MCP794XX_DRV_OK)
    3aca:	2800      	cmp	r0, #0
    3acc:	d0eb      	beq.n	3aa6 <mcp794xx_set_countdown_interrupt_enable_status+0x12>
        a_mcp794xx_print_error_msg(pHandle, "set countdown interrupt");
    3ace:	490a      	ldr	r1, [pc, #40]	; (3af8 <mcp794xx_set_countdown_interrupt_enable_status+0x64>)
    3ad0:	4479      	add	r1, pc
    3ad2:	0020      	movs	r0, r4
    3ad4:	f7fe f93e 	bl	1d54 <a_mcp794xx_print_error_msg>
        return 1;
    3ad8:	0028      	movs	r0, r5
    3ada:	e7e4      	b.n	3aa6 <mcp794xx_set_countdown_interrupt_enable_status+0x12>
		a_mcp794xx_print_error_msg(pHandle, "set countdown interrupt, ALARM 0 not disabled");
    3adc:	4907      	ldr	r1, [pc, #28]	; (3afc <mcp794xx_set_countdown_interrupt_enable_status+0x68>)
    3ade:	4479      	add	r1, pc
    3ae0:	0020      	movs	r0, r4
    3ae2:	f7fe f937 	bl	1d54 <a_mcp794xx_print_error_msg>
		return 1;
    3ae6:	0028      	movs	r0, r5
    3ae8:	e7dd      	b.n	3aa6 <mcp794xx_set_countdown_interrupt_enable_status+0x12>
        return 2;     /**< return failed error */
    3aea:	2002      	movs	r0, #2
    3aec:	e7db      	b.n	3aa6 <mcp794xx_set_countdown_interrupt_enable_status+0x12>
    3aee:	46c0      	nop			; (mov r8, r8)
    3af0:	1fffc82e 	.word	0x1fffc82e
    3af4:	1fffc81a 	.word	0x1fffc81a
    3af8:	000042fc 	.word	0x000042fc
    3afc:	000042be 	.word	0x000042be

00003b00 <mcp794xx_set_countdown_interrupt_time>:
 *            - "mcp794xx_set_countdown_interrupt_enable_status"  must be called before using this function
 *            - Time and date must be set prior to calling this function
 *            - day of the week must be accurate when setting time
 */
uint8_t mcp794xx_set_countdown_interrupt_time(mcp794xx_handle_t *const pHandle, uint16_t u16Time_value, mcp794xx_countdwon_time_unit_t time_unit)
{
    3b00:	b570      	push	{r4, r5, r6, lr}
    3b02:	b084      	sub	sp, #16
    3b04:	0004      	movs	r4, r0
    3b06:	000e      	movs	r6, r1
    3b08:	0015      	movs	r5, r2
	mcp794xx_time_t pTime;

    uint32_t countdown_time_in_seconds;
    uint32_t epoch_time;

    if(pHandle == NULL)
    3b0a:	2800      	cmp	r0, #0
    3b0c:	d05b      	beq.n	3bc6 <mcp794xx_set_countdown_interrupt_time+0xc6>
        return 2;     /**< return failed error */
    if(pHandle->inited != 1)
    3b0e:	7fc3      	ldrb	r3, [r0, #31]
    3b10:	2b01      	cmp	r3, #1
    3b12:	d002      	beq.n	3b1a <mcp794xx_set_countdown_interrupt_time+0x1a>
        return 3;      /**< return failed error */
    3b14:	2003      	movs	r0, #3
    {
        return err;
    }

    return 0;
}
    3b16:	b004      	add	sp, #16
    3b18:	bd70      	pop	{r4, r5, r6, pc}
    if((time_unit != MCP794XX_CNTDWN_SECONDS) && (time_unit != MCP794XX_CNTDWN_MINUTES) && (time_unit != MCP794XX_CNTDWN_HOURS))
    3b1a:	2a02      	cmp	r2, #2
    3b1c:	d905      	bls.n	3b2a <mcp794xx_set_countdown_interrupt_time+0x2a>
        a_mcp794xx_print_error_msg(pHandle, "countdown interrupt, invalid time unit");
    3b1e:	492b      	ldr	r1, [pc, #172]	; (3bcc <mcp794xx_set_countdown_interrupt_time+0xcc>)
    3b20:	4479      	add	r1, pc
    3b22:	f7fe f917 	bl	1d54 <a_mcp794xx_print_error_msg>
        return 4;
    3b26:	2004      	movs	r0, #4
    3b28:	e7f5      	b.n	3b16 <mcp794xx_set_countdown_interrupt_time+0x16>
	mcp794xx_clr_alarm_interrupt_flag(pHandle, MCP794XX_ALARM1);						/**< clear alarm flag */
    3b2a:	2101      	movs	r1, #1
    3b2c:	f7ff fb54 	bl	31d8 <mcp794xx_clr_alarm_interrupt_flag>
	err = mcp794xx_get_time_and_date(pHandle, &pTime);										/**< get current time and date */
    3b30:	a901      	add	r1, sp, #4
    3b32:	0020      	movs	r0, r4
    3b34:	f7fe f9d4 	bl	1ee0 <mcp794xx_get_time_and_date>
    3b38:	4b25      	ldr	r3, [pc, #148]	; (3bd0 <mcp794xx_set_countdown_interrupt_time+0xd0>)
    3b3a:	447b      	add	r3, pc
    3b3c:	7018      	strb	r0, [r3, #0]
	if(err)
    3b3e:	2800      	cmp	r0, #0
    3b40:	d123      	bne.n	3b8a <mcp794xx_set_countdown_interrupt_time+0x8a>
    err = mcp794xx_read_epoch_unix_time_stamp(pHandle, &pTime, (uint32_t *)&epoch_time);
    3b42:	466a      	mov	r2, sp
    3b44:	a901      	add	r1, sp, #4
    3b46:	0020      	movs	r0, r4
    3b48:	f7ff fd8a 	bl	3660 <mcp794xx_read_epoch_unix_time_stamp>
    3b4c:	4a21      	ldr	r2, [pc, #132]	; (3bd4 <mcp794xx_set_countdown_interrupt_time+0xd4>)
    3b4e:	447a      	add	r2, pc
    3b50:	7010      	strb	r0, [r2, #0]
    if(err)
    3b52:	2800      	cmp	r0, #0
    3b54:	d1df      	bne.n	3b16 <mcp794xx_set_countdown_interrupt_time+0x16>
    switch(time_unit)
    3b56:	2d01      	cmp	r5, #1
    3b58:	d025      	beq.n	3ba6 <mcp794xx_set_countdown_interrupt_time+0xa6>
    3b5a:	2d00      	cmp	r5, #0
    3b5c:	d01e      	beq.n	3b9c <mcp794xx_set_countdown_interrupt_time+0x9c>
    3b5e:	2d02      	cmp	r5, #2
    3b60:	d029      	beq.n	3bb6 <mcp794xx_set_countdown_interrupt_time+0xb6>
    err = mcp794xx_convert_epoch_unix_time_stamp(pHandle, epoch_time, &pTime);
    3b62:	aa01      	add	r2, sp, #4
    3b64:	9900      	ldr	r1, [sp, #0]
    3b66:	0020      	movs	r0, r4
    3b68:	f7ff fdbc 	bl	36e4 <mcp794xx_convert_epoch_unix_time_stamp>
    3b6c:	4a1a      	ldr	r2, [pc, #104]	; (3bd8 <mcp794xx_set_countdown_interrupt_time+0xd8>)
    3b6e:	447a      	add	r2, pc
    3b70:	7010      	strb	r0, [r2, #0]
    if(err != MCP794XX_DRV_OK)
    3b72:	2800      	cmp	r0, #0
    3b74:	d1cf      	bne.n	3b16 <mcp794xx_set_countdown_interrupt_time+0x16>
    err = mcp794xx_set_alarm(pHandle, MCP794XX_ALARM1, MCP794XX_MASK_S_M_H_WD_D_M, &pTime);
    3b76:	ab01      	add	r3, sp, #4
    3b78:	2207      	movs	r2, #7
    3b7a:	2101      	movs	r1, #1
    3b7c:	0020      	movs	r0, r4
    3b7e:	f7ff f927 	bl	2dd0 <mcp794xx_set_alarm>
    3b82:	4a16      	ldr	r2, [pc, #88]	; (3bdc <mcp794xx_set_countdown_interrupt_time+0xdc>)
    3b84:	447a      	add	r2, pc
    3b86:	7010      	strb	r0, [r2, #0]
    3b88:	e7c5      	b.n	3b16 <mcp794xx_set_countdown_interrupt_time+0x16>
		a_mcp794xx_print_error_msg(pHandle, "read current time and date");
    3b8a:	4915      	ldr	r1, [pc, #84]	; (3be0 <mcp794xx_set_countdown_interrupt_time+0xe0>)
    3b8c:	4479      	add	r1, pc
    3b8e:	0020      	movs	r0, r4
    3b90:	f7fe f8e0 	bl	1d54 <a_mcp794xx_print_error_msg>
		return err;
    3b94:	4b13      	ldr	r3, [pc, #76]	; (3be4 <mcp794xx_set_countdown_interrupt_time+0xe4>)
    3b96:	447b      	add	r3, pc
    3b98:	7818      	ldrb	r0, [r3, #0]
    3b9a:	e7bc      	b.n	3b16 <mcp794xx_set_countdown_interrupt_time+0x16>
                epoch_time += countdown_time_in_seconds;
    3b9c:	9b00      	ldr	r3, [sp, #0]
    3b9e:	469c      	mov	ip, r3
    3ba0:	4466      	add	r6, ip
    3ba2:	9600      	str	r6, [sp, #0]
                break;
    3ba4:	e7dd      	b.n	3b62 <mcp794xx_set_countdown_interrupt_time+0x62>
                countdown_time_in_seconds = u16Time_value * 60;      /**< convert to second */
    3ba6:	0133      	lsls	r3, r6, #4
    3ba8:	1b9e      	subs	r6, r3, r6
    3baa:	00b3      	lsls	r3, r6, #2
                 epoch_time += countdown_time_in_seconds;
    3bac:	9a00      	ldr	r2, [sp, #0]
    3bae:	4694      	mov	ip, r2
    3bb0:	4463      	add	r3, ip
    3bb2:	9300      	str	r3, [sp, #0]
                break;
    3bb4:	e7d5      	b.n	3b62 <mcp794xx_set_countdown_interrupt_time+0x62>
                countdown_time_in_seconds = u16Time_value * 3600;    /**< convert to seconds */
    3bb6:	23e1      	movs	r3, #225	; 0xe1
    3bb8:	011b      	lsls	r3, r3, #4
    3bba:	435e      	muls	r6, r3
                 epoch_time += countdown_time_in_seconds;
    3bbc:	9b00      	ldr	r3, [sp, #0]
    3bbe:	469c      	mov	ip, r3
    3bc0:	4466      	add	r6, ip
    3bc2:	9600      	str	r6, [sp, #0]
                break;
    3bc4:	e7cd      	b.n	3b62 <mcp794xx_set_countdown_interrupt_time+0x62>
        return 2;     /**< return failed error */
    3bc6:	2002      	movs	r0, #2
    3bc8:	e7a5      	b.n	3b16 <mcp794xx_set_countdown_interrupt_time+0x16>
    3bca:	46c0      	nop			; (mov r8, r8)
    3bcc:	000042c4 	.word	0x000042c4
    3bd0:	1fffc7a6 	.word	0x1fffc7a6
    3bd4:	1fffc792 	.word	0x1fffc792
    3bd8:	1fffc772 	.word	0x1fffc772
    3bdc:	1fffc75c 	.word	0x1fffc75c
    3be0:	00004280 	.word	0x00004280
    3be4:	1fffc74a 	.word	0x1fffc74a

00003be8 <mcp794xx_uid_read>:
 *            - 2 pHandle is NULL
 *            - 3 pHandle is not initialized
 * @note      none
 */
uint8_t mcp794xx_uid_read(mcp794xx_handle_t *const pHandle, uint8_t *pUID)
{
    3be8:	b5f0      	push	{r4, r5, r6, r7, lr}
    3bea:	b083      	sub	sp, #12
    3bec:	0005      	movs	r5, r0
    3bee:	000e      	movs	r6, r1
    uint8_t temp_buffer[UID_MAX_LENGTH];

    if(pHandle == NULL)
    3bf0:	2800      	cmp	r0, #0
    3bf2:	d100      	bne.n	3bf6 <mcp794xx_uid_read+0xe>
    3bf4:	e091      	b.n	3d1a <mcp794xx_uid_read+0x132>
        return 2;     /**< return failed error */
    if(pHandle->inited != 1)
    3bf6:	7fc4      	ldrb	r4, [r0, #31]
    3bf8:	2c01      	cmp	r4, #1
    3bfa:	d003      	beq.n	3c04 <mcp794xx_uid_read+0x1c>
        return 3;      /**< return failed error */
    3bfc:	2403      	movs	r4, #3
        }

    }

    return 0;              /**< success */
}
    3bfe:	0020      	movs	r0, r4
    3c00:	b003      	add	sp, #12
    3c02:	bdf0      	pop	{r4, r5, r6, r7, pc}
    memset(temp_buffer, 0x00, sizeof(temp_buffer));                 /**< clear buffer before read */
    3c04:	2208      	movs	r2, #8
    3c06:	2100      	movs	r1, #0
    3c08:	4668      	mov	r0, sp
    3c0a:	f002 fad2 	bl	61b2 <memset>
    switch(pHandle->device_variant)
    3c0e:	7fa8      	ldrb	r0, [r5, #30]
    3c10:	2807      	cmp	r0, #7
    3c12:	d900      	bls.n	3c16 <mcp794xx_uid_read+0x2e>
    3c14:	e083      	b.n	3d1e <mcp794xx_uid_read+0x136>
    3c16:	f000 ffb9 	bl	4b8c <__gnu_thumb1_case_uqi>
    3c1a:	0a04      	.short	0x0a04
    3c1c:	48423c23 	.word	0x48423c23
    3c20:	674e      	.short	0x674e
            a_mcp794xx_print_error_msg(pHandle, "failed to read UID, unsupported cmd for mcp79400 variant");
    3c22:	4940      	ldr	r1, [pc, #256]	; (3d24 <mcp794xx_uid_read+0x13c>)
    3c24:	4479      	add	r1, pc
    3c26:	0028      	movs	r0, r5
    3c28:	f7fe f894 	bl	1d54 <a_mcp794xx_print_error_msg>
            return 1;           /**< failed error */
    3c2c:	e7e7      	b.n	3bfe <mcp794xx_uid_read+0x16>
            err = eeprom_mcp794xx_i2c_read(pHandle, EEPROM_UID_ADDRESS + 2, (uint8_t *)temp_buffer, UID_MAX_LENGTH - 2);
    3c2e:	2306      	movs	r3, #6
    3c30:	466a      	mov	r2, sp
    3c32:	21f2      	movs	r1, #242	; 0xf2
    3c34:	0028      	movs	r0, r5
    3c36:	f7fe f851 	bl	1cdc <eeprom_mcp794xx_i2c_read>
    3c3a:	0007      	movs	r7, r0
    3c3c:	4b3a      	ldr	r3, [pc, #232]	; (3d28 <mcp794xx_uid_read+0x140>)
    3c3e:	447b      	add	r3, pc
    3c40:	7018      	strb	r0, [r3, #0]
            if(err)
    3c42:	2800      	cmp	r0, #0
    3c44:	d005      	beq.n	3c52 <mcp794xx_uid_read+0x6a>
                a_mcp794xx_print_error_msg(pHandle, "failed to read UID");
    3c46:	4939      	ldr	r1, [pc, #228]	; (3d2c <mcp794xx_uid_read+0x144>)
    3c48:	4479      	add	r1, pc
    3c4a:	0028      	movs	r0, r5
    3c4c:	f7fe f882 	bl	1d54 <a_mcp794xx_print_error_msg>
                return 1;           /**< failed error */
    3c50:	e7d5      	b.n	3bfe <mcp794xx_uid_read+0x16>
            memcpy((uint8_t *)pUID, (uint8_t *)temp_buffer, sizeof(temp_buffer) - 2);
    3c52:	2206      	movs	r2, #6
    3c54:	4669      	mov	r1, sp
    3c56:	0030      	movs	r0, r6
    3c58:	f002 faa2 	bl	61a0 <memcpy>
    return 0;              /**< success */
    3c5c:	003c      	movs	r4, r7
            break;
    3c5e:	e7ce      	b.n	3bfe <mcp794xx_uid_read+0x16>
            err = eeprom_mcp794xx_i2c_read(pHandle, EEPROM_UID_ADDRESS, (uint8_t *)temp_buffer, UID_MAX_LENGTH);
    3c60:	2308      	movs	r3, #8
    3c62:	466a      	mov	r2, sp
    3c64:	21f0      	movs	r1, #240	; 0xf0
    3c66:	0028      	movs	r0, r5
    3c68:	f7fe f838 	bl	1cdc <eeprom_mcp794xx_i2c_read>
    3c6c:	0007      	movs	r7, r0
    3c6e:	4b30      	ldr	r3, [pc, #192]	; (3d30 <mcp794xx_uid_read+0x148>)
    3c70:	447b      	add	r3, pc
    3c72:	7018      	strb	r0, [r3, #0]
            if(err)
    3c74:	2800      	cmp	r0, #0
    3c76:	d106      	bne.n	3c86 <mcp794xx_uid_read+0x9e>
            memcpy((uint8_t *)pUID, (uint8_t *)temp_buffer, sizeof(temp_buffer));
    3c78:	2208      	movs	r2, #8
    3c7a:	4669      	mov	r1, sp
    3c7c:	0030      	movs	r0, r6
    3c7e:	f002 fa8f 	bl	61a0 <memcpy>
    return 0;              /**< success */
    3c82:	003c      	movs	r4, r7
            break;
    3c84:	e7bb      	b.n	3bfe <mcp794xx_uid_read+0x16>
                a_mcp794xx_print_error_msg(pHandle, "failed to read UID");
    3c86:	492b      	ldr	r1, [pc, #172]	; (3d34 <mcp794xx_uid_read+0x14c>)
    3c88:	4479      	add	r1, pc
    3c8a:	0028      	movs	r0, r5
    3c8c:	f7fe f862 	bl	1d54 <a_mcp794xx_print_error_msg>
                return 1;           /**< failed error */
    3c90:	e7b5      	b.n	3bfe <mcp794xx_uid_read+0x16>
            a_mcp794xx_print_error_msg(pHandle, "failed to read UID, unsupported cmd for mcp7940m variant");
    3c92:	4929      	ldr	r1, [pc, #164]	; (3d38 <mcp794xx_uid_read+0x150>)
    3c94:	4479      	add	r1, pc
    3c96:	0028      	movs	r0, r5
    3c98:	f7fe f85c 	bl	1d54 <a_mcp794xx_print_error_msg>
            return 1;           /**< failed error */
    3c9c:	e7af      	b.n	3bfe <mcp794xx_uid_read+0x16>
            a_mcp794xx_print_error_msg(pHandle, "failed to read UID, unsupported cmd for mcp7940n variant");
    3c9e:	4927      	ldr	r1, [pc, #156]	; (3d3c <mcp794xx_uid_read+0x154>)
    3ca0:	4479      	add	r1, pc
    3ca2:	0028      	movs	r0, r5
    3ca4:	f7fe f856 	bl	1d54 <a_mcp794xx_print_error_msg>
            return 1;           /**< failed error */
    3ca8:	e7a9      	b.n	3bfe <mcp794xx_uid_read+0x16>
            a_mcp794xx_print_error_msg(pHandle, "failed to read UID, unsupported cmd for mcp79410 variant");
    3caa:	4925      	ldr	r1, [pc, #148]	; (3d40 <mcp794xx_uid_read+0x158>)
    3cac:	4479      	add	r1, pc
    3cae:	0028      	movs	r0, r5
    3cb0:	f7fe f850 	bl	1d54 <a_mcp794xx_print_error_msg>
            return 1;           /**< failed error */
    3cb4:	e7a3      	b.n	3bfe <mcp794xx_uid_read+0x16>
            err = eeprom_mcp794xx_i2c_read(pHandle, EEPROM_UID_ADDRESS + 2, (uint8_t *)temp_buffer, UID_MAX_LENGTH - 2);
    3cb6:	2306      	movs	r3, #6
    3cb8:	466a      	mov	r2, sp
    3cba:	21f2      	movs	r1, #242	; 0xf2
    3cbc:	0028      	movs	r0, r5
    3cbe:	f7fe f80d 	bl	1cdc <eeprom_mcp794xx_i2c_read>
    3cc2:	0007      	movs	r7, r0
    3cc4:	4b1f      	ldr	r3, [pc, #124]	; (3d44 <mcp794xx_uid_read+0x15c>)
    3cc6:	447b      	add	r3, pc
    3cc8:	7018      	strb	r0, [r3, #0]
            if(err)
    3cca:	2800      	cmp	r0, #0
    3ccc:	d005      	beq.n	3cda <mcp794xx_uid_read+0xf2>
                a_mcp794xx_print_error_msg(pHandle, "failed to read UID");
    3cce:	491e      	ldr	r1, [pc, #120]	; (3d48 <mcp794xx_uid_read+0x160>)
    3cd0:	4479      	add	r1, pc
    3cd2:	0028      	movs	r0, r5
    3cd4:	f7fe f83e 	bl	1d54 <a_mcp794xx_print_error_msg>
                return 1;           /**< failed error */
    3cd8:	e791      	b.n	3bfe <mcp794xx_uid_read+0x16>
            memcpy((uint8_t *)pUID, (uint8_t *)temp_buffer, sizeof(temp_buffer) - 2);
    3cda:	2206      	movs	r2, #6
    3cdc:	4669      	mov	r1, sp
    3cde:	0030      	movs	r0, r6
    3ce0:	f002 fa5e 	bl	61a0 <memcpy>
    return 0;              /**< success */
    3ce4:	003c      	movs	r4, r7
            break;
    3ce6:	e78a      	b.n	3bfe <mcp794xx_uid_read+0x16>
            err = eeprom_mcp794xx_i2c_read(pHandle, EEPROM_UID_ADDRESS, (uint8_t *)temp_buffer, UID_MAX_LENGTH);
    3ce8:	2308      	movs	r3, #8
    3cea:	466a      	mov	r2, sp
    3cec:	21f0      	movs	r1, #240	; 0xf0
    3cee:	0028      	movs	r0, r5
    3cf0:	f7fd fff4 	bl	1cdc <eeprom_mcp794xx_i2c_read>
    3cf4:	0007      	movs	r7, r0
    3cf6:	4b15      	ldr	r3, [pc, #84]	; (3d4c <mcp794xx_uid_read+0x164>)
    3cf8:	447b      	add	r3, pc
    3cfa:	7018      	strb	r0, [r3, #0]
            if(err)
    3cfc:	2800      	cmp	r0, #0
    3cfe:	d106      	bne.n	3d0e <mcp794xx_uid_read+0x126>
            memcpy((uint8_t *)pUID, (uint8_t *)temp_buffer, sizeof(temp_buffer));
    3d00:	2208      	movs	r2, #8
    3d02:	4669      	mov	r1, sp
    3d04:	0030      	movs	r0, r6
    3d06:	f002 fa4b 	bl	61a0 <memcpy>
    return 0;              /**< success */
    3d0a:	003c      	movs	r4, r7
            break;
    3d0c:	e777      	b.n	3bfe <mcp794xx_uid_read+0x16>
                a_mcp794xx_print_error_msg(pHandle, "failed to read UID");
    3d0e:	4910      	ldr	r1, [pc, #64]	; (3d50 <mcp794xx_uid_read+0x168>)
    3d10:	4479      	add	r1, pc
    3d12:	0028      	movs	r0, r5
    3d14:	f7fe f81e 	bl	1d54 <a_mcp794xx_print_error_msg>
                return 1;           /**< failed error */
    3d18:	e771      	b.n	3bfe <mcp794xx_uid_read+0x16>
        return 2;     /**< return failed error */
    3d1a:	2402      	movs	r4, #2
    3d1c:	e76f      	b.n	3bfe <mcp794xx_uid_read+0x16>
    return 0;              /**< success */
    3d1e:	2400      	movs	r4, #0
    3d20:	e76d      	b.n	3bfe <mcp794xx_uid_read+0x16>
    3d22:	46c0      	nop			; (mov r8, r8)
    3d24:	00004204 	.word	0x00004204
    3d28:	1fffc6a2 	.word	0x1fffc6a2
    3d2c:	0000421c 	.word	0x0000421c
    3d30:	1fffc670 	.word	0x1fffc670
    3d34:	000041dc 	.word	0x000041dc
    3d38:	000041e4 	.word	0x000041e4
    3d3c:	00004214 	.word	0x00004214
    3d40:	00004244 	.word	0x00004244
    3d44:	1fffc61a 	.word	0x1fffc61a
    3d48:	00004194 	.word	0x00004194
    3d4c:	1fffc5e8 	.word	0x1fffc5e8
    3d50:	00004154 	.word	0x00004154

00003d54 <mcp794xx_sram_write_byte>:
*          - 3 pHandle is not initialized
*          - 4 invalid address
* @note none
*/
uint8_t mcp794xx_sram_write_byte(mcp794xx_handle_t *const pHandle, uint8_t addr, uint8_t *pBuffer, size_t length)
{
    3d54:	b570      	push	{r4, r5, r6, lr}
    3d56:	1e04      	subs	r4, r0, #0

    if(pHandle == NULL)
    3d58:	d034      	beq.n	3dc4 <mcp794xx_sram_write_byte+0x70>
        return 2;     /**< return failed error */
    if(pHandle->inited != 1)
    3d5a:	7fc5      	ldrb	r5, [r0, #31]
    3d5c:	2d01      	cmp	r5, #1
    3d5e:	d001      	beq.n	3d64 <mcp794xx_sram_write_byte+0x10>
        return 3;      /**< return failed error */
    3d60:	2003      	movs	r0, #3
    {
       a_mcp794xx_print_error_msg(pHandle, "write to sram");
       return 1;
    }
	return 0;          /**< success */
}
    3d62:	bd70      	pop	{r4, r5, r6, pc}
    if(addr > SRAM_LAST_ADDRESS || addr < SRAM_FIRST_ADDRESS)
    3d64:	0008      	movs	r0, r1
    3d66:	3820      	subs	r0, #32
    3d68:	b2c0      	uxtb	r0, r0
    3d6a:	283f      	cmp	r0, #63	; 0x3f
    3d6c:	d80c      	bhi.n	3d88 <mcp794xx_sram_write_byte+0x34>
    }if(length > SRAM_MEMORY_SIZE){
    3d6e:	2b40      	cmp	r3, #64	; 0x40
    3d70:	d811      	bhi.n	3d96 <mcp794xx_sram_write_byte+0x42>
    }if((addr - SRAM_FIRST_ADDRESS)+ length > SRAM_MEMORY_SIZE){
    3d72:	18c8      	adds	r0, r1, r3
    3d74:	3820      	subs	r0, #32
    3d76:	2840      	cmp	r0, #64	; 0x40
    3d78:	d914      	bls.n	3da4 <mcp794xx_sram_write_byte+0x50>
    	a_mcp794xx_print_error_msg(pHandle, "write sram, address out of range");
    3d7a:	4913      	ldr	r1, [pc, #76]	; (3dc8 <mcp794xx_sram_write_byte+0x74>)
    3d7c:	4479      	add	r1, pc
    3d7e:	0020      	movs	r0, r4
    3d80:	f7fd ffe8 	bl	1d54 <a_mcp794xx_print_error_msg>
    	return 5;
    3d84:	2005      	movs	r0, #5
    3d86:	e7ec      	b.n	3d62 <mcp794xx_sram_write_byte+0xe>
    	a_mcp794xx_print_error_msg(pHandle, "write sram, invalid address");
    3d88:	4910      	ldr	r1, [pc, #64]	; (3dcc <mcp794xx_sram_write_byte+0x78>)
    3d8a:	4479      	add	r1, pc
    3d8c:	0020      	movs	r0, r4
    3d8e:	f7fd ffe1 	bl	1d54 <a_mcp794xx_print_error_msg>
    	return 4;
    3d92:	2004      	movs	r0, #4
    3d94:	e7e5      	b.n	3d62 <mcp794xx_sram_write_byte+0xe>
    	a_mcp794xx_print_error_msg(pHandle, "write sram, address can't be greater than 0x5F");
    3d96:	490e      	ldr	r1, [pc, #56]	; (3dd0 <mcp794xx_sram_write_byte+0x7c>)
    3d98:	4479      	add	r1, pc
    3d9a:	0020      	movs	r0, r4
    3d9c:	f7fd ffda 	bl	1d54 <a_mcp794xx_print_error_msg>
    	return 5;
    3da0:	2005      	movs	r0, #5
    3da2:	e7de      	b.n	3d62 <mcp794xx_sram_write_byte+0xe>
    err = sram_mcp794xx_i2c_write(pHandle, addr, (uint8_t *)pBuffer, length);
    3da4:	b2db      	uxtb	r3, r3
    3da6:	0020      	movs	r0, r4
    3da8:	f7fd ffb3 	bl	1d12 <sram_mcp794xx_i2c_write>
    3dac:	4a09      	ldr	r2, [pc, #36]	; (3dd4 <mcp794xx_sram_write_byte+0x80>)
    3dae:	447a      	add	r2, pc
    3db0:	7010      	strb	r0, [r2, #0]
    if(err)
    3db2:	2800      	cmp	r0, #0
    3db4:	d0d5      	beq.n	3d62 <mcp794xx_sram_write_byte+0xe>
       a_mcp794xx_print_error_msg(pHandle, "write to sram");
    3db6:	4908      	ldr	r1, [pc, #32]	; (3dd8 <mcp794xx_sram_write_byte+0x84>)
    3db8:	4479      	add	r1, pc
    3dba:	0020      	movs	r0, r4
    3dbc:	f7fd ffca 	bl	1d54 <a_mcp794xx_print_error_msg>
       return 1;
    3dc0:	0028      	movs	r0, r5
    3dc2:	e7ce      	b.n	3d62 <mcp794xx_sram_write_byte+0xe>
        return 2;     /**< return failed error */
    3dc4:	2002      	movs	r0, #2
    3dc6:	e7cc      	b.n	3d62 <mcp794xx_sram_write_byte+0xe>
    3dc8:	000041fc 	.word	0x000041fc
    3dcc:	000041a2 	.word	0x000041a2
    3dd0:	000041b0 	.word	0x000041b0
    3dd4:	1fffc532 	.word	0x1fffc532
    3dd8:	000041e4 	.word	0x000041e4

00003ddc <mcp794xx_sram_read_byte>:
*          - 3 pHandle is not initialized
*          - 4 invalid address
* @note none
*/
uint8_t mcp794xx_sram_read_byte(mcp794xx_handle_t *const pHandle, uint8_t addr, uint8_t *pBuffer, size_t length)
{
    3ddc:	b570      	push	{r4, r5, r6, lr}
    3dde:	1e04      	subs	r4, r0, #0

    if(pHandle == NULL)
    3de0:	d035      	beq.n	3e4e <mcp794xx_sram_read_byte+0x72>
        return 2;     /**< return failed error */
    if(pHandle->inited != 1)
    3de2:	7fc5      	ldrb	r5, [r0, #31]
    3de4:	2d01      	cmp	r5, #1
    3de6:	d001      	beq.n	3dec <mcp794xx_sram_read_byte+0x10>
        return 3;      /**< return failed error */
    3de8:	2003      	movs	r0, #3
       a_mcp794xx_print_error_msg(pHandle, "read sram");
       return 1;
    }

 return 0;          /**< success */
}
    3dea:	bd70      	pop	{r4, r5, r6, pc}
    if(addr > SRAM_LAST_ADDRESS || addr < SRAM_FIRST_ADDRESS)
    3dec:	0008      	movs	r0, r1
    3dee:	3820      	subs	r0, #32
    3df0:	b2c0      	uxtb	r0, r0
    3df2:	283f      	cmp	r0, #63	; 0x3f
    3df4:	d80c      	bhi.n	3e10 <mcp794xx_sram_read_byte+0x34>
    }if(length > SRAM_MEMORY_SIZE){
    3df6:	2b40      	cmp	r3, #64	; 0x40
    3df8:	d811      	bhi.n	3e1e <mcp794xx_sram_read_byte+0x42>
    }if((addr - SRAM_FIRST_ADDRESS)+ length > SRAM_MEMORY_SIZE){
    3dfa:	18c8      	adds	r0, r1, r3
    3dfc:	3820      	subs	r0, #32
    3dfe:	2840      	cmp	r0, #64	; 0x40
    3e00:	d914      	bls.n	3e2c <mcp794xx_sram_read_byte+0x50>
    	a_mcp794xx_print_error_msg(pHandle, "read sram, address out of range");
    3e02:	4914      	ldr	r1, [pc, #80]	; (3e54 <mcp794xx_sram_read_byte+0x78>)
    3e04:	4479      	add	r1, pc
    3e06:	0020      	movs	r0, r4
    3e08:	f7fd ffa4 	bl	1d54 <a_mcp794xx_print_error_msg>
    	return 5;
    3e0c:	2005      	movs	r0, #5
    3e0e:	e7ec      	b.n	3dea <mcp794xx_sram_read_byte+0xe>
    	a_mcp794xx_print_error_msg(pHandle, "read sram, invalid address");
    3e10:	4911      	ldr	r1, [pc, #68]	; (3e58 <mcp794xx_sram_read_byte+0x7c>)
    3e12:	4479      	add	r1, pc
    3e14:	0020      	movs	r0, r4
    3e16:	f7fd ff9d 	bl	1d54 <a_mcp794xx_print_error_msg>
    	return 4;
    3e1a:	2004      	movs	r0, #4
    3e1c:	e7e5      	b.n	3dea <mcp794xx_sram_read_byte+0xe>
    	a_mcp794xx_print_error_msg(pHandle, "read sram, address can't be greater than 0x5F");
    3e1e:	490f      	ldr	r1, [pc, #60]	; (3e5c <mcp794xx_sram_read_byte+0x80>)
    3e20:	4479      	add	r1, pc
    3e22:	0020      	movs	r0, r4
    3e24:	f7fd ff96 	bl	1d54 <a_mcp794xx_print_error_msg>
    	return 5;
    3e28:	2005      	movs	r0, #5
    3e2a:	e7de      	b.n	3dea <mcp794xx_sram_read_byte+0xe>
    err = rtc_mcp794xx_i2c_read(pHandle, addr, (uint8_t *)pBuffer, length);
    3e2c:	b2db      	uxtb	r3, r3
    3e2e:	b289      	uxth	r1, r1
    3e30:	0020      	movs	r0, r4
    3e32:	f7fd ff18 	bl	1c66 <rtc_mcp794xx_i2c_read>
    3e36:	4a0a      	ldr	r2, [pc, #40]	; (3e60 <mcp794xx_sram_read_byte+0x84>)
    3e38:	447a      	add	r2, pc
    3e3a:	7010      	strb	r0, [r2, #0]
    if(err)
    3e3c:	2800      	cmp	r0, #0
    3e3e:	d0d4      	beq.n	3dea <mcp794xx_sram_read_byte+0xe>
       a_mcp794xx_print_error_msg(pHandle, "read sram");
    3e40:	4908      	ldr	r1, [pc, #32]	; (3e64 <mcp794xx_sram_read_byte+0x88>)
    3e42:	4479      	add	r1, pc
    3e44:	0020      	movs	r0, r4
    3e46:	f7fd ff85 	bl	1d54 <a_mcp794xx_print_error_msg>
       return 1;
    3e4a:	0028      	movs	r0, r5
    3e4c:	e7cd      	b.n	3dea <mcp794xx_sram_read_byte+0xe>
        return 2;     /**< return failed error */
    3e4e:	2002      	movs	r0, #2
    3e50:	e7cb      	b.n	3dea <mcp794xx_sram_read_byte+0xe>
    3e52:	46c0      	nop			; (mov r8, r8)
    3e54:	000041f4 	.word	0x000041f4
    3e58:	0000419a 	.word	0x0000419a
    3e5c:	000041a8 	.word	0x000041a8
    3e60:	1fffc4a8 	.word	0x1fffc4a8
    3e64:	000041d6 	.word	0x000041d6

00003e68 <mcp794xx_sram_erase_selector>:
*          - 3 pHandle is not initialized
*          - 4 invalid address
* @note data from the start to the end address will be erased
*/
uint8_t mcp794xx_sram_erase_selector(mcp794xx_handle_t *const pHandle, uint8_t start_addr, uint8_t end_addr)
{
    3e68:	b5f0      	push	{r4, r5, r6, r7, lr}
    3e6a:	b083      	sub	sp, #12
    3e6c:	0005      	movs	r5, r0
    3e6e:	0017      	movs	r7, r2
	int index;
	uint8_t dummy_dada = 0x00;
    3e70:	2200      	movs	r2, #0
    3e72:	466b      	mov	r3, sp
    3e74:	71da      	strb	r2, [r3, #7]

    if(pHandle == NULL)
    3e76:	2800      	cmp	r0, #0
    3e78:	d035      	beq.n	3ee6 <mcp794xx_sram_erase_selector+0x7e>
        return 2;     /**< return failed error */
    if(pHandle->inited != 1)
    3e7a:	7fc4      	ldrb	r4, [r0, #31]
    3e7c:	2c01      	cmp	r4, #1
    3e7e:	d003      	beq.n	3e88 <mcp794xx_sram_erase_selector+0x20>
        return 3;      /**< return failed error */
    3e80:	2403      	movs	r4, #3
		   return 1;
		}
    }

	return 0;   /**< success */
}
    3e82:	0020      	movs	r0, r4
    3e84:	b003      	add	sp, #12
    3e86:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if(start_addr > SRAM_LAST_ADDRESS || start_addr < SRAM_FIRST_ADDRESS)
    3e88:	000b      	movs	r3, r1
    3e8a:	3b20      	subs	r3, #32
    3e8c:	b2db      	uxtb	r3, r3
    3e8e:	2b3f      	cmp	r3, #63	; 0x3f
    3e90:	d815      	bhi.n	3ebe <mcp794xx_sram_erase_selector+0x56>
    }if(end_addr > SRAM_LAST_ADDRESS || end_addr < SRAM_FIRST_ADDRESS){
    3e92:	003b      	movs	r3, r7
    3e94:	3b20      	subs	r3, #32
    3e96:	b2db      	uxtb	r3, r3
    3e98:	2b3f      	cmp	r3, #63	; 0x3f
    3e9a:	d816      	bhi.n	3eca <mcp794xx_sram_erase_selector+0x62>
    for(index = start_addr; index <= end_addr; index++)
    3e9c:	000e      	movs	r6, r1
    3e9e:	42be      	cmp	r6, r7
    3ea0:	dc1f      	bgt.n	3ee2 <mcp794xx_sram_erase_selector+0x7a>
		err = sram_mcp794xx_i2c_write(pHandle, index, (uint8_t *)&dummy_dada, 1);
    3ea2:	b2f1      	uxtb	r1, r6
    3ea4:	2301      	movs	r3, #1
    3ea6:	466a      	mov	r2, sp
    3ea8:	3207      	adds	r2, #7
    3eaa:	0028      	movs	r0, r5
    3eac:	f7fd ff31 	bl	1d12 <sram_mcp794xx_i2c_write>
    3eb0:	4b0e      	ldr	r3, [pc, #56]	; (3eec <mcp794xx_sram_erase_selector+0x84>)
    3eb2:	447b      	add	r3, pc
    3eb4:	7018      	strb	r0, [r3, #0]
		if(err)
    3eb6:	2800      	cmp	r0, #0
    3eb8:	d10d      	bne.n	3ed6 <mcp794xx_sram_erase_selector+0x6e>
    for(index = start_addr; index <= end_addr; index++)
    3eba:	3601      	adds	r6, #1
    3ebc:	e7ef      	b.n	3e9e <mcp794xx_sram_erase_selector+0x36>
    	a_mcp794xx_print_error_msg(pHandle, "erase sram sector, invalid address (0x20 - 0x57)");
    3ebe:	490c      	ldr	r1, [pc, #48]	; (3ef0 <mcp794xx_sram_erase_selector+0x88>)
    3ec0:	4479      	add	r1, pc
    3ec2:	f7fd ff47 	bl	1d54 <a_mcp794xx_print_error_msg>
    	return 4;
    3ec6:	3403      	adds	r4, #3
    3ec8:	e7db      	b.n	3e82 <mcp794xx_sram_erase_selector+0x1a>
    	a_mcp794xx_print_error_msg(pHandle, "erase sram sector, invalid address (0x20 - 0x57)");
    3eca:	490a      	ldr	r1, [pc, #40]	; (3ef4 <mcp794xx_sram_erase_selector+0x8c>)
    3ecc:	4479      	add	r1, pc
    3ece:	f7fd ff41 	bl	1d54 <a_mcp794xx_print_error_msg>
    	return 4;
    3ed2:	2404      	movs	r4, #4
    3ed4:	e7d5      	b.n	3e82 <mcp794xx_sram_erase_selector+0x1a>
		   a_mcp794xx_print_error_msg(pHandle, "erase sram sector");
    3ed6:	4908      	ldr	r1, [pc, #32]	; (3ef8 <mcp794xx_sram_erase_selector+0x90>)
    3ed8:	4479      	add	r1, pc
    3eda:	0028      	movs	r0, r5
    3edc:	f7fd ff3a 	bl	1d54 <a_mcp794xx_print_error_msg>
		   return 1;
    3ee0:	e7cf      	b.n	3e82 <mcp794xx_sram_erase_selector+0x1a>
	return 0;   /**< success */
    3ee2:	2400      	movs	r4, #0
    3ee4:	e7cd      	b.n	3e82 <mcp794xx_sram_erase_selector+0x1a>
        return 2;     /**< return failed error */
    3ee6:	2402      	movs	r4, #2
    3ee8:	e7cb      	b.n	3e82 <mcp794xx_sram_erase_selector+0x1a>
    3eea:	46c0      	nop			; (mov r8, r8)
    3eec:	1fffc42e 	.word	0x1fffc42e
    3ef0:	00004164 	.word	0x00004164
    3ef4:	00004158 	.word	0x00004158
    3ef8:	00004180 	.word	0x00004180

00003efc <mcp794xx_wipe_sram>:
*          - 2 pHandle is NULL
*          - 3 pHandle is not initialized
* @note none
*/
uint8_t mcp794xx_wipe_sram(mcp794xx_handle_t *const pHandle)
{
    3efc:	b530      	push	{r4, r5, lr}
    3efe:	b091      	sub	sp, #68	; 0x44
    3f00:	0004      	movs	r4, r0
    uint8_t temp_buffer[SRAM_MEMORY_SIZE];

    memset(temp_buffer, 0x00, sizeof(temp_buffer));
    3f02:	2240      	movs	r2, #64	; 0x40
    3f04:	2100      	movs	r1, #0
    3f06:	4668      	mov	r0, sp
    3f08:	f002 f953 	bl	61b2 <memset>

    if(pHandle == NULL)
    3f0c:	2c00      	cmp	r4, #0
    3f0e:	d017      	beq.n	3f40 <mcp794xx_wipe_sram+0x44>
        return 2;     /**< return failed error */
    if(pHandle->inited != 1)
    3f10:	7fe5      	ldrb	r5, [r4, #31]
    3f12:	2d01      	cmp	r5, #1
    3f14:	d002      	beq.n	3f1c <mcp794xx_wipe_sram+0x20>
        return 3;      /**< return failed error */
    3f16:	2003      	movs	r0, #3
	   a_mcp794xx_print_error_msg(pHandle, "wipe sram");
	   return 1;
	}

	return 0;    /**< success */
}
    3f18:	b011      	add	sp, #68	; 0x44
    3f1a:	bd30      	pop	{r4, r5, pc}
    err = sram_mcp794xx_i2c_write(pHandle, SRAM_FIRST_ADDRESS, (uint8_t *)temp_buffer, SRAM_MEMORY_SIZE);
    3f1c:	2340      	movs	r3, #64	; 0x40
    3f1e:	466a      	mov	r2, sp
    3f20:	2120      	movs	r1, #32
    3f22:	0020      	movs	r0, r4
    3f24:	f7fd fef5 	bl	1d12 <sram_mcp794xx_i2c_write>
    3f28:	4a06      	ldr	r2, [pc, #24]	; (3f44 <mcp794xx_wipe_sram+0x48>)
    3f2a:	447a      	add	r2, pc
    3f2c:	7010      	strb	r0, [r2, #0]
	if(err)
    3f2e:	2800      	cmp	r0, #0
    3f30:	d0f2      	beq.n	3f18 <mcp794xx_wipe_sram+0x1c>
	   a_mcp794xx_print_error_msg(pHandle, "wipe sram");
    3f32:	4905      	ldr	r1, [pc, #20]	; (3f48 <mcp794xx_wipe_sram+0x4c>)
    3f34:	4479      	add	r1, pc
    3f36:	0020      	movs	r0, r4
    3f38:	f7fd ff0c 	bl	1d54 <a_mcp794xx_print_error_msg>
	   return 1;
    3f3c:	0028      	movs	r0, r5
    3f3e:	e7eb      	b.n	3f18 <mcp794xx_wipe_sram+0x1c>
        return 2;     /**< return failed error */
    3f40:	2002      	movs	r0, #2
    3f42:	e7e9      	b.n	3f18 <mcp794xx_wipe_sram+0x1c>
    3f44:	1fffc3b6 	.word	0x1fffc3b6
    3f48:	00004138 	.word	0x00004138

00003f4c <mcp794xx_eeprom_read_byte>:
 *            - 4 invalid address
 *            - 5 invalid device variant
 * @note      none
 */
uint8_t mcp794xx_eeprom_read_byte(mcp794xx_handle_t *const pHandle, uint8_t u8Addr, uint8_t *pBuf, uint8_t length)
{
    3f4c:	b570      	push	{r4, r5, r6, lr}
    3f4e:	1e04      	subs	r4, r0, #0

    if(pHandle == NULL)
    3f50:	d038      	beq.n	3fc4 <mcp794xx_eeprom_read_byte+0x78>
        return 2;     /**< return failed error */
    if(pHandle->inited != 1)
    3f52:	7fc5      	ldrb	r5, [r0, #31]
    3f54:	2d01      	cmp	r5, #1
    3f56:	d001      	beq.n	3f5c <mcp794xx_eeprom_read_byte+0x10>
        return 3;      /**< return failed error */
    3f58:	2003      	movs	r0, #3
    	a_mcp794xx_print_error_msg(pHandle, "read eeprom");
        return 1;           /**< failed error */
    }

    return 0;              /**< success */
}
    3f5a:	bd70      	pop	{r4, r5, r6, pc}
    if(u8Addr < EEPROM_LOWEST_ADDRESS || u8Addr > EEPROM_HIGHEST_ADDRESS){
    3f5c:	b248      	sxtb	r0, r1
    3f5e:	2800      	cmp	r0, #0
    3f60:	db12      	blt.n	3f88 <mcp794xx_eeprom_read_byte+0x3c>
    }if((u8Addr + length) > EEPROM_MEMORY_SIZE)
    3f62:	18c8      	adds	r0, r1, r3
    3f64:	2880      	cmp	r0, #128	; 0x80
    3f66:	dc16      	bgt.n	3f96 <mcp794xx_eeprom_read_byte+0x4a>
    if(pHandle->device_variant == MCP79400_VARIANT || pHandle->device_variant == MCP7940M_VARIANT || pHandle->device_variant == MCP7940N_VARIANT || pHandle->device_variant == MCP79410_VARIANT){
    3f68:	7fa0      	ldrb	r0, [r4, #30]
    3f6a:	2800      	cmp	r0, #0
    3f6c:	d005      	beq.n	3f7a <mcp794xx_eeprom_read_byte+0x2e>
    3f6e:	2803      	cmp	r0, #3
    3f70:	d003      	beq.n	3f7a <mcp794xx_eeprom_read_byte+0x2e>
    3f72:	2804      	cmp	r0, #4
    3f74:	d001      	beq.n	3f7a <mcp794xx_eeprom_read_byte+0x2e>
    3f76:	2805      	cmp	r0, #5
    3f78:	d114      	bne.n	3fa4 <mcp794xx_eeprom_read_byte+0x58>
 	   a_mcp794xx_print_error_msg(pHandle, "invalid device variant, the device does have a eeprom built-in");
    3f7a:	4913      	ldr	r1, [pc, #76]	; (3fc8 <mcp794xx_eeprom_read_byte+0x7c>)
    3f7c:	4479      	add	r1, pc
    3f7e:	0020      	movs	r0, r4
    3f80:	f7fd fee8 	bl	1d54 <a_mcp794xx_print_error_msg>
 	   return 5;
    3f84:	2005      	movs	r0, #5
    3f86:	e7e8      	b.n	3f5a <mcp794xx_eeprom_read_byte+0xe>
    	a_mcp794xx_print_error_msg(pHandle, "to read eeprom, invalid address");
    3f88:	4910      	ldr	r1, [pc, #64]	; (3fcc <mcp794xx_eeprom_read_byte+0x80>)
    3f8a:	4479      	add	r1, pc
    3f8c:	0020      	movs	r0, r4
    3f8e:	f7fd fee1 	bl	1d54 <a_mcp794xx_print_error_msg>
    	return 4;
    3f92:	2004      	movs	r0, #4
    3f94:	e7e1      	b.n	3f5a <mcp794xx_eeprom_read_byte+0xe>
    	a_mcp794xx_print_error_msg(pHandle, "to read eeprom, address out of range");
    3f96:	490e      	ldr	r1, [pc, #56]	; (3fd0 <mcp794xx_eeprom_read_byte+0x84>)
    3f98:	4479      	add	r1, pc
    3f9a:	0020      	movs	r0, r4
    3f9c:	f7fd feda 	bl	1d54 <a_mcp794xx_print_error_msg>
    	return 4;
    3fa0:	2004      	movs	r0, #4
    3fa2:	e7da      	b.n	3f5a <mcp794xx_eeprom_read_byte+0xe>
    err = eeprom_mcp794xx_i2c_read(pHandle, u8Addr, (uint8_t *)pBuf, length);
    3fa4:	b289      	uxth	r1, r1
    3fa6:	0020      	movs	r0, r4
    3fa8:	f7fd fe98 	bl	1cdc <eeprom_mcp794xx_i2c_read>
    3fac:	4a09      	ldr	r2, [pc, #36]	; (3fd4 <mcp794xx_eeprom_read_byte+0x88>)
    3fae:	447a      	add	r2, pc
    3fb0:	7010      	strb	r0, [r2, #0]
    if(err)
    3fb2:	2800      	cmp	r0, #0
    3fb4:	d0d1      	beq.n	3f5a <mcp794xx_eeprom_read_byte+0xe>
    	a_mcp794xx_print_error_msg(pHandle, "read eeprom");
    3fb6:	4908      	ldr	r1, [pc, #32]	; (3fd8 <mcp794xx_eeprom_read_byte+0x8c>)
    3fb8:	4479      	add	r1, pc
    3fba:	0020      	movs	r0, r4
    3fbc:	f7fd feca 	bl	1d54 <a_mcp794xx_print_error_msg>
        return 1;           /**< failed error */
    3fc0:	0028      	movs	r0, r5
    3fc2:	e7ca      	b.n	3f5a <mcp794xx_eeprom_read_byte+0xe>
        return 2;     /**< return failed error */
    3fc4:	2002      	movs	r0, #2
    3fc6:	e7c8      	b.n	3f5a <mcp794xx_eeprom_read_byte+0xe>
    3fc8:	00004144 	.word	0x00004144
    3fcc:	000040ee 	.word	0x000040ee
    3fd0:	00004100 	.word	0x00004100
    3fd4:	1fffc332 	.word	0x1fffc332
    3fd8:	00004148 	.word	0x00004148

00003fdc <mcp794xx_eeprom_get_bp_status>:
 *            - 2 handle is NULL
 *            - 3 handle is not initialized
 * @note      none
 */
uint8_t mcp794xx_eeprom_get_bp_status(mcp794xx_handle_t *const pHandle, mcp794xx_eeprom_block_protect_stat_t *pStatus)
{
    3fdc:	b570      	push	{r4, r5, r6, lr}
    3fde:	b082      	sub	sp, #8
    3fe0:	0004      	movs	r4, r0
    3fe2:	000d      	movs	r5, r1
	uint8_t block_protect_status = 0;
    3fe4:	2200      	movs	r2, #0
    3fe6:	466b      	mov	r3, sp
    3fe8:	71da      	strb	r2, [r3, #7]

    if(pHandle == NULL)
    3fea:	2800      	cmp	r0, #0
    3fec:	d01e      	beq.n	402c <mcp794xx_eeprom_get_bp_status+0x50>
        return 2;     /**< return failed error */
    if(pHandle->inited != 1)
    3fee:	7fc6      	ldrb	r6, [r0, #31]
    3ff0:	2e01      	cmp	r6, #1
    3ff2:	d002      	beq.n	3ffa <mcp794xx_eeprom_get_bp_status+0x1e>
        return 3;      /**< return failed error */
    3ff4:	2003      	movs	r0, #3
    }

    *pStatus = (mcp794xx_eeprom_block_protect_stat_t)(block_protect_status & EEPROM_BLOCK_PROTECT_MASK) >> 2;

    return 0;               /**< success */
}
    3ff6:	b002      	add	sp, #8
    3ff8:	bd70      	pop	{r4, r5, r6, pc}
    err = eeprom_mcp794xx_i2c_read(pHandle, EEPROM_BLOCK_PROTECT_REG, (uint8_t *)&block_protect_status, 1);
    3ffa:	2301      	movs	r3, #1
    3ffc:	466a      	mov	r2, sp
    3ffe:	3207      	adds	r2, #7
    4000:	21ff      	movs	r1, #255	; 0xff
    4002:	f7fd fe6b 	bl	1cdc <eeprom_mcp794xx_i2c_read>
    4006:	4a0a      	ldr	r2, [pc, #40]	; (4030 <mcp794xx_eeprom_get_bp_status+0x54>)
    4008:	447a      	add	r2, pc
    400a:	7010      	strb	r0, [r2, #0]
    if(err)
    400c:	2800      	cmp	r0, #0
    400e:	d106      	bne.n	401e <mcp794xx_eeprom_get_bp_status+0x42>
    *pStatus = (mcp794xx_eeprom_block_protect_stat_t)(block_protect_status & EEPROM_BLOCK_PROTECT_MASK) >> 2;
    4010:	466b      	mov	r3, sp
    4012:	79da      	ldrb	r2, [r3, #7]
    4014:	1092      	asrs	r2, r2, #2
    4016:	2303      	movs	r3, #3
    4018:	4013      	ands	r3, r2
    401a:	702b      	strb	r3, [r5, #0]
    return 0;               /**< success */
    401c:	e7eb      	b.n	3ff6 <mcp794xx_eeprom_get_bp_status+0x1a>
    	a_mcp794xx_print_error_msg(pHandle, "read eeprom block protect reg");
    401e:	4905      	ldr	r1, [pc, #20]	; (4034 <mcp794xx_eeprom_get_bp_status+0x58>)
    4020:	4479      	add	r1, pc
    4022:	0020      	movs	r0, r4
    4024:	f7fd fe96 	bl	1d54 <a_mcp794xx_print_error_msg>
        return 1;           /**< failed error */
    4028:	0030      	movs	r0, r6
    402a:	e7e4      	b.n	3ff6 <mcp794xx_eeprom_get_bp_status+0x1a>
        return 2;     /**< return failed error */
    402c:	2002      	movs	r0, #2
    402e:	e7e2      	b.n	3ff6 <mcp794xx_eeprom_get_bp_status+0x1a>
    4030:	1fffc2d8 	.word	0x1fffc2d8
    4034:	0000410c 	.word	0x0000410c

00004038 <mcp794xx_eeprom_check_bp_before_write>:
 *          - 3 handle is not initialized
 *          - 4 invalid device variant
 * @note    none
 */
uint8_t mcp794xx_eeprom_check_bp_before_write(mcp794xx_handle_t *const pHandle, uint8_t u8Address)
{
    4038:	b570      	push	{r4, r5, r6, lr}
    403a:	b082      	sub	sp, #8
    403c:	0005      	movs	r5, r0
    403e:	000e      	movs	r6, r1
	uint8_t status;

    if(pHandle == NULL)
    4040:	2800      	cmp	r0, #0
    4042:	d03b      	beq.n	40bc <mcp794xx_eeprom_check_bp_before_write+0x84>
        return 2;     /**< return failed error */
    if(pHandle->inited != 1)
    4044:	7fc4      	ldrb	r4, [r0, #31]
    4046:	2c01      	cmp	r4, #1
    4048:	d003      	beq.n	4052 <mcp794xx_eeprom_check_bp_before_write+0x1a>
        return 3;      /**< return failed error */
    404a:	2403      	movs	r4, #3
			break;
		}
   }

    return 0;              /**< success */
}
    404c:	0020      	movs	r0, r4
    404e:	b002      	add	sp, #8
    4050:	bd70      	pop	{r4, r5, r6, pc}
   err = mcp794xx_eeprom_get_bp_status(pHandle, (uint8_t *)&status);
    4052:	466b      	mov	r3, sp
    4054:	1dd9      	adds	r1, r3, #7
    4056:	f7ff ffc1 	bl	3fdc <mcp794xx_eeprom_get_bp_status>
    405a:	4b19      	ldr	r3, [pc, #100]	; (40c0 <mcp794xx_eeprom_check_bp_before_write+0x88>)
    405c:	447b      	add	r3, pc
    405e:	7018      	strb	r0, [r3, #0]
   if(err != MCP794XX_DRV_OK){
    4060:	2800      	cmp	r0, #0
    4062:	d113      	bne.n	408c <mcp794xx_eeprom_check_bp_before_write+0x54>
   if(pHandle->device_variant == MCP79400_VARIANT || pHandle->device_variant == MCP7940M_VARIANT || pHandle->device_variant == MCP7940N_VARIANT || pHandle->device_variant == MCP79410_VARIANT){
    4064:	7fab      	ldrb	r3, [r5, #30]
    4066:	2b00      	cmp	r3, #0
    4068:	d019      	beq.n	409e <mcp794xx_eeprom_check_bp_before_write+0x66>
    406a:	2b03      	cmp	r3, #3
    406c:	d017      	beq.n	409e <mcp794xx_eeprom_check_bp_before_write+0x66>
    406e:	2b04      	cmp	r3, #4
    4070:	d015      	beq.n	409e <mcp794xx_eeprom_check_bp_before_write+0x66>
    4072:	2b05      	cmp	r3, #5
    4074:	d013      	beq.n	409e <mcp794xx_eeprom_check_bp_before_write+0x66>
   switch(status)
    4076:	466b      	mov	r3, sp
    4078:	3307      	adds	r3, #7
    407a:	781b      	ldrb	r3, [r3, #0]
    407c:	2b02      	cmp	r3, #2
    407e:	d019      	beq.n	40b4 <mcp794xx_eeprom_check_bp_before_write+0x7c>
    4080:	2b03      	cmp	r3, #3
    4082:	d0e3      	beq.n	404c <mcp794xx_eeprom_check_bp_before_write+0x14>
    4084:	2b01      	cmp	r3, #1
    4086:	d011      	beq.n	40ac <mcp794xx_eeprom_check_bp_before_write+0x74>
		   return 0;
    4088:	0004      	movs	r4, r0
    408a:	e7df      	b.n	404c <mcp794xx_eeprom_check_bp_before_write+0x14>
	   a_mcp794xx_print_error_msg(pHandle, "to verify memory block protect status");
    408c:	490d      	ldr	r1, [pc, #52]	; (40c4 <mcp794xx_eeprom_check_bp_before_write+0x8c>)
    408e:	4479      	add	r1, pc
    4090:	0028      	movs	r0, r5
    4092:	f7fd fe5f 	bl	1d54 <a_mcp794xx_print_error_msg>
	   return err;
    4096:	4b0c      	ldr	r3, [pc, #48]	; (40c8 <mcp794xx_eeprom_check_bp_before_write+0x90>)
    4098:	447b      	add	r3, pc
    409a:	781c      	ldrb	r4, [r3, #0]
    409c:	e7d6      	b.n	404c <mcp794xx_eeprom_check_bp_before_write+0x14>
	   a_mcp794xx_print_error_msg(pHandle, "invalid device variant, the device does have a eeprom built-in");
    409e:	490b      	ldr	r1, [pc, #44]	; (40cc <mcp794xx_eeprom_check_bp_before_write+0x94>)
    40a0:	4479      	add	r1, pc
    40a2:	0028      	movs	r0, r5
    40a4:	f7fd fe56 	bl	1d54 <a_mcp794xx_print_error_msg>
	   return 4;
    40a8:	2404      	movs	r4, #4
    40aa:	e7cf      	b.n	404c <mcp794xx_eeprom_check_bp_before_write+0x14>
			if (u8Address >= (uint8_t )(EEPROM_MEMORY_SIZE * 0.75))
    40ac:	2e5f      	cmp	r6, #95	; 0x5f
    40ae:	d8cd      	bhi.n	404c <mcp794xx_eeprom_check_bp_before_write+0x14>
				return 0;
    40b0:	0004      	movs	r4, r0
    40b2:	e7cb      	b.n	404c <mcp794xx_eeprom_check_bp_before_write+0x14>
			if (u8Address >= (uint8_t )(EEPROM_MEMORY_SIZE * 0.5))
    40b4:	2e3f      	cmp	r6, #63	; 0x3f
    40b6:	d8c9      	bhi.n	404c <mcp794xx_eeprom_check_bp_before_write+0x14>
				return 0;
    40b8:	0004      	movs	r4, r0
    40ba:	e7c7      	b.n	404c <mcp794xx_eeprom_check_bp_before_write+0x14>
        return 2;     /**< return failed error */
    40bc:	2402      	movs	r4, #2
    40be:	e7c5      	b.n	404c <mcp794xx_eeprom_check_bp_before_write+0x14>
    40c0:	1fffc284 	.word	0x1fffc284
    40c4:	000040be 	.word	0x000040be
    40c8:	1fffc248 	.word	0x1fffc248
    40cc:	00004020 	.word	0x00004020

000040d0 <mcp794xx_eeprom_write_byte>:
{
    40d0:	b5f0      	push	{r4, r5, r6, r7, lr}
    40d2:	b083      	sub	sp, #12
    40d4:	0004      	movs	r4, r0
    40d6:	000d      	movs	r5, r1
    40d8:	9201      	str	r2, [sp, #4]
    40da:	001e      	movs	r6, r3
    if(pHandle == NULL)
    40dc:	2800      	cmp	r0, #0
    40de:	d037      	beq.n	4150 <mcp794xx_eeprom_write_byte+0x80>
    if(pHandle->inited != 1)
    40e0:	7fc7      	ldrb	r7, [r0, #31]
    40e2:	2f01      	cmp	r7, #1
    40e4:	d002      	beq.n	40ec <mcp794xx_eeprom_write_byte+0x1c>
        return 3;      /**< return failed error */
    40e6:	2003      	movs	r0, #3
}
    40e8:	b003      	add	sp, #12
    40ea:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if(u8Addr < EEPROM_LOWEST_ADDRESS || u8Addr > EEPROM_HIGHEST_ADDRESS){
    40ec:	b24b      	sxtb	r3, r1
    40ee:	2b00      	cmp	r3, #0
    40f0:	db08      	blt.n	4104 <mcp794xx_eeprom_write_byte+0x34>
    }if((u8Addr + length) > EEPROM_MEMORY_SIZE)
    40f2:	198b      	adds	r3, r1, r6
    40f4:	2b80      	cmp	r3, #128	; 0x80
    40f6:	dd0b      	ble.n	4110 <mcp794xx_eeprom_write_byte+0x40>
    	a_mcp794xx_print_error_msg(pHandle, "to write eeprom, address out of range");
    40f8:	4916      	ldr	r1, [pc, #88]	; (4154 <mcp794xx_eeprom_write_byte+0x84>)
    40fa:	4479      	add	r1, pc
    40fc:	f7fd fe2a 	bl	1d54 <a_mcp794xx_print_error_msg>
    	return 4;
    4100:	2004      	movs	r0, #4
    4102:	e7f1      	b.n	40e8 <mcp794xx_eeprom_write_byte+0x18>
    	a_mcp794xx_print_error_msg(pHandle, "to write eeprom, invalid address");
    4104:	4914      	ldr	r1, [pc, #80]	; (4158 <mcp794xx_eeprom_write_byte+0x88>)
    4106:	4479      	add	r1, pc
    4108:	f7fd fe24 	bl	1d54 <a_mcp794xx_print_error_msg>
    	return 4;
    410c:	2004      	movs	r0, #4
    410e:	e7eb      	b.n	40e8 <mcp794xx_eeprom_write_byte+0x18>
    err = mcp794xx_eeprom_check_bp_before_write(pHandle, u8Addr);   /**< check to make sure that the address to write is not protected */
    4110:	f7ff ff92 	bl	4038 <mcp794xx_eeprom_check_bp_before_write>
    4114:	4b11      	ldr	r3, [pc, #68]	; (415c <mcp794xx_eeprom_write_byte+0x8c>)
    4116:	447b      	add	r3, pc
    4118:	7018      	strb	r0, [r3, #0]
    if(err != MCP794XX_DRV_OK)
    411a:	2800      	cmp	r0, #0
    411c:	d006      	beq.n	412c <mcp794xx_eeprom_write_byte+0x5c>
    	a_mcp794xx_print_error_msg(pHandle, "write eeprom, attempt to write a block protected region");
    411e:	4910      	ldr	r1, [pc, #64]	; (4160 <mcp794xx_eeprom_write_byte+0x90>)
    4120:	4479      	add	r1, pc
    4122:	0020      	movs	r0, r4
    4124:	f7fd fe16 	bl	1d54 <a_mcp794xx_print_error_msg>
    	return 5;
    4128:	2005      	movs	r0, #5
    412a:	e7dd      	b.n	40e8 <mcp794xx_eeprom_write_byte+0x18>
    err = eeprom_mcp794xx_i2c_write(pHandle, u8Addr, (uint8_t *)pBuf, length);
    412c:	0033      	movs	r3, r6
    412e:	9a01      	ldr	r2, [sp, #4]
    4130:	0029      	movs	r1, r5
    4132:	0020      	movs	r0, r4
    4134:	f7fd fdb2 	bl	1c9c <eeprom_mcp794xx_i2c_write>
    4138:	4a0a      	ldr	r2, [pc, #40]	; (4164 <mcp794xx_eeprom_write_byte+0x94>)
    413a:	447a      	add	r2, pc
    413c:	7010      	strb	r0, [r2, #0]
    if(err)
    413e:	2800      	cmp	r0, #0
    4140:	d0d2      	beq.n	40e8 <mcp794xx_eeprom_write_byte+0x18>
    	a_mcp794xx_print_error_msg(pHandle, "write eeprom");
    4142:	4909      	ldr	r1, [pc, #36]	; (4168 <mcp794xx_eeprom_write_byte+0x98>)
    4144:	4479      	add	r1, pc
    4146:	0020      	movs	r0, r4
    4148:	f7fd fe04 	bl	1d54 <a_mcp794xx_print_error_msg>
        return 1;           /**< failed error */
    414c:	0038      	movs	r0, r7
    414e:	e7cb      	b.n	40e8 <mcp794xx_eeprom_write_byte+0x18>
        return 2;     /**< return failed error */
    4150:	2002      	movs	r0, #2
    4152:	e7c9      	b.n	40e8 <mcp794xx_eeprom_write_byte+0x18>
    4154:	0000409e 	.word	0x0000409e
    4158:	0000406e 	.word	0x0000406e
    415c:	1fffc1ca 	.word	0x1fffc1ca
    4160:	000040a0 	.word	0x000040a0
    4164:	1fffc1a6 	.word	0x1fffc1a6
    4168:	000040b4 	.word	0x000040b4

0000416c <mcp794xx_eeprom_get_legth>:
 * @note      Tgis function returns the eeprom size
 */
uint8_t mcp794xx_eeprom_get_legth(mcp794xx_handle_t *const pHandle)
{

    if(pHandle == NULL)
    416c:	2800      	cmp	r0, #0
    416e:	d004      	beq.n	417a <mcp794xx_eeprom_get_legth+0xe>
        return 2;     /**< return failed error */
    if(pHandle->inited != 1)
    4170:	7fc3      	ldrb	r3, [r0, #31]
    4172:	2b01      	cmp	r3, #1
    4174:	d003      	beq.n	417e <mcp794xx_eeprom_get_legth+0x12>
        return 3;      /**< return failed error */
    4176:	2003      	movs	r0, #3

    return EEPROM_MEMORY_SIZE;              /**< success */
}
    4178:	4770      	bx	lr
        return 2;     /**< return failed error */
    417a:	2002      	movs	r0, #2
    417c:	e7fc      	b.n	4178 <mcp794xx_eeprom_get_legth+0xc>
    return EEPROM_MEMORY_SIZE;              /**< success */
    417e:	2080      	movs	r0, #128	; 0x80
    4180:	e7fa      	b.n	4178 <mcp794xx_eeprom_get_legth+0xc>
	...

00004184 <mcp794xx_eeprom_validate_page_boundary>:
{
    4184:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    4186:	0007      	movs	r7, r0
    4188:	000c      	movs	r4, r1
    418a:	0015      	movs	r5, r2
    if(pHandle == NULL)
    418c:	2800      	cmp	r0, #0
    418e:	d038      	beq.n	4202 <mcp794xx_eeprom_validate_page_boundary+0x7e>
    if(pHandle->inited != 1)
    4190:	7fc3      	ldrb	r3, [r0, #31]
    4192:	2b01      	cmp	r3, #1
    4194:	d001      	beq.n	419a <mcp794xx_eeprom_validate_page_boundary+0x16>
        return 3;      /**< return failed error */
    4196:	2003      	movs	r0, #3
}
    4198:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    419a:	2600      	movs	r6, #0
    for (index = 0; index < (mcp794xx_eeprom_get_legth(pHandle) / EEPROM_PAGE_SIZE); index++)
    419c:	0038      	movs	r0, r7
    419e:	f7ff ffe5 	bl	416c <mcp794xx_eeprom_get_legth>
    41a2:	08c0      	lsrs	r0, r0, #3
    41a4:	b2c0      	uxtb	r0, r0
    41a6:	4286      	cmp	r6, r0
    41a8:	da29      	bge.n	41fe <mcp794xx_eeprom_validate_page_boundary+0x7a>
        if ((index * EEPROM_PAGE_SIZE) > u8Address) /**< get start address page number(index) */
    41aa:	00f3      	lsls	r3, r6, #3
    41ac:	42a3      	cmp	r3, r4
    41ae:	dc01      	bgt.n	41b4 <mcp794xx_eeprom_validate_page_boundary+0x30>
    for (index = 0; index < (mcp794xx_eeprom_get_legth(pHandle) / EEPROM_PAGE_SIZE); index++)
    41b0:	3601      	adds	r6, #1
    41b2:	e7f3      	b.n	419c <mcp794xx_eeprom_validate_page_boundary+0x18>
        	status = (u8Address + u8Length) / (float) EEPROM_PAGE_SIZE;
    41b4:	1928      	adds	r0, r5, r4
    41b6:	f001 f9af 	bl	5518 <__aeabi_i2f>
    41ba:	21f8      	movs	r1, #248	; 0xf8
    41bc:	0589      	lsls	r1, r1, #22
    41be:	f000 fecf 	bl	4f60 <__aeabi_fmul>
            res = ceil(status);
    41c2:	f001 fe3d 	bl	5e40 <__aeabi_f2d>
    41c6:	f000 fc4b 	bl	4a60 <ceil>
    41ca:	f001 fe05 	bl	5dd8 <__aeabi_d2iz>
            if (res > index)
    41ce:	4286      	cmp	r6, r0
    41d0:	db01      	blt.n	41d6 <mcp794xx_eeprom_validate_page_boundary+0x52>
    return 0;               /**< success */
    41d2:	2000      	movs	r0, #0
    41d4:	e7e0      	b.n	4198 <mcp794xx_eeprom_validate_page_boundary+0x14>
                startAdress = (uint16_t) (EEPROM_PAGE_SIZE * (index - 1));
    41d6:	1e74      	subs	r4, r6, #1
    41d8:	b2a4      	uxth	r4, r4
    41da:	00e4      	lsls	r4, r4, #3
    41dc:	b2a4      	uxth	r4, r4
                endAddress = (startAdress + EEPROM_PAGE_SIZE) - 1;
    41de:	1de5      	adds	r5, r4, #7
    41e0:	b2ad      	uxth	r5, r5
                a_mcp794xx_print_error_msg(pHandle, "to execute, attempt to write beyond page boundary");
    41e2:	4909      	ldr	r1, [pc, #36]	; (4208 <mcp794xx_eeprom_validate_page_boundary+0x84>)
    41e4:	4479      	add	r1, pc
    41e6:	0038      	movs	r0, r7
    41e8:	f7fd fdb4 	bl	1d54 <a_mcp794xx_print_error_msg>
                pHandle->debug_print("mcp794xx: page %d start address:%d end address:%d\r\n", index, startAdress, endAddress);
    41ec:	697f      	ldr	r7, [r7, #20]
    41ee:	002b      	movs	r3, r5
    41f0:	0022      	movs	r2, r4
    41f2:	0031      	movs	r1, r6
    41f4:	4805      	ldr	r0, [pc, #20]	; (420c <mcp794xx_eeprom_validate_page_boundary+0x88>)
    41f6:	4478      	add	r0, pc
    41f8:	47b8      	blx	r7
                return 6; /**< return failed error **/
    41fa:	2006      	movs	r0, #6
    41fc:	e7cc      	b.n	4198 <mcp794xx_eeprom_validate_page_boundary+0x14>
    return 0;               /**< success */
    41fe:	2000      	movs	r0, #0
    4200:	e7ca      	b.n	4198 <mcp794xx_eeprom_validate_page_boundary+0x14>
        return 2;     /**< return failed error */
    4202:	2002      	movs	r0, #2
    4204:	e7c8      	b.n	4198 <mcp794xx_eeprom_validate_page_boundary+0x14>
    4206:	46c0      	nop			; (mov r8, r8)
    4208:	000040e8 	.word	0x000040e8
    420c:	0000410a 	.word	0x0000410a

00004210 <mcp794xx_eeprom_put_byte>:
{
    4210:	b5f0      	push	{r4, r5, r6, r7, lr}
    4212:	46c6      	mov	lr, r8
    4214:	b500      	push	{lr}
    4216:	b082      	sub	sp, #8
    4218:	0005      	movs	r5, r0
    421a:	9101      	str	r1, [sp, #4]
    421c:	0014      	movs	r4, r2
    421e:	001e      	movs	r6, r3
    if(pHandle == NULL)
    4220:	2800      	cmp	r0, #0
    4222:	d04a      	beq.n	42ba <mcp794xx_eeprom_put_byte+0xaa>
    if(pHandle->inited != 1)
    4224:	7fc7      	ldrb	r7, [r0, #31]
    4226:	2f01      	cmp	r7, #1
    4228:	d005      	beq.n	4236 <mcp794xx_eeprom_put_byte+0x26>
        return 3;      /**< return failed error */
    422a:	2403      	movs	r4, #3
}
    422c:	0020      	movs	r0, r4
    422e:	b002      	add	sp, #8
    4230:	bc04      	pop	{r2}
    4232:	4690      	mov	r8, r2
    4234:	bdf0      	pop	{r4, r5, r6, r7, pc}
    pTemp_buffer = (uint8_t*)calloc(u8Length, sizeof(uint8_t));
    4236:	2101      	movs	r1, #1
    4238:	0018      	movs	r0, r3
    423a:	f001 ff79 	bl	6130 <calloc>
    423e:	4680      	mov	r8, r0
	if(pTemp_buffer == NULL)
    4240:	2800      	cmp	r0, #0
    4242:	d010      	beq.n	4266 <mcp794xx_eeprom_put_byte+0x56>
    memcpy(pTemp_buffer, pBuf, u8Length);
    4244:	0032      	movs	r2, r6
    4246:	0021      	movs	r1, r4
    4248:	4640      	mov	r0, r8
    424a:	f001 ffa9 	bl	61a0 <memcpy>
    err = mcp794xx_eeprom_validate_page_boundary(pHandle, u8Addr, u8Length);
    424e:	0032      	movs	r2, r6
    4250:	9901      	ldr	r1, [sp, #4]
    4252:	0028      	movs	r0, r5
    4254:	f7ff ff96 	bl	4184 <mcp794xx_eeprom_validate_page_boundary>
    4258:	0004      	movs	r4, r0
    425a:	4b19      	ldr	r3, [pc, #100]	; (42c0 <mcp794xx_eeprom_put_byte+0xb0>)
    425c:	447b      	add	r3, pc
    425e:	7018      	strb	r0, [r3, #0]
    if(err != MCP794XX_DRV_OK){
    4260:	2800      	cmp	r0, #0
    4262:	d010      	beq.n	4286 <mcp794xx_eeprom_put_byte+0x76>
    4264:	e7e2      	b.n	422c <mcp794xx_eeprom_put_byte+0x1c>
		pHandle->debug_print("failed to allocate dynamic memory\n\r");
    4266:	4817      	ldr	r0, [pc, #92]	; (42c4 <mcp794xx_eeprom_put_byte+0xb4>)
    4268:	4478      	add	r0, pc
    426a:	696b      	ldr	r3, [r5, #20]
    426c:	4798      	blx	r3
    426e:	e7e9      	b.n	4244 <mcp794xx_eeprom_put_byte+0x34>
		dataOut = pTemp_buffer[index];
    4270:	4643      	mov	r3, r8
    4272:	191a      	adds	r2, r3, r4
    4274:	7811      	ldrb	r1, [r2, #0]
		pTemp_buffer[index] = pTemp_buffer[u8Length - index - 1];
    4276:	1b33      	subs	r3, r6, r4
    4278:	3b01      	subs	r3, #1
    427a:	4443      	add	r3, r8
    427c:	7818      	ldrb	r0, [r3, #0]
    427e:	7010      	strb	r0, [r2, #0]
		pTemp_buffer[u8Length - index - 1] = dataOut;
    4280:	7019      	strb	r1, [r3, #0]
	for (index = 0; index < (uint8_t)u8Length / 2; index++)
    4282:	3401      	adds	r4, #1
    4284:	b2e4      	uxtb	r4, r4
    4286:	0873      	lsrs	r3, r6, #1
    4288:	429c      	cmp	r4, r3
    428a:	d3f1      	bcc.n	4270 <mcp794xx_eeprom_put_byte+0x60>
	err = mcp794xx_eeprom_write_byte(pHandle, u8Addr, (uint8_t *)pTemp_buffer, u8Length);
    428c:	0033      	movs	r3, r6
    428e:	4642      	mov	r2, r8
    4290:	9901      	ldr	r1, [sp, #4]
    4292:	0028      	movs	r0, r5
    4294:	f7ff ff1c 	bl	40d0 <mcp794xx_eeprom_write_byte>
    4298:	0004      	movs	r4, r0
    429a:	4b0b      	ldr	r3, [pc, #44]	; (42c8 <mcp794xx_eeprom_put_byte+0xb8>)
    429c:	447b      	add	r3, pc
    429e:	7018      	strb	r0, [r3, #0]
	if (err)
    42a0:	2800      	cmp	r0, #0
    42a2:	d103      	bne.n	42ac <mcp794xx_eeprom_put_byte+0x9c>
	free(pTemp_buffer);
    42a4:	4640      	mov	r0, r8
    42a6:	f001 ff71 	bl	618c <free>
    return 0;              /**< success */
    42aa:	e7bf      	b.n	422c <mcp794xx_eeprom_put_byte+0x1c>
		a_mcp794xx_print_error_msg(pHandle, "put bytes");
    42ac:	4907      	ldr	r1, [pc, #28]	; (42cc <mcp794xx_eeprom_put_byte+0xbc>)
    42ae:	4479      	add	r1, pc
    42b0:	0028      	movs	r0, r5
    42b2:	f7fd fd4f 	bl	1d54 <a_mcp794xx_print_error_msg>
		return 1; /**< failed to write */
    42b6:	003c      	movs	r4, r7
    42b8:	e7b8      	b.n	422c <mcp794xx_eeprom_put_byte+0x1c>
        return 2;     /**< return failed error */
    42ba:	2402      	movs	r4, #2
    42bc:	e7b6      	b.n	422c <mcp794xx_eeprom_put_byte+0x1c>
    42be:	46c0      	nop			; (mov r8, r8)
    42c0:	1fffc084 	.word	0x1fffc084
    42c4:	00002c68 	.word	0x00002c68
    42c8:	1fffc044 	.word	0x1fffc044
    42cc:	00004086 	.word	0x00004086

000042d0 <mcp794xx_eeprom_get_byte>:
{
    42d0:	b5f0      	push	{r4, r5, r6, r7, lr}
    42d2:	46c6      	mov	lr, r8
    42d4:	b500      	push	{lr}
    42d6:	b082      	sub	sp, #8
    42d8:	0007      	movs	r7, r0
    42da:	9100      	str	r1, [sp, #0]
    42dc:	9201      	str	r2, [sp, #4]
    42de:	001d      	movs	r5, r3
    if(pHandle == NULL)
    42e0:	2800      	cmp	r0, #0
    42e2:	d046      	beq.n	4372 <mcp794xx_eeprom_get_byte+0xa2>
    if(pHandle->inited != 1)
    42e4:	7fc6      	ldrb	r6, [r0, #31]
    42e6:	2e01      	cmp	r6, #1
    42e8:	d005      	beq.n	42f6 <mcp794xx_eeprom_get_byte+0x26>
        return 3;      /**< return failed error */
    42ea:	2403      	movs	r4, #3
}
    42ec:	0020      	movs	r0, r4
    42ee:	b002      	add	sp, #8
    42f0:	bc04      	pop	{r2}
    42f2:	4690      	mov	r8, r2
    42f4:	bdf0      	pop	{r4, r5, r6, r7, pc}
	temp_buffer = (uint8_t*)calloc(u8Length, sizeof(uint8_t));
    42f6:	2101      	movs	r1, #1
    42f8:	0018      	movs	r0, r3
    42fa:	f001 ff19 	bl	6130 <calloc>
    42fe:	4680      	mov	r8, r0
    err = mcp794xx_eeprom_validate_page_boundary(pHandle, u8Addr, u8Length);
    4300:	002a      	movs	r2, r5
    4302:	9900      	ldr	r1, [sp, #0]
    4304:	0038      	movs	r0, r7
    4306:	f7ff ff3d 	bl	4184 <mcp794xx_eeprom_validate_page_boundary>
    430a:	0004      	movs	r4, r0
    430c:	4b1a      	ldr	r3, [pc, #104]	; (4378 <mcp794xx_eeprom_get_byte+0xa8>)
    430e:	447b      	add	r3, pc
    4310:	7018      	strb	r0, [r3, #0]
    if(err != MCP794XX_DRV_OK){
    4312:	2800      	cmp	r0, #0
    4314:	d1ea      	bne.n	42ec <mcp794xx_eeprom_get_byte+0x1c>
    err = (mcp794xx_eeprom_read_byte(pHandle, u8Addr, (uint8_t*) temp_buffer, u8Length));
    4316:	002b      	movs	r3, r5
    4318:	4642      	mov	r2, r8
    431a:	9900      	ldr	r1, [sp, #0]
    431c:	0038      	movs	r0, r7
    431e:	f7ff fe15 	bl	3f4c <mcp794xx_eeprom_read_byte>
    4322:	0004      	movs	r4, r0
    4324:	4b15      	ldr	r3, [pc, #84]	; (437c <mcp794xx_eeprom_get_byte+0xac>)
    4326:	447b      	add	r3, pc
    4328:	7018      	strb	r0, [r3, #0]
    if (err != MCP794XX_DRV_OK)
    432a:	2800      	cmp	r0, #0
    432c:	d011      	beq.n	4352 <mcp794xx_eeprom_get_byte+0x82>
    	a_mcp794xx_print_error_msg(pHandle, "get bytes");
    432e:	4914      	ldr	r1, [pc, #80]	; (4380 <mcp794xx_eeprom_get_byte+0xb0>)
    4330:	4479      	add	r1, pc
    4332:	0038      	movs	r0, r7
    4334:	f7fd fd0e 	bl	1d54 <a_mcp794xx_print_error_msg>
        return 1; /**< return error code */
    4338:	0034      	movs	r4, r6
    433a:	e7d7      	b.n	42ec <mcp794xx_eeprom_get_byte+0x1c>
        dataOut = temp_buffer[index];
    433c:	4643      	mov	r3, r8
    433e:	181a      	adds	r2, r3, r0
    4340:	7811      	ldrb	r1, [r2, #0]
        temp_buffer[index] = temp_buffer[u8Length - index - 1];
    4342:	1a2b      	subs	r3, r5, r0
    4344:	3b01      	subs	r3, #1
    4346:	4443      	add	r3, r8
    4348:	781e      	ldrb	r6, [r3, #0]
    434a:	7016      	strb	r6, [r2, #0]
        temp_buffer[u8Length - index - 1] = dataOut;
    434c:	7019      	strb	r1, [r3, #0]
    for (index = 0; index < (uint8_t)u8Length / 2; index++)
    434e:	3001      	adds	r0, #1
    4350:	b2c0      	uxtb	r0, r0
    4352:	086b      	lsrs	r3, r5, #1
    4354:	4298      	cmp	r0, r3
    4356:	d3f1      	bcc.n	433c <mcp794xx_eeprom_get_byte+0x6c>
    memcpy(eeprom.buffer, temp_buffer, u8Length);
    4358:	4e0a      	ldr	r6, [pc, #40]	; (4384 <mcp794xx_eeprom_get_byte+0xb4>)
    435a:	447e      	add	r6, pc
    435c:	1d30      	adds	r0, r6, #4
    435e:	002a      	movs	r2, r5
    4360:	4641      	mov	r1, r8
    4362:	f001 ff1d 	bl	61a0 <memcpy>
    *pBuf = (uint32_t)eeprom.data;
    4366:	6873      	ldr	r3, [r6, #4]
    4368:	9300      	str	r3, [sp, #0]
    436a:	9b01      	ldr	r3, [sp, #4]
    436c:	9a00      	ldr	r2, [sp, #0]
    436e:	601a      	str	r2, [r3, #0]
    return 0;              /**< success */
    4370:	e7bc      	b.n	42ec <mcp794xx_eeprom_get_byte+0x1c>
        return 2;     /**< return failed error */
    4372:	2402      	movs	r4, #2
    4374:	e7ba      	b.n	42ec <mcp794xx_eeprom_get_byte+0x1c>
    4376:	46c0      	nop			; (mov r8, r8)
    4378:	1fffbfd2 	.word	0x1fffbfd2
    437c:	1fffbfba 	.word	0x1fffbfba
    4380:	00004010 	.word	0x00004010
    4384:	1fffbf86 	.word	0x1fffbf86

00004388 <mcp794xx_info>:
 *             - 0 success
 *             - 2 pHandle is NULL
 * @note       none
 */
uint8_t mcp794xx_info(mcp794xx_handle_t *const pHandle)
{
    4388:	b510      	push	{r4, lr}
    438a:	0004      	movs	r4, r0

    strncpy(pHandle->info.chip_name, CHIP_NAME, 10);                        /**< copy chip name */
    438c:	3024      	adds	r0, #36	; 0x24
    438e:	220a      	movs	r2, #10
    4390:	4912      	ldr	r1, [pc, #72]	; (43dc <mcp794xx_info+0x54>)
    4392:	4479      	add	r1, pc
    4394:	f001 ffe5 	bl	6362 <strncpy>
    strncpy(pHandle->info.interface, INTERFACE, 5);                         /**< copy interface name */
    4398:	0020      	movs	r0, r4
    439a:	3047      	adds	r0, #71	; 0x47
    439c:	2205      	movs	r2, #5
    439e:	4910      	ldr	r1, [pc, #64]	; (43e0 <mcp794xx_info+0x58>)
    43a0:	4479      	add	r1, pc
    43a2:	f001 ffde 	bl	6362 <strncpy>
    strncpy(pHandle->info.manufacturer_name, MANUFACTURER_NAME, 25);        /**< copy manufacturer name */
    43a6:	0020      	movs	r0, r4
    43a8:	302e      	adds	r0, #46	; 0x2e
    43aa:	2219      	movs	r2, #25
    43ac:	490d      	ldr	r1, [pc, #52]	; (43e4 <mcp794xx_info+0x5c>)
    43ae:	4479      	add	r1, pc
    43b0:	f001 ffd7 	bl	6362 <strncpy>
    pHandle->info.supply_voltage_max_v = SUPPLY_VOLTAGE_MAX;                /**< set minimal supply voltage */
    43b4:	4b0c      	ldr	r3, [pc, #48]	; (43e8 <mcp794xx_info+0x60>)
    43b6:	6523      	str	r3, [r4, #80]	; 0x50
    pHandle->info.supply_voltage_min_v = SUPPLY_VOLTAGE_MIN;                /**< set maximum supply voltage */
    43b8:	4b0c      	ldr	r3, [pc, #48]	; (43ec <mcp794xx_info+0x64>)
    43ba:	64e3      	str	r3, [r4, #76]	; 0x4c
    pHandle->info.max_current_ma = MAX_CURRENT;                             /**< set maximum current */
    43bc:	4b0c      	ldr	r3, [pc, #48]	; (43f0 <mcp794xx_info+0x68>)
    43be:	6563      	str	r3, [r4, #84]	; 0x54
    pHandle->info.temperature_max = TEMPERATURE_MAX;                        /**< set minimal temperature */
    43c0:	4b0c      	ldr	r3, [pc, #48]	; (43f4 <mcp794xx_info+0x6c>)
    43c2:	65e3      	str	r3, [r4, #92]	; 0x5c
    pHandle->info.temperature_min = TEMPERATURE_MIN;                        /**< set maximum temperature */
    43c4:	4b0c      	ldr	r3, [pc, #48]	; (43f8 <mcp794xx_info+0x70>)
    43c6:	65a3      	str	r3, [r4, #88]	; 0x58
    pHandle->info.flash_size_min = MCU_FLASH_MIN;                           /**< set the Micro-controller minimum recommended flash size */
    43c8:	2240      	movs	r2, #64	; 0x40
    43ca:	2360      	movs	r3, #96	; 0x60
    43cc:	54e2      	strb	r2, [r4, r3]
    pHandle->info.ram_size_min = MCU_RAM_MIN;                               /**< set the Micro-controller minimum recommended ram size */
    43ce:	3a38      	subs	r2, #56	; 0x38
    43d0:	3301      	adds	r3, #1
    43d2:	54e2      	strb	r2, [r4, r3]
    pHandle->info.driver_version = DRIVER_VERSION;                          /**< set driver version */
    43d4:	4b09      	ldr	r3, [pc, #36]	; (43fc <mcp794xx_info+0x74>)
    43d6:	6663      	str	r3, [r4, #100]	; 0x64

    return 0;
}
    43d8:	2000      	movs	r0, #0
    43da:	bd10      	pop	{r4, pc}
    43dc:	00003fda 	.word	0x00003fda
    43e0:	00003fd8 	.word	0x00003fd8
    43e4:	00003fce 	.word	0x00003fce
    43e8:	40b00000 	.word	0x40b00000
    43ec:	3fa66666 	.word	0x3fa66666
    43f0:	43c80000 	.word	0x43c80000
    43f4:	42aa0000 	.word	0x42aa0000
    43f8:	c2200000 	.word	0xc2200000
    43fc:	447a0000 	.word	0x447a0000

00004400 <mcp794xx_basic_initialize>:
 *          - 1 initialize failed
 * @note    none
 */

uint8_t mcp794xx_basic_initialize(mcp794xx_variant_t variant)
{
    4400:	b570      	push	{r4, r5, r6, lr}
    4402:	b082      	sub	sp, #8
    4404:	0006      	movs	r6, r0
    4406:	4d67      	ldr	r5, [pc, #412]	; (45a4 <mcp794xx_basic_initialize+0x1a4>)
    4408:	447d      	add	r5, pc
   /*link function*/
    DRIVER_MCP794XX_LINK_INIT(&mcp794xx_handler, mcp794xx_handle_t);                               /**< Link the  */
    440a:	4c67      	ldr	r4, [pc, #412]	; (45a8 <mcp794xx_basic_initialize+0x1a8>)
    440c:	447c      	add	r4, pc
    440e:	2274      	movs	r2, #116	; 0x74
    4410:	2100      	movs	r1, #0
    4412:	0020      	movs	r0, r4
    4414:	f001 fecd 	bl	61b2 <memset>
    DRIVER_MCP794XX_LINK_I2C_INIT(&mcp794xx_handler, mcp794xx_interface_i2c_init);                 /**< Link the i2c initialize function */
    4418:	4b64      	ldr	r3, [pc, #400]	; (45ac <mcp794xx_basic_initialize+0x1ac>)
    441a:	58eb      	ldr	r3, [r5, r3]
    441c:	9301      	str	r3, [sp, #4]
    441e:	6023      	str	r3, [r4, #0]
    DRIVER_MCP794XX_LINK_I2C_DEINIT(&mcp794xx_handler, mcp794xx_interface_i2c_deinit);             /**< Link the the i2c de-initialize function */
    4420:	4b63      	ldr	r3, [pc, #396]	; (45b0 <mcp794xx_basic_initialize+0x1b0>)
    4422:	58eb      	ldr	r3, [r5, r3]
    4424:	9301      	str	r3, [sp, #4]
    4426:	6063      	str	r3, [r4, #4]
    DRIVER_MCP794XX_LINK_I2C_WRITE(&mcp794xx_handler, mcp794xx_interface_i2c_write);               /**< Link the i2c  write function */
    4428:	4b62      	ldr	r3, [pc, #392]	; (45b4 <mcp794xx_basic_initialize+0x1b4>)
    442a:	58eb      	ldr	r3, [r5, r3]
    442c:	9301      	str	r3, [sp, #4]
    442e:	60e3      	str	r3, [r4, #12]
    DRIVER_MCP794XX_LINK_I2C_READ(&mcp794xx_handler, mcp794xx_interface_i2c_read);                 /**< Link the i2c read function */
    4430:	4b61      	ldr	r3, [pc, #388]	; (45b8 <mcp794xx_basic_initialize+0x1b8>)
    4432:	58eb      	ldr	r3, [r5, r3]
    4434:	9301      	str	r3, [sp, #4]
    4436:	60a3      	str	r3, [r4, #8]
    DRIVER_MCP794XX_LINK_DELAY_MS(&mcp794xx_handler,mcp794xx_interface_delay_ms);                  /**< Link delay function */
    4438:	4b60      	ldr	r3, [pc, #384]	; (45bc <mcp794xx_basic_initialize+0x1bc>)
    443a:	58eb      	ldr	r3, [r5, r3]
    443c:	9301      	str	r3, [sp, #4]
    443e:	6123      	str	r3, [r4, #16]
    DRIVER_MCP794XX_LINK_DEBUG_PRINT(&mcp794xx_handler, mcp794xx_interface_debug_print);           /**< Link the debug print function */
    4440:	4b5f      	ldr	r3, [pc, #380]	; (45c0 <mcp794xx_basic_initialize+0x1c0>)
    4442:	58eb      	ldr	r3, [r5, r3]
    4444:	9301      	str	r3, [sp, #4]
    4446:	6163      	str	r3, [r4, #20]
    DRIVER_MCP794XX_LINK_RECEIVE_CALLBACK(&mcp794xx_handler, mcp794xx_interface_irq_callback);     /**< Link the IRQ callback function */
    4448:	4b5e      	ldr	r3, [pc, #376]	; (45c4 <mcp794xx_basic_initialize+0x1c4>)
    444a:	58eb      	ldr	r3, [r5, r3]
    444c:	9301      	str	r3, [sp, #4]
    444e:	61a3      	str	r3, [r4, #24]

    /* initialize */
    err = mcp794xx_init(&mcp794xx_handler);
    4450:	0020      	movs	r0, r4
    4452:	f7fd fca1 	bl	1d98 <mcp794xx_init>
    4456:	2374      	movs	r3, #116	; 0x74
    4458:	54e0      	strb	r0, [r4, r3]
    if(err)
    445a:	2800      	cmp	r0, #0
    445c:	d000      	beq.n	4460 <mcp794xx_basic_initialize+0x60>
    445e:	e096      	b.n	458e <mcp794xx_basic_initialize+0x18e>
       mcp794xx_interface_debug_print("initialize");
        return err; /**< return error code */       /**< failed */
    }

        /* set device variant */
    err = mcp794xx_set_variant(&mcp794xx_handler, variant);
    4460:	4d59      	ldr	r5, [pc, #356]	; (45c8 <mcp794xx_basic_initialize+0x1c8>)
    4462:	447d      	add	r5, pc
    4464:	0031      	movs	r1, r6
    4466:	0028      	movs	r0, r5
    4468:	f7fd fd22 	bl	1eb0 <mcp794xx_set_variant>
    446c:	0004      	movs	r4, r0
    446e:	2374      	movs	r3, #116	; 0x74
    4470:	54e8      	strb	r0, [r5, r3]
    if(err)
    4472:	2800      	cmp	r0, #0
    4474:	d000      	beq.n	4478 <mcp794xx_basic_initialize+0x78>
    4476:	e092      	b.n	459e <mcp794xx_basic_initialize+0x19e>
    {
        return err; /**< return error code */   /**< failed */
    }

    /* set i2c address mask */
    err = mcp794xx_set_addr_pin(&mcp794xx_handler);
    4478:	4d54      	ldr	r5, [pc, #336]	; (45cc <mcp794xx_basic_initialize+0x1cc>)
    447a:	447d      	add	r5, pc
    447c:	0028      	movs	r0, r5
    447e:	f7fd fcf9 	bl	1e74 <mcp794xx_set_addr_pin>
    4482:	0004      	movs	r4, r0
    4484:	2374      	movs	r3, #116	; 0x74
    4486:	54e8      	strb	r0, [r5, r3]
    if(err)
    4488:	2800      	cmp	r0, #0
    448a:	d000      	beq.n	448e <mcp794xx_basic_initialize+0x8e>
    448c:	e087      	b.n	459e <mcp794xx_basic_initialize+0x19e>
    {
        return err; /**< return error code */ /**< failed */
    }

    /* enable oscillator */
    err = mcp794xx_set_osc_status(&mcp794xx_handler, MCP794XX_OSC_ENABLED);
    448e:	4d50      	ldr	r5, [pc, #320]	; (45d0 <mcp794xx_basic_initialize+0x1d0>)
    4490:	447d      	add	r5, pc
    4492:	2101      	movs	r1, #1
    4494:	0028      	movs	r0, r5
    4496:	f7fe f819 	bl	24cc <mcp794xx_set_osc_status>
    449a:	0004      	movs	r4, r0
    449c:	2374      	movs	r3, #116	; 0x74
    449e:	54e8      	strb	r0, [r5, r3]
    if(err)
    44a0:	2800      	cmp	r0, #0
    44a2:	d000      	beq.n	44a6 <mcp794xx_basic_initialize+0xa6>
    44a4:	e07b      	b.n	459e <mcp794xx_basic_initialize+0x19e>
    {
        return err; /**< return error code */ /**< failed */
    }

    /* clear alarm 0 interrupt status bit */
    err = mcp794xx_clr_alarm_interrupt_flag(&mcp794xx_handler, MCP794XX_ALARM0);
    44a6:	4d4b      	ldr	r5, [pc, #300]	; (45d4 <mcp794xx_basic_initialize+0x1d4>)
    44a8:	447d      	add	r5, pc
    44aa:	2100      	movs	r1, #0
    44ac:	0028      	movs	r0, r5
    44ae:	f7fe fe93 	bl	31d8 <mcp794xx_clr_alarm_interrupt_flag>
    44b2:	0004      	movs	r4, r0
    44b4:	2374      	movs	r3, #116	; 0x74
    44b6:	54e8      	strb	r0, [r5, r3]
    if(err)
    44b8:	2800      	cmp	r0, #0
    44ba:	d170      	bne.n	459e <mcp794xx_basic_initialize+0x19e>
    {
        return err; /**< return error code */ /**< failed */
    }

    /* clear alarm 1 interrupt status bit */
    err = mcp794xx_clr_alarm_interrupt_flag(&mcp794xx_handler, MCP794XX_ALARM1);
    44bc:	4d46      	ldr	r5, [pc, #280]	; (45d8 <mcp794xx_basic_initialize+0x1d8>)
    44be:	447d      	add	r5, pc
    44c0:	2101      	movs	r1, #1
    44c2:	0028      	movs	r0, r5
    44c4:	f7fe fe88 	bl	31d8 <mcp794xx_clr_alarm_interrupt_flag>
    44c8:	0004      	movs	r4, r0
    44ca:	2374      	movs	r3, #116	; 0x74
    44cc:	54e8      	strb	r0, [r5, r3]
    if(err)
    44ce:	2800      	cmp	r0, #0
    44d0:	d165      	bne.n	459e <mcp794xx_basic_initialize+0x19e>
    {
        return err; /**< return error code */ /**< failed */
    }

    /* disable alarms */
    err= mcp794xx_set_alarm_enable_status(&mcp794xx_handler, MCP794XX_ALARM0, MCP794XX_BOOL_FALSE);
    44d2:	4d42      	ldr	r5, [pc, #264]	; (45dc <mcp794xx_basic_initialize+0x1dc>)
    44d4:	447d      	add	r5, pc
    44d6:	2200      	movs	r2, #0
    44d8:	2100      	movs	r1, #0
    44da:	0028      	movs	r0, r5
    44dc:	f7fe f912 	bl	2704 <mcp794xx_set_alarm_enable_status>
    44e0:	0004      	movs	r4, r0
    44e2:	2374      	movs	r3, #116	; 0x74
    44e4:	54e8      	strb	r0, [r5, r3]
    if(err)
    44e6:	2800      	cmp	r0, #0
    44e8:	d159      	bne.n	459e <mcp794xx_basic_initialize+0x19e>
    {
      return err; /**< return error code */ /**< failed */
    }

        /* disable alarms */
    err= mcp794xx_set_alarm_enable_status(&mcp794xx_handler, MCP794XX_ALARM1, MCP794XX_BOOL_FALSE);
    44ea:	4d3d      	ldr	r5, [pc, #244]	; (45e0 <mcp794xx_basic_initialize+0x1e0>)
    44ec:	447d      	add	r5, pc
    44ee:	2200      	movs	r2, #0
    44f0:	2101      	movs	r1, #1
    44f2:	0028      	movs	r0, r5
    44f4:	f7fe f906 	bl	2704 <mcp794xx_set_alarm_enable_status>
    44f8:	0004      	movs	r4, r0
    44fa:	2374      	movs	r3, #116	; 0x74
    44fc:	54e8      	strb	r0, [r5, r3]
    if(err)
    44fe:	2800      	cmp	r0, #0
    4500:	d14d      	bne.n	459e <mcp794xx_basic_initialize+0x19e>
    {
      return err; /**< return error code */ /**< failed */
    }

    /* set the gpio logic level */
    err = mcp794xx_set_mfp_logic_level(&mcp794xx_handler, MCP794XX_MFP_LOGIC_HIGH);
    4502:	4d38      	ldr	r5, [pc, #224]	; (45e4 <mcp794xx_basic_initialize+0x1e4>)
    4504:	447d      	add	r5, pc
    4506:	2101      	movs	r1, #1
    4508:	0028      	movs	r0, r5
    450a:	f7fe fedd 	bl	32c8 <mcp794xx_set_mfp_logic_level>
    450e:	0004      	movs	r4, r0
    4510:	2374      	movs	r3, #116	; 0x74
    4512:	54e8      	strb	r0, [r5, r3]
    if(err)
    4514:	2800      	cmp	r0, #0
    4516:	d142      	bne.n	459e <mcp794xx_basic_initialize+0x19e>
    {
        return err; /**< return error code */ /**< failed */
    }

    /* disable the square wave frequency output */
    err = mcp794xx_set_sqr_wave_enable_status(&mcp794xx_handler, MCP794XX_BOOL_FALSE);
    4518:	4d33      	ldr	r5, [pc, #204]	; (45e8 <mcp794xx_basic_initialize+0x1e8>)
    451a:	447d      	add	r5, pc
    451c:	2100      	movs	r1, #0
    451e:	0028      	movs	r0, r5
    4520:	f7fe ff52 	bl	33c8 <mcp794xx_set_sqr_wave_enable_status>
    4524:	0004      	movs	r4, r0
    4526:	2374      	movs	r3, #116	; 0x74
    4528:	54e8      	strb	r0, [r5, r3]
    if(err)
    452a:	2800      	cmp	r0, #0
    452c:	d137      	bne.n	459e <mcp794xx_basic_initialize+0x19e>
    {
        return err; /**< return error code */ /**< failed */
    }

    /* disable the trim coarse */
    err = mcp794xx_set_coarse_trim_mode_status(&mcp794xx_handler, MCP794XX_BOOL_FALSE);
    452e:	4d2f      	ldr	r5, [pc, #188]	; (45ec <mcp794xx_basic_initialize+0x1ec>)
    4530:	447d      	add	r5, pc
    4532:	2100      	movs	r1, #0
    4534:	0028      	movs	r0, r5
    4536:	f7fe ff87 	bl	3448 <mcp794xx_set_coarse_trim_mode_status>
    453a:	0004      	movs	r4, r0
    453c:	2374      	movs	r3, #116	; 0x74
    453e:	54e8      	strb	r0, [r5, r3]
    if(err)
    4540:	2800      	cmp	r0, #0
    4542:	d12c      	bne.n	459e <mcp794xx_basic_initialize+0x19e>
    {
        return err; /**< return error code */ /**< failed */
    }

    /* enable the external oscillator pins to use by the 32.78Khz oscillator */
    err = mcp794xx_set_ext_osc_enable_status(&mcp794xx_handler, MCP794XX_BOOL_FALSE);
    4544:	4d2a      	ldr	r5, [pc, #168]	; (45f0 <mcp794xx_basic_initialize+0x1f0>)
    4546:	447d      	add	r5, pc
    4548:	2100      	movs	r1, #0
    454a:	0028      	movs	r0, r5
    454c:	f7ff f808 	bl	3560 <mcp794xx_set_ext_osc_enable_status>
    4550:	0004      	movs	r4, r0
    4552:	2374      	movs	r3, #116	; 0x74
    4554:	54e8      	strb	r0, [r5, r3]
    if(err)
    4556:	2800      	cmp	r0, #0
    4558:	d121      	bne.n	459e <mcp794xx_basic_initialize+0x19e>
    {
        return err; /**< return error code */ /**< failed */
    }

    /* start the oscillator */
    err = mcp794xx_set_osc_start_bit(&mcp794xx_handler, MCP794XX_BOOL_TRUE);
    455a:	4d26      	ldr	r5, [pc, #152]	; (45f4 <mcp794xx_basic_initialize+0x1f4>)
    455c:	447d      	add	r5, pc
    455e:	2101      	movs	r1, #1
    4560:	0028      	movs	r0, r5
    4562:	f7ff f83d 	bl	35e0 <mcp794xx_set_osc_start_bit>
    4566:	0004      	movs	r4, r0
    4568:	2374      	movs	r3, #116	; 0x74
    456a:	54e8      	strb	r0, [r5, r3]
    if(err)
    456c:	2800      	cmp	r0, #0
    456e:	d116      	bne.n	459e <mcp794xx_basic_initialize+0x19e>
//    {
//        return err; /**< return error code */ /**< failed */
//    }

    /* define printout buffer size */
    err = mcp794xx_set_debug_print_buffer_size(&mcp794xx_handler, MCP794XX_DEBUG_PRINT_BUFFER_SIZE_64B); /**< set the debug print function buffer to 64 bytes */
    4570:	4d21      	ldr	r5, [pc, #132]	; (45f8 <mcp794xx_basic_initialize+0x1f8>)
    4572:	447d      	add	r5, pc
    4574:	2140      	movs	r1, #64	; 0x40
    4576:	0028      	movs	r0, r5
    4578:	f7fd fca6 	bl	1ec8 <mcp794xx_set_debug_print_buffer_size>
    457c:	0004      	movs	r4, r0
    457e:	2374      	movs	r3, #116	; 0x74
    4580:	54e8      	strb	r0, [r5, r3]
    if(err)
    4582:	2800      	cmp	r0, #0
    4584:	d10b      	bne.n	459e <mcp794xx_basic_initialize+0x19e>
    {
        return err; /**< return error code */ /**< failed */
    }

    mcp794xx_interface_delay_ms(10);																	/**< wait 10 ms after initialize complete */
    4586:	200a      	movs	r0, #10
    4588:	f000 fa20 	bl	49cc <mcp794xx_interface_delay_ms>

    return 0;   /**< Initialize success */
    458c:	e007      	b.n	459e <mcp794xx_basic_initialize+0x19e>
       mcp794xx_interface_debug_print("initialize");
    458e:	481b      	ldr	r0, [pc, #108]	; (45fc <mcp794xx_basic_initialize+0x1fc>)
    4590:	4478      	add	r0, pc
    4592:	f000 fa1f 	bl	49d4 <mcp794xx_interface_debug_print>
        return err; /**< return error code */       /**< failed */
    4596:	2374      	movs	r3, #116	; 0x74
    4598:	4a19      	ldr	r2, [pc, #100]	; (4600 <mcp794xx_basic_initialize+0x200>)
    459a:	447a      	add	r2, pc
    459c:	5cd4      	ldrb	r4, [r2, r3]

}
    459e:	0020      	movs	r0, r4
    45a0:	b002      	add	sp, #8
    45a2:	bd70      	pop	{r4, r5, r6, pc}
    45a4:	000041c0 	.word	0x000041c0
    45a8:	1fffbee0 	.word	0x1fffbee0
    45ac:	00000004 	.word	0x00000004
    45b0:	0000004c 	.word	0x0000004c
    45b4:	00000054 	.word	0x00000054
    45b8:	00000090 	.word	0x00000090
    45bc:	00000070 	.word	0x00000070
    45c0:	00000064 	.word	0x00000064
    45c4:	00000068 	.word	0x00000068
    45c8:	1fffbe8a 	.word	0x1fffbe8a
    45cc:	1fffbe72 	.word	0x1fffbe72
    45d0:	1fffbe5c 	.word	0x1fffbe5c
    45d4:	1fffbe44 	.word	0x1fffbe44
    45d8:	1fffbe2e 	.word	0x1fffbe2e
    45dc:	1fffbe18 	.word	0x1fffbe18
    45e0:	1fffbe00 	.word	0x1fffbe00
    45e4:	1fffbde8 	.word	0x1fffbde8
    45e8:	1fffbdd2 	.word	0x1fffbdd2
    45ec:	1fffbdbc 	.word	0x1fffbdbc
    45f0:	1fffbda6 	.word	0x1fffbda6
    45f4:	1fffbd90 	.word	0x1fffbd90
    45f8:	1fffbd7a 	.word	0x1fffbd7a
    45fc:	00003df8 	.word	0x00003df8
    4600:	1fffbd52 	.word	0x1fffbd52

00004604 <mcp794xx_basic_irq_handler>:
 * @return status code
 *          - 0 success
 *          - 1 fail to run handler
 */
uint8_t mcp794xx_basic_irq_handler(mcp794xx_alarm_t alarm)
{
    4604:	b510      	push	{r4, lr}
    4606:	0001      	movs	r1, r0
    err = mcp794xx_irq_pHandler(&mcp794xx_handler, alarm);
    4608:	4c03      	ldr	r4, [pc, #12]	; (4618 <mcp794xx_basic_irq_handler+0x14>)
    460a:	447c      	add	r4, pc
    460c:	0020      	movs	r0, r4
    460e:	f7fd fc17 	bl	1e40 <mcp794xx_irq_pHandler>
    4612:	2374      	movs	r3, #116	; 0x74
    4614:	54e0      	strb	r0, [r4, r3]
    return err;
}
    4616:	bd10      	pop	{r4, pc}
    4618:	1fffbce2 	.word	0x1fffbce2

0000461c <mcp794xx_basic_irq_callBack>:
 *          - 0 succeed
 *          - 1 failed to run
 * @note none
 */
uint8_t mcp794xx_basic_irq_callBack(mcp794xx_alarm_t alarm, mcp794xx_irq_callback_t cb)
{
    461c:	b510      	push	{r4, lr}
	err = cb(alarm);
    461e:	4788      	blx	r1
    4620:	2374      	movs	r3, #116	; 0x74
    4622:	4a02      	ldr	r2, [pc, #8]	; (462c <mcp794xx_basic_irq_callBack+0x10>)
    4624:	447a      	add	r2, pc
    4626:	54d0      	strb	r0, [r2, r3]
	return err;
}
    4628:	bd10      	pop	{r4, pc}
    462a:	46c0      	nop			; (mov r8, r8)
    462c:	1fffbcc8 	.word	0x1fffbcc8

00004630 <mcp794xx_basic_get_current_time_date>:
 *          - 0 success
 *          - 1 failed to get time
 * @note    am_pm is don't care when 24hr time format is used
 */
uint8_t mcp794xx_basic_get_current_time_date(mcp794xx_time_t *pTime)
{
    4630:	b510      	push	{r4, lr}
    4632:	0001      	movs	r1, r0
   err = mcp794xx_get_time_and_date(&mcp794xx_handler, pTime);
    4634:	4c03      	ldr	r4, [pc, #12]	; (4644 <mcp794xx_basic_get_current_time_date+0x14>)
    4636:	447c      	add	r4, pc
    4638:	0020      	movs	r0, r4
    463a:	f7fd fc51 	bl	1ee0 <mcp794xx_get_time_and_date>
    463e:	2374      	movs	r3, #116	; 0x74
    4640:	54e0      	strb	r0, [r4, r3]
   return err; /**< return error code */
}
    4642:	bd10      	pop	{r4, pc}
    4644:	1fffbcb6 	.word	0x1fffbcb6

00004648 <mcp794xx_basic_set_time_format>:
 *          - 0 success
 *          - 1 failed to set time format
 * @note        none
 */
uint8_t mcp794xx_basic_set_time_format(mcp794xx_time_format_t format)
{
    4648:	b570      	push	{r4, r5, r6, lr}
    464a:	0005      	movs	r5, r0
    err = mcp794xx_set_hour_format(&mcp794xx_handler, MCP794XX_RTC_HOUR_REG, format);  /**< set the time format for real time clock register */
    464c:	4c12      	ldr	r4, [pc, #72]	; (4698 <mcp794xx_basic_set_time_format+0x50>)
    464e:	447c      	add	r4, pc
    4650:	0002      	movs	r2, r0
    4652:	2102      	movs	r1, #2
    4654:	0020      	movs	r0, r4
    4656:	f7fd fcb1 	bl	1fbc <mcp794xx_set_hour_format>
    465a:	0003      	movs	r3, r0
    465c:	2274      	movs	r2, #116	; 0x74
    465e:	54a0      	strb	r0, [r4, r2]
    if(err != MCP794XX_DRV_OK){
    4660:	2800      	cmp	r0, #0
    4662:	d001      	beq.n	4668 <mcp794xx_basic_set_time_format+0x20>
    if(err != MCP794XX_DRV_OK){
      return err; /**< return error code */
    }

	return err; /**< return error code */
}
    4664:	0018      	movs	r0, r3
    4666:	bd70      	pop	{r4, r5, r6, pc}
    err = mcp794xx_set_hour_format(&mcp794xx_handler, MCP794XX_PWR_DWN_HOUR_REG, format); /**< set time format for power down time stamp */
    4668:	4c0c      	ldr	r4, [pc, #48]	; (469c <mcp794xx_basic_set_time_format+0x54>)
    466a:	447c      	add	r4, pc
    466c:	002a      	movs	r2, r5
    466e:	2119      	movs	r1, #25
    4670:	0020      	movs	r0, r4
    4672:	f7fd fca3 	bl	1fbc <mcp794xx_set_hour_format>
    4676:	0003      	movs	r3, r0
    4678:	2274      	movs	r2, #116	; 0x74
    467a:	54a0      	strb	r0, [r4, r2]
    if(err != MCP794XX_DRV_OK){
    467c:	2800      	cmp	r0, #0
    467e:	d1f1      	bne.n	4664 <mcp794xx_basic_set_time_format+0x1c>
    err = mcp794xx_set_hour_format(&mcp794xx_handler, MCP794XX_PWR_UP_HOUR_REG, format); /**< set time format for power up time stamp */
    4680:	4c07      	ldr	r4, [pc, #28]	; (46a0 <mcp794xx_basic_set_time_format+0x58>)
    4682:	447c      	add	r4, pc
    4684:	002a      	movs	r2, r5
    4686:	211d      	movs	r1, #29
    4688:	0020      	movs	r0, r4
    468a:	f7fd fc97 	bl	1fbc <mcp794xx_set_hour_format>
    468e:	0003      	movs	r3, r0
    4690:	2274      	movs	r2, #116	; 0x74
    4692:	54a0      	strb	r0, [r4, r2]
    4694:	e7e6      	b.n	4664 <mcp794xx_basic_set_time_format+0x1c>
    4696:	46c0      	nop			; (mov r8, r8)
    4698:	1fffbc9e 	.word	0x1fffbc9e
    469c:	1fffbc82 	.word	0x1fffbc82
    46a0:	1fffbc6a 	.word	0x1fffbc6a

000046a4 <mcp794xx_basic_set_time_date>:
{
    46a4:	b510      	push	{r4, lr}
    46a6:	0004      	movs	r4, r0
    err = mcp794xx_basic_set_time_format(pTime->time_Format);
    46a8:	7a00      	ldrb	r0, [r0, #8]
    46aa:	f7ff ffcd 	bl	4648 <mcp794xx_basic_set_time_format>
    46ae:	0003      	movs	r3, r0
    46b0:	2274      	movs	r2, #116	; 0x74
    46b2:	4909      	ldr	r1, [pc, #36]	; (46d8 <mcp794xx_basic_set_time_date+0x34>)
    46b4:	4479      	add	r1, pc
    46b6:	5488      	strb	r0, [r1, r2]
    if(err != MCP794XX_DRV_OK)
    46b8:	2800      	cmp	r0, #0
    46ba:	d001      	beq.n	46c0 <mcp794xx_basic_set_time_date+0x1c>
}
    46bc:	0018      	movs	r0, r3
    46be:	bd10      	pop	{r4, pc}
    err = mcp794xx_set_time_and_date(&mcp794xx_handler, pTime);  /**< set time and date */
    46c0:	4b06      	ldr	r3, [pc, #24]	; (46dc <mcp794xx_basic_set_time_date+0x38>)
    46c2:	447b      	add	r3, pc
    46c4:	0021      	movs	r1, r4
    46c6:	001c      	movs	r4, r3
    46c8:	0018      	movs	r0, r3
    46ca:	f7fd fd2d 	bl	2128 <mcp794xx_set_time_and_date>
    46ce:	0003      	movs	r3, r0
    46d0:	2274      	movs	r2, #116	; 0x74
    46d2:	54a0      	strb	r0, [r4, r2]
    return err; /**< return error code */
    46d4:	e7f2      	b.n	46bc <mcp794xx_basic_set_time_date+0x18>
    46d6:	46c0      	nop			; (mov r8, r8)
    46d8:	1fffbc38 	.word	0x1fffbc38
    46dc:	1fffbc2a 	.word	0x1fffbc2a

000046e0 <mcp794xx_basic_get_pwr_fail_time_stamp>:
 *          - 3 handle is not initialized
 * @note reading or writing the the external battery back up bit will clear the pwr fail time stamp.
         Time stamp should be read at start up before reading or setting current time and date
 */
uint8_t mcp794xx_basic_get_pwr_fail_time_stamp(mcp794xx_pwr_fail_type_t powerMode, mcp794xx_time_t *pTime)
{
    46e0:	b570      	push	{r4, r5, r6, lr}
    46e2:	0005      	movs	r5, r0
    46e4:	000e      	movs	r6, r1
    mcp794xx_set_pwr_fail_time_param(&mcp794xx_handler);      						/**< set indicator parameters for power fail time stamp */
    46e6:	4c06      	ldr	r4, [pc, #24]	; (4700 <mcp794xx_basic_get_pwr_fail_time_stamp+0x20>)
    46e8:	447c      	add	r4, pc
    46ea:	0020      	movs	r0, r4
    46ec:	f7fd ffae 	bl	264c <mcp794xx_set_pwr_fail_time_param>
    err = mcp794xx_get_pwr_fail_time_stamp(&mcp794xx_handler, powerMode, pTime);
    46f0:	0032      	movs	r2, r6
    46f2:	0029      	movs	r1, r5
    46f4:	0020      	movs	r0, r4
    46f6:	f7fd ff29 	bl	254c <mcp794xx_get_pwr_fail_time_stamp>
    46fa:	2374      	movs	r3, #116	; 0x74
    46fc:	54e0      	strb	r0, [r4, r3]
    return err; /**< return error code */
}
    46fe:	bd70      	pop	{r4, r5, r6, pc}
    4700:	1fffbc04 	.word	0x1fffbc04

00004704 <mcp794xx_basic_enable_ext_batt_bckup_pwr>:
 *          - 3 handle is not initialized
 * @note reading or writing the the external battery back up bit will clear the pwr fail time stamp.
         Time stamp should be read at start up before reading or setting current time and date
 */
uint8_t  mcp794xx_basic_enable_ext_batt_bckup_pwr(void)
{
    4704:	b510      	push	{r4, lr}
    err = mcp794xx_set_ext_batt_enable_status(&mcp794xx_handler, MCP794XX_BOOL_TRUE);
    4706:	4c04      	ldr	r4, [pc, #16]	; (4718 <mcp794xx_basic_enable_ext_batt_bckup_pwr+0x14>)
    4708:	447c      	add	r4, pc
    470a:	2101      	movs	r1, #1
    470c:	0020      	movs	r0, r4
    470e:	f7fe fedb 	bl	34c8 <mcp794xx_set_ext_batt_enable_status>
    4712:	2374      	movs	r3, #116	; 0x74
    4714:	54e0      	strb	r0, [r4, r3]
    return err; /**< return error code */
}
    4716:	bd10      	pop	{r4, pc}
    4718:	1fffbbe4 	.word	0x1fffbbe4

0000471c <mcp794xx_basic_enable_alarm>:
*          - 1 failed
           - 2 handle null
*          - 3 handle is not initialized
*/
uint8_t mcp794xx_basic_enable_alarm(mcp794xx_alarm_t alarm, mcp794xx_int_output_polarity_t polarity)
{
    471c:	b570      	push	{r4, r5, r6, lr}
    471e:	0005      	movs	r5, r0
    4720:	000e      	movs	r6, r1
    err = mcp794xx_set_alarm_enable_status(&mcp794xx_handler, alarm, MCP794XX_BOOL_TRUE);
    4722:	4c0c      	ldr	r4, [pc, #48]	; (4754 <mcp794xx_basic_enable_alarm+0x38>)
    4724:	447c      	add	r4, pc
    4726:	2201      	movs	r2, #1
    4728:	0001      	movs	r1, r0
    472a:	0020      	movs	r0, r4
    472c:	f7fd ffea 	bl	2704 <mcp794xx_set_alarm_enable_status>
    4730:	0003      	movs	r3, r0
    4732:	2274      	movs	r2, #116	; 0x74
    4734:	54a0      	strb	r0, [r4, r2]
    if(err != MCP794XX_DRV_OK)
    4736:	2800      	cmp	r0, #0
    4738:	d001      	beq.n	473e <mcp794xx_basic_enable_alarm+0x22>
    	return err; /**< return error code */
    }

    err = mcp794xx_set_alarm_interrupt_output_polarity(&mcp794xx_handler, alarm, polarity);
    return err; /**< return error code */
}
    473a:	0018      	movs	r0, r3
    473c:	bd70      	pop	{r4, r5, r6, pc}
    err = mcp794xx_set_alarm_interrupt_output_polarity(&mcp794xx_handler, alarm, polarity);
    473e:	4c06      	ldr	r4, [pc, #24]	; (4758 <mcp794xx_basic_enable_alarm+0x3c>)
    4740:	447c      	add	r4, pc
    4742:	0032      	movs	r2, r6
    4744:	0029      	movs	r1, r5
    4746:	0020      	movs	r0, r4
    4748:	f7fe f83c 	bl	27c4 <mcp794xx_set_alarm_interrupt_output_polarity>
    474c:	0003      	movs	r3, r0
    474e:	2274      	movs	r2, #116	; 0x74
    4750:	54a0      	strb	r0, [r4, r2]
    return err; /**< return error code */
    4752:	e7f2      	b.n	473a <mcp794xx_basic_enable_alarm+0x1e>
    4754:	1fffbbc8 	.word	0x1fffbbc8
    4758:	1fffbbac 	.word	0x1fffbbac

0000475c <mcp794xx_basic_set_alarm_time_date>:
 *          - 4 invalid alarm
 *          - 5 invalid mask
 * @note prior to this function to be called, the "mcp794xx_basic_enable_alarm" to enable interrupt and set polarity
 */
uint8_t mcp794xx_basic_set_alarm_time_date(mcp794xx_alarm_t alarm, mcp794xx_alarm_mask_t mask, mcp794xx_time_t *pTime)
{
    475c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    475e:	0005      	movs	r5, r0
    4760:	000f      	movs	r7, r1
    4762:	0016      	movs	r6, r2
	if(alarm == MCP794XX_ALARM0){
    4764:	2800      	cmp	r0, #0
    4766:	d00e      	beq.n	4786 <mcp794xx_basic_set_alarm_time_date+0x2a>
		err = mcp794xx_set_hour_format(&mcp794xx_handler, MCP794XX_ALM0_HOUR_REG, pTime->time_Format);
		if(err){return err; /**< return error code */}
	}else if(alarm == MCP794XX_ALARM1)
    4768:	2801      	cmp	r0, #1
    476a:	d019      	beq.n	47a0 <mcp794xx_basic_set_alarm_time_date+0x44>
		if(err != MCP794XX_DRV_OK)
		{
			return err; /**< return error code */
		}
	}
    err = mcp794xx_set_alarm(&mcp794xx_handler, alarm, mask, pTime);
    476c:	4c13      	ldr	r4, [pc, #76]	; (47bc <mcp794xx_basic_set_alarm_time_date+0x60>)
    476e:	447c      	add	r4, pc
    4770:	0033      	movs	r3, r6
    4772:	003a      	movs	r2, r7
    4774:	0029      	movs	r1, r5
    4776:	0020      	movs	r0, r4
    4778:	f7fe fb2a 	bl	2dd0 <mcp794xx_set_alarm>
    477c:	0003      	movs	r3, r0
    477e:	2274      	movs	r2, #116	; 0x74
    4780:	54a0      	strb	r0, [r4, r2]
    return err; /**< return error code */
}
    4782:	0018      	movs	r0, r3
    4784:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		err = mcp794xx_set_hour_format(&mcp794xx_handler, MCP794XX_ALM0_HOUR_REG, pTime->time_Format);
    4786:	7a12      	ldrb	r2, [r2, #8]
    4788:	4c0d      	ldr	r4, [pc, #52]	; (47c0 <mcp794xx_basic_set_alarm_time_date+0x64>)
    478a:	447c      	add	r4, pc
    478c:	210c      	movs	r1, #12
    478e:	0020      	movs	r0, r4
    4790:	f7fd fc14 	bl	1fbc <mcp794xx_set_hour_format>
    4794:	0003      	movs	r3, r0
    4796:	2274      	movs	r2, #116	; 0x74
    4798:	54a0      	strb	r0, [r4, r2]
		if(err){return err; /**< return error code */}
    479a:	2800      	cmp	r0, #0
    479c:	d0e6      	beq.n	476c <mcp794xx_basic_set_alarm_time_date+0x10>
    479e:	e7f0      	b.n	4782 <mcp794xx_basic_set_alarm_time_date+0x26>
		err = mcp794xx_set_hour_format(&mcp794xx_handler, MCP794XX_ALM1_HOUR_REG, pTime->time_Format);
    47a0:	7a12      	ldrb	r2, [r2, #8]
    47a2:	4c08      	ldr	r4, [pc, #32]	; (47c4 <mcp794xx_basic_set_alarm_time_date+0x68>)
    47a4:	447c      	add	r4, pc
    47a6:	2113      	movs	r1, #19
    47a8:	0020      	movs	r0, r4
    47aa:	f7fd fc07 	bl	1fbc <mcp794xx_set_hour_format>
    47ae:	0003      	movs	r3, r0
    47b0:	2274      	movs	r2, #116	; 0x74
    47b2:	54a0      	strb	r0, [r4, r2]
		if(err != MCP794XX_DRV_OK)
    47b4:	2800      	cmp	r0, #0
    47b6:	d0d9      	beq.n	476c <mcp794xx_basic_set_alarm_time_date+0x10>
    47b8:	e7e3      	b.n	4782 <mcp794xx_basic_set_alarm_time_date+0x26>
    47ba:	46c0      	nop			; (mov r8, r8)
    47bc:	1fffbb7e 	.word	0x1fffbb7e
    47c0:	1fffbb62 	.word	0x1fffbb62
    47c4:	1fffbb48 	.word	0x1fffbb48

000047c8 <mcp794xx_basic_get_alarm_time_date>:
            - 2 handle null
 *          - 3 handle is not initialized
 *          - 4 invalid alarm
 */
uint8_t mcp794xx_basic_get_alarm_time_date(mcp794xx_alarm_t alarm, mcp794xx_alarm_mask_t *pMask, mcp794xx_time_t *pTime)
{
    47c8:	b510      	push	{r4, lr}
    47ca:	0013      	movs	r3, r2
    err = mcp794xx_get_alarm(&mcp794xx_handler, alarm, pMask, pTime);
    47cc:	4c04      	ldr	r4, [pc, #16]	; (47e0 <mcp794xx_basic_get_alarm_time_date+0x18>)
    47ce:	447c      	add	r4, pc
    47d0:	000a      	movs	r2, r1
    47d2:	0001      	movs	r1, r0
    47d4:	0020      	movs	r0, r4
    47d6:	f7fe fc37 	bl	3048 <mcp794xx_get_alarm>
    47da:	2374      	movs	r3, #116	; 0x74
    47dc:	54e0      	strb	r0, [r4, r3]
    return err; /**< return error code */
}
    47de:	bd10      	pop	{r4, pc}
    47e0:	1fffbb1e 	.word	0x1fffbb1e

000047e4 <mcp794xx_basic_get_alarm_interrupt_flag>:
            - 2 handle null
 *          - 3 handle is not initialized
 *          - 4 invalid alarm
 */
uint8_t mcp794xx_basic_get_alarm_interrupt_flag(mcp794xx_alarm_t alarm, mcp794xx_alarm_int_flag_t *pFlag)
{
    47e4:	b510      	push	{r4, lr}
    47e6:	000a      	movs	r2, r1
    err = mcp794xx_get_alarm_interrupt_flag(&mcp794xx_handler, alarm, pFlag);
    47e8:	4c04      	ldr	r4, [pc, #16]	; (47fc <mcp794xx_basic_get_alarm_interrupt_flag+0x18>)
    47ea:	447c      	add	r4, pc
    47ec:	0001      	movs	r1, r0
    47ee:	0020      	movs	r0, r4
    47f0:	f7fe fc9e 	bl	3130 <mcp794xx_get_alarm_interrupt_flag>
    47f4:	2374      	movs	r3, #116	; 0x74
    47f6:	54e0      	strb	r0, [r4, r3]
    return err; /**< return error code */
}
    47f8:	bd10      	pop	{r4, pc}
    47fa:	46c0      	nop			; (mov r8, r8)
    47fc:	1fffbb02 	.word	0x1fffbb02

00004800 <mcp794xx_basic_clr_alarm_interrupt_flag>:
 *          - 1 failed
            - 2 handle null
 *          - 3 handle is not initialized
 */
uint8_t mcp794xx_basic_clr_alarm_interrupt_flag(mcp794xx_alarm_t alarm)
{
    4800:	b510      	push	{r4, lr}
    4802:	0001      	movs	r1, r0
    err = mcp794xx_clr_alarm_interrupt_flag(&mcp794xx_handler,alarm);
    4804:	4c03      	ldr	r4, [pc, #12]	; (4814 <mcp794xx_basic_clr_alarm_interrupt_flag+0x14>)
    4806:	447c      	add	r4, pc
    4808:	0020      	movs	r0, r4
    480a:	f7fe fce5 	bl	31d8 <mcp794xx_clr_alarm_interrupt_flag>
    480e:	2374      	movs	r3, #116	; 0x74
    4810:	54e0      	strb	r0, [r4, r3]
    return err; /**< return error code */
}
    4812:	bd10      	pop	{r4, pc}
    4814:	1fffbae6 	.word	0x1fffbae6

00004818 <mcp794xx_basic_enable_countdown_interrupt>:
 *            - 2 pHandle is NULL
 *            - 3 pHandle is not initialized
 * @note      This function use ALARM1 and overwrite existing data within register
 */
uint8_t mcp794xx_basic_enable_countdown_interrupt(void)
{
    4818:	b510      	push	{r4, lr}
    err = mcp794xx_set_countdown_interrupt_enable_status(&mcp794xx_handler, MCP794XX_BOOL_TRUE);
    481a:	4c04      	ldr	r4, [pc, #16]	; (482c <mcp794xx_basic_enable_countdown_interrupt+0x14>)
    481c:	447c      	add	r4, pc
    481e:	2101      	movs	r1, #1
    4820:	0020      	movs	r0, r4
    4822:	f7ff f937 	bl	3a94 <mcp794xx_set_countdown_interrupt_enable_status>
    4826:	2374      	movs	r3, #116	; 0x74
    4828:	54e0      	strb	r0, [r4, r3]
    return err;
}
    482a:	bd10      	pop	{r4, pc}
    482c:	1fffbad0 	.word	0x1fffbad0

00004830 <mcp794xx_basic_set_countdown_time>:
 *            - "mcp794xx_set_countdown_interrupt_enable_status"  must be called before using this function
 *            - Time and date must be set prior to calling this function
 *            - day of the week must be accurate when setting time
 */
uint8_t mcp794xx_basic_set_countdown_time(uint16_t u16Time_value, mcp794xx_countdwon_time_unit_t time_unit)
{
    4830:	b510      	push	{r4, lr}
    4832:	000a      	movs	r2, r1
    err = mcp794xx_set_countdown_interrupt_time(&mcp794xx_handler, u16Time_value, time_unit);
    4834:	4c04      	ldr	r4, [pc, #16]	; (4848 <mcp794xx_basic_set_countdown_time+0x18>)
    4836:	447c      	add	r4, pc
    4838:	0001      	movs	r1, r0
    483a:	0020      	movs	r0, r4
    483c:	f7ff f960 	bl	3b00 <mcp794xx_set_countdown_interrupt_time>
    4840:	2374      	movs	r3, #116	; 0x74
    4842:	54e0      	strb	r0, [r4, r3]
    return err;
}
    4844:	bd10      	pop	{r4, pc}
    4846:	46c0      	nop			; (mov r8, r8)
    4848:	1fffbab6 	.word	0x1fffbab6

0000484c <mcp794xx_basic_enable_sqr_wave_output>:
 *          - 1 failed
            - 2 handle null
 *          - 3 handle is not initialized
 */
uint8_t mcp794xx_basic_enable_sqr_wave_output(void)
{
    484c:	b510      	push	{r4, lr}
    err = mcp794xx_set_sqr_wave_enable_status(&mcp794xx_handler, MCP794XX_BOOL_TRUE);
    484e:	4c04      	ldr	r4, [pc, #16]	; (4860 <mcp794xx_basic_enable_sqr_wave_output+0x14>)
    4850:	447c      	add	r4, pc
    4852:	2101      	movs	r1, #1
    4854:	0020      	movs	r0, r4
    4856:	f7fe fdb7 	bl	33c8 <mcp794xx_set_sqr_wave_enable_status>
    485a:	2374      	movs	r3, #116	; 0x74
    485c:	54e0      	strb	r0, [r4, r3]
    return err; /**< return error code */
}
    485e:	bd10      	pop	{r4, pc}
    4860:	1fffba9c 	.word	0x1fffba9c

00004864 <mcp94xx_basic_set_sqr_wave_output_freq>:
            - 2 handle null
 *          - 3 handle is not initialized
 * @note prior to setting frequency output, the "mcp794xx_basic_enable_sqr_wave_output" must called first to enable this feature.
 */
uint8_t mcp94xx_basic_set_sqr_wave_output_freq(mcp94xx_sqr_wave_freq_t freq)
{
    4864:	b510      	push	{r4, lr}
    4866:	0001      	movs	r1, r0
    err = mcp94xx_set_sqr_wave_output_freq(&mcp794xx_handler,freq);
    4868:	4c03      	ldr	r4, [pc, #12]	; (4878 <mcp94xx_basic_set_sqr_wave_output_freq+0x14>)
    486a:	447c      	add	r4, pc
    486c:	0020      	movs	r0, r4
    486e:	f7fe fd6b 	bl	3348 <mcp94xx_set_sqr_wave_output_freq>
    4872:	2374      	movs	r3, #116	; 0x74
    4874:	54e0      	strb	r0, [r4, r3]
    return err; /**< return error code */
}
    4876:	bd10      	pop	{r4, pc}
    4878:	1fffba82 	.word	0x1fffba82

0000487c <mcp794xx_basic_convert_time_to_epoch_unix_time>:
 *            - 2 pHandle is NULL
 *            - 3 pHandle is not initialized
 * @note      This function will fail to execute from January 19, 2038
 */
uint8_t mcp794xx_basic_convert_time_to_epoch_unix_time(mcp794xx_time_t *pTime, uint32_t *pEpoch_time)
{
    487c:	b510      	push	{r4, lr}
    487e:	000a      	movs	r2, r1
    err = mcp794xx_read_epoch_unix_time_stamp(&mcp794xx_handler, pTime, (uint32_t *)pEpoch_time);
    4880:	4c04      	ldr	r4, [pc, #16]	; (4894 <mcp794xx_basic_convert_time_to_epoch_unix_time+0x18>)
    4882:	447c      	add	r4, pc
    4884:	0001      	movs	r1, r0
    4886:	0020      	movs	r0, r4
    4888:	f7fe feea 	bl	3660 <mcp794xx_read_epoch_unix_time_stamp>
    488c:	2374      	movs	r3, #116	; 0x74
    488e:	54e0      	strb	r0, [r4, r3]
    return err; /**< return error code */
}
    4890:	bd10      	pop	{r4, pc}
    4892:	46c0      	nop			; (mov r8, r8)
    4894:	1fffba6a 	.word	0x1fffba6a

00004898 <mcp794xx_basic_convert_epoch_to_human_time_format>:
 *            - 2 pHandle is NULL
 *            - 3 pHandle is not initialized
 * @note      This function will fail to execute from January 19, 2038
 */
uint8_t mcp794xx_basic_convert_epoch_to_human_time_format(uint32_t epoch_unix_time, mcp794xx_time_t *pTime)
{
    4898:	b510      	push	{r4, lr}
    489a:	000a      	movs	r2, r1
	err = mcp794xx_convert_epoch_unix_time_stamp(&mcp794xx_handler, epoch_unix_time, pTime);
    489c:	4c04      	ldr	r4, [pc, #16]	; (48b0 <mcp794xx_basic_convert_epoch_to_human_time_format+0x18>)
    489e:	447c      	add	r4, pc
    48a0:	0001      	movs	r1, r0
    48a2:	0020      	movs	r0, r4
    48a4:	f7fe ff1e 	bl	36e4 <mcp794xx_convert_epoch_unix_time_stamp>
    48a8:	2374      	movs	r3, #116	; 0x74
    48aa:	54e0      	strb	r0, [r4, r3]
	return err; /**< return error code */
}
    48ac:	bd10      	pop	{r4, pc}
    48ae:	46c0      	nop			; (mov r8, r8)
    48b0:	1fffba4e 	.word	0x1fffba4e

000048b4 <mcp794xx_basic_get_compile_time_date>:
 *             - 2 handle or time is NULL
 *             - 3 handle is not initialized
 * @note       this function returns time in 24Hr format
 */
uint8_t mcp794xx_basic_get_compile_time_date(char *pCompile_time_date, mcp794xx_time_t *pTime)
{
    48b4:	b510      	push	{r4, lr}
    48b6:	000a      	movs	r2, r1
	err = mcp794xx_get_compile_time_date(&mcp794xx_handler, pCompile_time_date, pTime);
    48b8:	4c04      	ldr	r4, [pc, #16]	; (48cc <mcp794xx_basic_get_compile_time_date+0x18>)
    48ba:	447c      	add	r4, pc
    48bc:	0001      	movs	r1, r0
    48be:	0020      	movs	r0, r4
    48c0:	f7fe ffe8 	bl	3894 <mcp794xx_get_compile_time_date>
    48c4:	2374      	movs	r3, #116	; 0x74
    48c6:	54e0      	strb	r0, [r4, r3]
	return err;
}
    48c8:	bd10      	pop	{r4, pc}
    48ca:	46c0      	nop			; (mov r8, r8)
    48cc:	1fffba32 	.word	0x1fffba32

000048d0 <mcp794xx_basic_sram_write_byte>:
*          - 3 pHandle is not initialized
*          - 4 invalid address
* @note none
*/
uint8_t mcp794xx_basic_sram_write_byte(uint8_t addr, uint8_t *pBuffer, size_t length)
{
    48d0:	b510      	push	{r4, lr}
    48d2:	0013      	movs	r3, r2
	err = mcp794xx_sram_write_byte(&mcp794xx_handler, addr, (uint8_t *)pBuffer, length);
    48d4:	4c04      	ldr	r4, [pc, #16]	; (48e8 <mcp794xx_basic_sram_write_byte+0x18>)
    48d6:	447c      	add	r4, pc
    48d8:	000a      	movs	r2, r1
    48da:	0001      	movs	r1, r0
    48dc:	0020      	movs	r0, r4
    48de:	f7ff fa39 	bl	3d54 <mcp794xx_sram_write_byte>
    48e2:	2374      	movs	r3, #116	; 0x74
    48e4:	54e0      	strb	r0, [r4, r3]
	return err; /**< return error code */
}
    48e6:	bd10      	pop	{r4, pc}
    48e8:	1fffba16 	.word	0x1fffba16

000048ec <mcp794xx_basic_sram_read_byte>:
*          - 3 pHandle is not initialized
*          - 4 invalid address
* @note none
*/
uint8_t mcp794xx_basic_sram_read_byte(uint8_t addr, uint8_t *pBuffer, size_t length)
{
    48ec:	b510      	push	{r4, lr}
    48ee:	0013      	movs	r3, r2
	err = mcp794xx_sram_read_byte(&mcp794xx_handler, addr, (uint8_t *)pBuffer, length);
    48f0:	4c04      	ldr	r4, [pc, #16]	; (4904 <mcp794xx_basic_sram_read_byte+0x18>)
    48f2:	447c      	add	r4, pc
    48f4:	000a      	movs	r2, r1
    48f6:	0001      	movs	r1, r0
    48f8:	0020      	movs	r0, r4
    48fa:	f7ff fa6f 	bl	3ddc <mcp794xx_sram_read_byte>
    48fe:	2374      	movs	r3, #116	; 0x74
    4900:	54e0      	strb	r0, [r4, r3]
	return err; /**< return error code */
}
    4902:	bd10      	pop	{r4, pc}
    4904:	1fffb9fa 	.word	0x1fffb9fa

00004908 <mcp794xx_basic_sram_erase_selector>:
*          - 3 pHandle is not initialized
*          - 4 invalid address
* @note data from the start to the end address will be erased
*/
uint8_t mcp794xx_basic_sram_erase_selector(uint8_t start_addr, uint8_t end_addr)
{
    4908:	b510      	push	{r4, lr}
    490a:	000a      	movs	r2, r1
	err = mcp794xx_sram_erase_selector(&mcp794xx_handler, start_addr, end_addr);
    490c:	4c04      	ldr	r4, [pc, #16]	; (4920 <mcp794xx_basic_sram_erase_selector+0x18>)
    490e:	447c      	add	r4, pc
    4910:	0001      	movs	r1, r0
    4912:	0020      	movs	r0, r4
    4914:	f7ff faa8 	bl	3e68 <mcp794xx_sram_erase_selector>
    4918:	2374      	movs	r3, #116	; 0x74
    491a:	54e0      	strb	r0, [r4, r3]
	return err;
}
    491c:	bd10      	pop	{r4, pc}
    491e:	46c0      	nop			; (mov r8, r8)
    4920:	1fffb9de 	.word	0x1fffb9de

00004924 <mcp794xx_basic_sram_wipe>:
*          - 2 pHandle is NULL
*          - 3 pHandle is not initialized
* @note none
*/
uint8_t mcp794xx_basic_sram_wipe(void)
{
    4924:	b510      	push	{r4, lr}
	err = mcp794xx_wipe_sram(&mcp794xx_handler);
    4926:	4c04      	ldr	r4, [pc, #16]	; (4938 <mcp794xx_basic_sram_wipe+0x14>)
    4928:	447c      	add	r4, pc
    492a:	0020      	movs	r0, r4
    492c:	f7ff fae6 	bl	3efc <mcp794xx_wipe_sram>
    4930:	2374      	movs	r3, #116	; 0x74
    4932:	54e0      	strb	r0, [r4, r3]
	return err; /**< return error code */
}
    4934:	bd10      	pop	{r4, pc}
    4936:	46c0      	nop			; (mov r8, r8)
    4938:	1fffb9c4 	.word	0x1fffb9c4

0000493c <mcp794xx_basic_uid_read>:
 *            - 2 pHandle is NULL
 *            - 3 pHandle is not initialized
 * @note      none
 */
uint8_t mcp794xx_basic_uid_read(uint8_t *pUID)
{
    493c:	b510      	push	{r4, lr}
    493e:	0001      	movs	r1, r0
	err = mcp794xx_uid_read(&mcp794xx_handler,(uint8_t*)pUID);
    4940:	4c03      	ldr	r4, [pc, #12]	; (4950 <mcp794xx_basic_uid_read+0x14>)
    4942:	447c      	add	r4, pc
    4944:	0020      	movs	r0, r4
    4946:	f7ff f94f 	bl	3be8 <mcp794xx_uid_read>
    494a:	2374      	movs	r3, #116	; 0x74
    494c:	54e0      	strb	r0, [r4, r3]
	return err; /**< return error code */
}
    494e:	bd10      	pop	{r4, pc}
    4950:	1fffb9aa 	.word	0x1fffb9aa

00004954 <mcp794xx_basic_eeprom_write_byte>:
 *            - 5 attempt to write a protected block array
 *            - 6 data length is larger than page size
 * @note      the eeprom has a 5ms write cycle time.
 */
uint8_t mcp794xx_basic_eeprom_write_byte(uint8_t u8Addr, uint8_t *pBuf, size_t length)
{
    4954:	b510      	push	{r4, lr}
	err = mcp794xx_eeprom_write_byte(&mcp794xx_handler, u8Addr, (uint8_t *)pBuf, length);
    4956:	b2d3      	uxtb	r3, r2
    4958:	4c04      	ldr	r4, [pc, #16]	; (496c <mcp794xx_basic_eeprom_write_byte+0x18>)
    495a:	447c      	add	r4, pc
    495c:	000a      	movs	r2, r1
    495e:	0001      	movs	r1, r0
    4960:	0020      	movs	r0, r4
    4962:	f7ff fbb5 	bl	40d0 <mcp794xx_eeprom_write_byte>
    4966:	2374      	movs	r3, #116	; 0x74
    4968:	54e0      	strb	r0, [r4, r3]
	return err; /**< return error code */
}
    496a:	bd10      	pop	{r4, pc}
    496c:	1fffb992 	.word	0x1fffb992

00004970 <mcp794xx_basic_eeprom_read_byte>:
 *            - 3 handle is not initialized
 *            - 4 invalid address
 * @note      none
 */
uint8_t mcp794xx_basic_eeprom_read_byte(uint8_t u8Addr, uint8_t *pBuf, size_t length)
{
    4970:	b510      	push	{r4, lr}
	err = mcp794xx_eeprom_read_byte(&mcp794xx_handler, u8Addr, (uint8_t *)pBuf, length);
    4972:	b2d3      	uxtb	r3, r2
    4974:	4c04      	ldr	r4, [pc, #16]	; (4988 <mcp794xx_basic_eeprom_read_byte+0x18>)
    4976:	447c      	add	r4, pc
    4978:	000a      	movs	r2, r1
    497a:	0001      	movs	r1, r0
    497c:	0020      	movs	r0, r4
    497e:	f7ff fae5 	bl	3f4c <mcp794xx_eeprom_read_byte>
    4982:	2374      	movs	r3, #116	; 0x74
    4984:	54e0      	strb	r0, [r4, r3]
	return err; /**< return error code */
}
    4986:	bd10      	pop	{r4, pc}
    4988:	1fffb976 	.word	0x1fffb976

0000498c <mcp794xx_basic_eeprom_put_byte>:
 *            - 6 data length is larger than page can contain
 * @note      none
 */

uint8_t mcp794xx_basic_eeprom_put_byte(uint8_t u8Addr, uint32_t *pBuf, uint8_t u8Length)
{
    498c:	b510      	push	{r4, lr}
    498e:	0013      	movs	r3, r2
	err = mcp794xx_eeprom_put_byte(&mcp794xx_handler, u8Addr, (uint32_t *)pBuf, u8Length);
    4990:	4c04      	ldr	r4, [pc, #16]	; (49a4 <mcp794xx_basic_eeprom_put_byte+0x18>)
    4992:	447c      	add	r4, pc
    4994:	000a      	movs	r2, r1
    4996:	0001      	movs	r1, r0
    4998:	0020      	movs	r0, r4
    499a:	f7ff fc39 	bl	4210 <mcp794xx_eeprom_put_byte>
    499e:	2374      	movs	r3, #116	; 0x74
    49a0:	54e0      	strb	r0, [r4, r3]
	return err; /**< return error code */
}
    49a2:	bd10      	pop	{r4, pc}
    49a4:	1fffb95a 	.word	0x1fffb95a

000049a8 <mcp794xx_basic_eeprom_get_byte>:
 *            - 4 invalid address (failed to validate address)
 * @note      none
 */

uint8_t mcp794xx_basic_eeprom_get_byte(uint8_t u8Addr, uint32_t *pBuf, uint8_t u8Length)
{
    49a8:	b510      	push	{r4, lr}
    49aa:	0013      	movs	r3, r2
	err = mcp794xx_eeprom_get_byte(&mcp794xx_handler, u8Addr, (uint32_t *)pBuf, u8Length);
    49ac:	4c04      	ldr	r4, [pc, #16]	; (49c0 <mcp794xx_basic_eeprom_get_byte+0x18>)
    49ae:	447c      	add	r4, pc
    49b0:	000a      	movs	r2, r1
    49b2:	0001      	movs	r1, r0
    49b4:	0020      	movs	r0, r4
    49b6:	f7ff fc8b 	bl	42d0 <mcp794xx_eeprom_get_byte>
    49ba:	2374      	movs	r3, #116	; 0x74
    49bc:	54e0      	strb	r0, [r4, r3]
	return err; /**< return error code */
}
    49be:	bd10      	pop	{r4, pc}
    49c0:	1fffb93e 	.word	0x1fffb93e

000049c4 <mcp794xx_interface_i2c_init>:
    /*call your i2c initialize function here*/
    /*user code begin */

    /*user code end*/
    return 0; /**< success */
}
    49c4:	2000      	movs	r0, #0
    49c6:	4770      	bx	lr

000049c8 <mcp794xx_interface_i2c_deinit>:
    /*call your i2c de-initialize function here*/
    /*user code begin */

    /*user code end*/
    return 0; /**< success */
}
    49c8:	2000      	movs	r0, #0
    49ca:	4770      	bx	lr

000049cc <mcp794xx_interface_delay_ms>:
 * @brief     interface delay ms
 * @param[in] u32Ms is the time in milliseconds
 * @note      none
 */
void mcp794xx_interface_delay_ms(uint32_t u32Ms)
{
    49cc:	b510      	push	{r4, lr}
    /*call your delay function here*/
    /*user code begin */
    delay_ms(u32Ms);
    49ce:	f7fb fd35 	bl	43c <delay_ms>
    /*user code end*/
}
    49d2:	bd10      	pop	{r4, pc}

000049d4 <mcp794xx_interface_debug_print>:
 * @brief     interface print format data
 * @param[in] fmt is the format data
 * @note      none
 */
void mcp794xx_interface_debug_print(const char *const fmt, ...)
{
    49d4:	b40f      	push	{r0, r1, r2, r3}
    49d6:	b5f0      	push	{r4, r5, r6, r7, lr}
    49d8:	b0c3      	sub	sp, #268	; 0x10c
    49da:	ad48      	add	r5, sp, #288	; 0x120
    49dc:	cd80      	ldmia	r5!, {r7}
#ifdef MCP794XX_DEBUG_MODE
    volatile char str[256];
    volatile uint8_t len;
    va_list args;

    memset((char *) str, 0, sizeof (char) * 256);
    49de:	2680      	movs	r6, #128	; 0x80
    49e0:	0076      	lsls	r6, r6, #1
    49e2:	0032      	movs	r2, r6
    49e4:	2100      	movs	r1, #0
    49e6:	ac02      	add	r4, sp, #8
    49e8:	0020      	movs	r0, r4
    49ea:	f001 fbe2 	bl	61b2 <memset>
    va_start(args, fmt);
    49ee:	9500      	str	r5, [sp, #0]
    vsnprintf((char *) str, 256, (char const *) fmt, args);
    49f0:	002b      	movs	r3, r5
    49f2:	003a      	movs	r2, r7
    49f4:	0031      	movs	r1, r6
    49f6:	0020      	movs	r0, r4
    49f8:	f001 fd8e 	bl	6518 <vsniprintf>
    va_end(args);

    len = strlen((char *) str);
    49fc:	0020      	movs	r0, r4
    49fe:	f001 fca9 	bl	6354 <strlen>
    4a02:	b2c0      	uxtb	r0, r0
    4a04:	466b      	mov	r3, sp
    4a06:	71d8      	strb	r0, [r3, #7]
    //   EUSART1_Write_Text((const char *) str, len);        /**< example of a usart function */
      (void)serial_print((uint8_t *)str, len);                     /**< example of printf function, comment out if used */
    4a08:	79d9      	ldrb	r1, [r3, #7]
    4a0a:	b2c9      	uxtb	r1, r1
    4a0c:	0020      	movs	r0, r4
    4a0e:	f7fd f8a7 	bl	1b60 <serial_print>

    /*user code end*/
#endif
}
    4a12:	b043      	add	sp, #268	; 0x10c
    4a14:	bcf0      	pop	{r4, r5, r6, r7}
    4a16:	bc08      	pop	{r3}
    4a18:	b004      	add	sp, #16
    4a1a:	4718      	bx	r3

00004a1c <mcp794xx_interface_i2c_read>:
{
    4a1c:	b510      	push	{r4, lr}
    if(i2c_read(u8Addr, pBuf, u8Length) !=  0)
    4a1e:	f7fd f8df 	bl	1be0 <i2c_read>
    4a22:	2800      	cmp	r0, #0
    4a24:	d100      	bne.n	4a28 <mcp794xx_interface_i2c_read+0xc>
}
    4a26:	bd10      	pop	{r4, pc}
	    mcp794xx_interface_debug_print("i2c write failed, check the i2c address or wiring\n");
    4a28:	4802      	ldr	r0, [pc, #8]	; (4a34 <mcp794xx_interface_i2c_read+0x18>)
    4a2a:	4478      	add	r0, pc
    4a2c:	f7ff ffd2 	bl	49d4 <mcp794xx_interface_debug_print>
	    return 1;
    4a30:	2001      	movs	r0, #1
    4a32:	e7f8      	b.n	4a26 <mcp794xx_interface_i2c_read+0xa>
    4a34:	0000396a 	.word	0x0000396a

00004a38 <mcp794xx_interface_i2c_write>:
{
    4a38:	b510      	push	{r4, lr}
    if(i2c_write(u8Addr, pBuf, u8Length) !=  0)
    4a3a:	f7fd f8ad 	bl	1b98 <i2c_write>
    4a3e:	2800      	cmp	r0, #0
    4a40:	d100      	bne.n	4a44 <mcp794xx_interface_i2c_write+0xc>
}
    4a42:	bd10      	pop	{r4, pc}
	    mcp794xx_interface_debug_print("i2c write failed, check the i2c address or wiring\n");
    4a44:	4802      	ldr	r0, [pc, #8]	; (4a50 <mcp794xx_interface_i2c_write+0x18>)
    4a46:	4478      	add	r0, pc
    4a48:	f7ff ffc4 	bl	49d4 <mcp794xx_interface_debug_print>
	    return 1;
    4a4c:	2001      	movs	r0, #1
    4a4e:	e7f8      	b.n	4a42 <mcp794xx_interface_i2c_write+0xa>
    4a50:	0000394e 	.word	0x0000394e

00004a54 <mcp794xx_interface_irq_callback>:
 * @brief     interface interrupt request callback
 * @param[in] u8Type is the interrupt type
 * @note      Do not use delay function or blocking code in here, such code could crush your code.
 */
void mcp794xx_interface_irq_callback(mcp794xx_alarm_t u8Type)
{
    4a54:	b510      	push	{r4, lr}
    /*call your delay function here*/
    /*user code begin */

    switch(u8Type)
    4a56:	2801      	cmp	r0, #1
    4a58:	d101      	bne.n	4a5e <mcp794xx_interface_irq_callback+0xa>
        case MCP794XX_ALARM1:
        {
          /* It's highly recommended to keep your code as short as possible in an interrupt callback function */
          /*user code begin */
		  
			led_toggle();
    4a5a:	f7fd f8e5 	bl	1c28 <led_toggle>

    }
	
    /*user code end*/

}
    4a5e:	bd10      	pop	{r4, pc}

00004a60 <ceil>:
    4a60:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    4a62:	4657      	mov	r7, sl
    4a64:	464e      	mov	r6, r9
    4a66:	4645      	mov	r5, r8
    4a68:	46de      	mov	lr, fp
    4a6a:	004b      	lsls	r3, r1, #1
    4a6c:	4a41      	ldr	r2, [pc, #260]	; (4b74 <ceil+0x114>)
    4a6e:	0d5b      	lsrs	r3, r3, #21
    4a70:	b5e0      	push	{r5, r6, r7, lr}
    4a72:	189f      	adds	r7, r3, r2
    4a74:	0005      	movs	r5, r0
    4a76:	000c      	movs	r4, r1
    4a78:	4680      	mov	r8, r0
    4a7a:	000e      	movs	r6, r1
    4a7c:	4689      	mov	r9, r1
    4a7e:	4682      	mov	sl, r0
    4a80:	2f13      	cmp	r7, #19
    4a82:	dc26      	bgt.n	4ad2 <ceil+0x72>
    4a84:	2f00      	cmp	r7, #0
    4a86:	db56      	blt.n	4b36 <ceil+0xd6>
    4a88:	4b3b      	ldr	r3, [pc, #236]	; (4b78 <ceil+0x118>)
    4a8a:	413b      	asrs	r3, r7
    4a8c:	4698      	mov	r8, r3
    4a8e:	000b      	movs	r3, r1
    4a90:	4642      	mov	r2, r8
    4a92:	4013      	ands	r3, r2
    4a94:	4303      	orrs	r3, r0
    4a96:	d016      	beq.n	4ac6 <ceil+0x66>
    4a98:	4a38      	ldr	r2, [pc, #224]	; (4b7c <ceil+0x11c>)
    4a9a:	4b39      	ldr	r3, [pc, #228]	; (4b80 <ceil+0x120>)
    4a9c:	f000 fd8c 	bl	55b8 <__aeabi_dadd>
    4aa0:	2200      	movs	r2, #0
    4aa2:	2300      	movs	r3, #0
    4aa4:	f000 fa26 	bl	4ef4 <__aeabi_dcmpgt>
    4aa8:	2800      	cmp	r0, #0
    4aaa:	d00a      	beq.n	4ac2 <ceil+0x62>
    4aac:	2c00      	cmp	r4, #0
    4aae:	dd03      	ble.n	4ab8 <ceil+0x58>
    4ab0:	2380      	movs	r3, #128	; 0x80
    4ab2:	035b      	lsls	r3, r3, #13
    4ab4:	413b      	asrs	r3, r7
    4ab6:	4499      	add	r9, r3
    4ab8:	4643      	mov	r3, r8
    4aba:	464e      	mov	r6, r9
    4abc:	439e      	bics	r6, r3
    4abe:	2300      	movs	r3, #0
    4ac0:	469a      	mov	sl, r3
    4ac2:	4650      	mov	r0, sl
    4ac4:	0031      	movs	r1, r6
    4ac6:	bc3c      	pop	{r2, r3, r4, r5}
    4ac8:	4690      	mov	r8, r2
    4aca:	4699      	mov	r9, r3
    4acc:	46a2      	mov	sl, r4
    4ace:	46ab      	mov	fp, r5
    4ad0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    4ad2:	2f33      	cmp	r7, #51	; 0x33
    4ad4:	dd08      	ble.n	4ae8 <ceil+0x88>
    4ad6:	2380      	movs	r3, #128	; 0x80
    4ad8:	00db      	lsls	r3, r3, #3
    4ada:	429f      	cmp	r7, r3
    4adc:	d1f3      	bne.n	4ac6 <ceil+0x66>
    4ade:	0002      	movs	r2, r0
    4ae0:	000b      	movs	r3, r1
    4ae2:	f000 fd69 	bl	55b8 <__aeabi_dadd>
    4ae6:	e7ee      	b.n	4ac6 <ceil+0x66>
    4ae8:	4a26      	ldr	r2, [pc, #152]	; (4b84 <ceil+0x124>)
    4aea:	4694      	mov	ip, r2
    4aec:	2201      	movs	r2, #1
    4aee:	4463      	add	r3, ip
    4af0:	4252      	negs	r2, r2
    4af2:	40da      	lsrs	r2, r3
    4af4:	4693      	mov	fp, r2
    4af6:	4202      	tst	r2, r0
    4af8:	d0e5      	beq.n	4ac6 <ceil+0x66>
    4afa:	4a20      	ldr	r2, [pc, #128]	; (4b7c <ceil+0x11c>)
    4afc:	4b20      	ldr	r3, [pc, #128]	; (4b80 <ceil+0x120>)
    4afe:	f000 fd5b 	bl	55b8 <__aeabi_dadd>
    4b02:	2200      	movs	r2, #0
    4b04:	2300      	movs	r3, #0
    4b06:	f000 f9f5 	bl	4ef4 <__aeabi_dcmpgt>
    4b0a:	2800      	cmp	r0, #0
    4b0c:	d0d9      	beq.n	4ac2 <ceil+0x62>
    4b0e:	2c00      	cmp	r4, #0
    4b10:	dd28      	ble.n	4b64 <ceil+0x104>
    4b12:	2f14      	cmp	r7, #20
    4b14:	d023      	beq.n	4b5e <ceil+0xfe>
    4b16:	2334      	movs	r3, #52	; 0x34
    4b18:	1bdb      	subs	r3, r3, r7
    4b1a:	2701      	movs	r7, #1
    4b1c:	409f      	lsls	r7, r3
    4b1e:	197f      	adds	r7, r7, r5
    4b20:	42af      	cmp	r7, r5
    4b22:	419b      	sbcs	r3, r3
    4b24:	425b      	negs	r3, r3
    4b26:	4499      	add	r9, r3
    4b28:	465b      	mov	r3, fp
    4b2a:	439f      	bics	r7, r3
    4b2c:	464e      	mov	r6, r9
    4b2e:	46ba      	mov	sl, r7
    4b30:	0031      	movs	r1, r6
    4b32:	4650      	mov	r0, sl
    4b34:	e7c7      	b.n	4ac6 <ceil+0x66>
    4b36:	4a11      	ldr	r2, [pc, #68]	; (4b7c <ceil+0x11c>)
    4b38:	4b11      	ldr	r3, [pc, #68]	; (4b80 <ceil+0x120>)
    4b3a:	f000 fd3d 	bl	55b8 <__aeabi_dadd>
    4b3e:	2200      	movs	r2, #0
    4b40:	2300      	movs	r3, #0
    4b42:	f000 f9d7 	bl	4ef4 <__aeabi_dcmpgt>
    4b46:	2800      	cmp	r0, #0
    4b48:	d0bb      	beq.n	4ac2 <ceil+0x62>
    4b4a:	2c00      	cmp	r4, #0
    4b4c:	db0c      	blt.n	4b68 <ceil+0x108>
    4b4e:	2300      	movs	r3, #0
    4b50:	432c      	orrs	r4, r5
    4b52:	469a      	mov	sl, r3
    4b54:	2600      	movs	r6, #0
    4b56:	2c00      	cmp	r4, #0
    4b58:	d0b3      	beq.n	4ac2 <ceil+0x62>
    4b5a:	4e0b      	ldr	r6, [pc, #44]	; (4b88 <ceil+0x128>)
    4b5c:	e7b1      	b.n	4ac2 <ceil+0x62>
    4b5e:	2301      	movs	r3, #1
    4b60:	469c      	mov	ip, r3
    4b62:	44e1      	add	r9, ip
    4b64:	4647      	mov	r7, r8
    4b66:	e7df      	b.n	4b28 <ceil+0xc8>
    4b68:	2300      	movs	r3, #0
    4b6a:	2680      	movs	r6, #128	; 0x80
    4b6c:	469a      	mov	sl, r3
    4b6e:	0636      	lsls	r6, r6, #24
    4b70:	e7a7      	b.n	4ac2 <ceil+0x62>
    4b72:	46c0      	nop			; (mov r8, r8)
    4b74:	fffffc01 	.word	0xfffffc01
    4b78:	000fffff 	.word	0x000fffff
    4b7c:	8800759c 	.word	0x8800759c
    4b80:	7e37e43c 	.word	0x7e37e43c
    4b84:	fffffbed 	.word	0xfffffbed
    4b88:	3ff00000 	.word	0x3ff00000

00004b8c <__gnu_thumb1_case_uqi>:
    4b8c:	b402      	push	{r1}
    4b8e:	4671      	mov	r1, lr
    4b90:	0849      	lsrs	r1, r1, #1
    4b92:	0049      	lsls	r1, r1, #1
    4b94:	5c09      	ldrb	r1, [r1, r0]
    4b96:	0049      	lsls	r1, r1, #1
    4b98:	448e      	add	lr, r1
    4b9a:	bc02      	pop	{r1}
    4b9c:	4770      	bx	lr
    4b9e:	46c0      	nop			; (mov r8, r8)

00004ba0 <__gnu_thumb1_case_shi>:
    4ba0:	b403      	push	{r0, r1}
    4ba2:	4671      	mov	r1, lr
    4ba4:	0849      	lsrs	r1, r1, #1
    4ba6:	0040      	lsls	r0, r0, #1
    4ba8:	0049      	lsls	r1, r1, #1
    4baa:	5e09      	ldrsh	r1, [r1, r0]
    4bac:	0049      	lsls	r1, r1, #1
    4bae:	448e      	add	lr, r1
    4bb0:	bc03      	pop	{r0, r1}
    4bb2:	4770      	bx	lr

00004bb4 <__udivsi3>:
    4bb4:	2200      	movs	r2, #0
    4bb6:	0843      	lsrs	r3, r0, #1
    4bb8:	428b      	cmp	r3, r1
    4bba:	d374      	bcc.n	4ca6 <__udivsi3+0xf2>
    4bbc:	0903      	lsrs	r3, r0, #4
    4bbe:	428b      	cmp	r3, r1
    4bc0:	d35f      	bcc.n	4c82 <__udivsi3+0xce>
    4bc2:	0a03      	lsrs	r3, r0, #8
    4bc4:	428b      	cmp	r3, r1
    4bc6:	d344      	bcc.n	4c52 <__udivsi3+0x9e>
    4bc8:	0b03      	lsrs	r3, r0, #12
    4bca:	428b      	cmp	r3, r1
    4bcc:	d328      	bcc.n	4c20 <__udivsi3+0x6c>
    4bce:	0c03      	lsrs	r3, r0, #16
    4bd0:	428b      	cmp	r3, r1
    4bd2:	d30d      	bcc.n	4bf0 <__udivsi3+0x3c>
    4bd4:	22ff      	movs	r2, #255	; 0xff
    4bd6:	0209      	lsls	r1, r1, #8
    4bd8:	ba12      	rev	r2, r2
    4bda:	0c03      	lsrs	r3, r0, #16
    4bdc:	428b      	cmp	r3, r1
    4bde:	d302      	bcc.n	4be6 <__udivsi3+0x32>
    4be0:	1212      	asrs	r2, r2, #8
    4be2:	0209      	lsls	r1, r1, #8
    4be4:	d065      	beq.n	4cb2 <__udivsi3+0xfe>
    4be6:	0b03      	lsrs	r3, r0, #12
    4be8:	428b      	cmp	r3, r1
    4bea:	d319      	bcc.n	4c20 <__udivsi3+0x6c>
    4bec:	e000      	b.n	4bf0 <__udivsi3+0x3c>
    4bee:	0a09      	lsrs	r1, r1, #8
    4bf0:	0bc3      	lsrs	r3, r0, #15
    4bf2:	428b      	cmp	r3, r1
    4bf4:	d301      	bcc.n	4bfa <__udivsi3+0x46>
    4bf6:	03cb      	lsls	r3, r1, #15
    4bf8:	1ac0      	subs	r0, r0, r3
    4bfa:	4152      	adcs	r2, r2
    4bfc:	0b83      	lsrs	r3, r0, #14
    4bfe:	428b      	cmp	r3, r1
    4c00:	d301      	bcc.n	4c06 <__udivsi3+0x52>
    4c02:	038b      	lsls	r3, r1, #14
    4c04:	1ac0      	subs	r0, r0, r3
    4c06:	4152      	adcs	r2, r2
    4c08:	0b43      	lsrs	r3, r0, #13
    4c0a:	428b      	cmp	r3, r1
    4c0c:	d301      	bcc.n	4c12 <__udivsi3+0x5e>
    4c0e:	034b      	lsls	r3, r1, #13
    4c10:	1ac0      	subs	r0, r0, r3
    4c12:	4152      	adcs	r2, r2
    4c14:	0b03      	lsrs	r3, r0, #12
    4c16:	428b      	cmp	r3, r1
    4c18:	d301      	bcc.n	4c1e <__udivsi3+0x6a>
    4c1a:	030b      	lsls	r3, r1, #12
    4c1c:	1ac0      	subs	r0, r0, r3
    4c1e:	4152      	adcs	r2, r2
    4c20:	0ac3      	lsrs	r3, r0, #11
    4c22:	428b      	cmp	r3, r1
    4c24:	d301      	bcc.n	4c2a <__udivsi3+0x76>
    4c26:	02cb      	lsls	r3, r1, #11
    4c28:	1ac0      	subs	r0, r0, r3
    4c2a:	4152      	adcs	r2, r2
    4c2c:	0a83      	lsrs	r3, r0, #10
    4c2e:	428b      	cmp	r3, r1
    4c30:	d301      	bcc.n	4c36 <__udivsi3+0x82>
    4c32:	028b      	lsls	r3, r1, #10
    4c34:	1ac0      	subs	r0, r0, r3
    4c36:	4152      	adcs	r2, r2
    4c38:	0a43      	lsrs	r3, r0, #9
    4c3a:	428b      	cmp	r3, r1
    4c3c:	d301      	bcc.n	4c42 <__udivsi3+0x8e>
    4c3e:	024b      	lsls	r3, r1, #9
    4c40:	1ac0      	subs	r0, r0, r3
    4c42:	4152      	adcs	r2, r2
    4c44:	0a03      	lsrs	r3, r0, #8
    4c46:	428b      	cmp	r3, r1
    4c48:	d301      	bcc.n	4c4e <__udivsi3+0x9a>
    4c4a:	020b      	lsls	r3, r1, #8
    4c4c:	1ac0      	subs	r0, r0, r3
    4c4e:	4152      	adcs	r2, r2
    4c50:	d2cd      	bcs.n	4bee <__udivsi3+0x3a>
    4c52:	09c3      	lsrs	r3, r0, #7
    4c54:	428b      	cmp	r3, r1
    4c56:	d301      	bcc.n	4c5c <__udivsi3+0xa8>
    4c58:	01cb      	lsls	r3, r1, #7
    4c5a:	1ac0      	subs	r0, r0, r3
    4c5c:	4152      	adcs	r2, r2
    4c5e:	0983      	lsrs	r3, r0, #6
    4c60:	428b      	cmp	r3, r1
    4c62:	d301      	bcc.n	4c68 <__udivsi3+0xb4>
    4c64:	018b      	lsls	r3, r1, #6
    4c66:	1ac0      	subs	r0, r0, r3
    4c68:	4152      	adcs	r2, r2
    4c6a:	0943      	lsrs	r3, r0, #5
    4c6c:	428b      	cmp	r3, r1
    4c6e:	d301      	bcc.n	4c74 <__udivsi3+0xc0>
    4c70:	014b      	lsls	r3, r1, #5
    4c72:	1ac0      	subs	r0, r0, r3
    4c74:	4152      	adcs	r2, r2
    4c76:	0903      	lsrs	r3, r0, #4
    4c78:	428b      	cmp	r3, r1
    4c7a:	d301      	bcc.n	4c80 <__udivsi3+0xcc>
    4c7c:	010b      	lsls	r3, r1, #4
    4c7e:	1ac0      	subs	r0, r0, r3
    4c80:	4152      	adcs	r2, r2
    4c82:	08c3      	lsrs	r3, r0, #3
    4c84:	428b      	cmp	r3, r1
    4c86:	d301      	bcc.n	4c8c <__udivsi3+0xd8>
    4c88:	00cb      	lsls	r3, r1, #3
    4c8a:	1ac0      	subs	r0, r0, r3
    4c8c:	4152      	adcs	r2, r2
    4c8e:	0883      	lsrs	r3, r0, #2
    4c90:	428b      	cmp	r3, r1
    4c92:	d301      	bcc.n	4c98 <__udivsi3+0xe4>
    4c94:	008b      	lsls	r3, r1, #2
    4c96:	1ac0      	subs	r0, r0, r3
    4c98:	4152      	adcs	r2, r2
    4c9a:	0843      	lsrs	r3, r0, #1
    4c9c:	428b      	cmp	r3, r1
    4c9e:	d301      	bcc.n	4ca4 <__udivsi3+0xf0>
    4ca0:	004b      	lsls	r3, r1, #1
    4ca2:	1ac0      	subs	r0, r0, r3
    4ca4:	4152      	adcs	r2, r2
    4ca6:	1a41      	subs	r1, r0, r1
    4ca8:	d200      	bcs.n	4cac <__udivsi3+0xf8>
    4caa:	4601      	mov	r1, r0
    4cac:	4152      	adcs	r2, r2
    4cae:	4610      	mov	r0, r2
    4cb0:	4770      	bx	lr
    4cb2:	e7ff      	b.n	4cb4 <__udivsi3+0x100>
    4cb4:	b501      	push	{r0, lr}
    4cb6:	2000      	movs	r0, #0
    4cb8:	f000 f8f0 	bl	4e9c <__aeabi_idiv0>
    4cbc:	bd02      	pop	{r1, pc}
    4cbe:	46c0      	nop			; (mov r8, r8)

00004cc0 <__aeabi_uidivmod>:
    4cc0:	2900      	cmp	r1, #0
    4cc2:	d0f7      	beq.n	4cb4 <__udivsi3+0x100>
    4cc4:	e776      	b.n	4bb4 <__udivsi3>
    4cc6:	4770      	bx	lr

00004cc8 <__divsi3>:
    4cc8:	4603      	mov	r3, r0
    4cca:	430b      	orrs	r3, r1
    4ccc:	d47f      	bmi.n	4dce <__divsi3+0x106>
    4cce:	2200      	movs	r2, #0
    4cd0:	0843      	lsrs	r3, r0, #1
    4cd2:	428b      	cmp	r3, r1
    4cd4:	d374      	bcc.n	4dc0 <__divsi3+0xf8>
    4cd6:	0903      	lsrs	r3, r0, #4
    4cd8:	428b      	cmp	r3, r1
    4cda:	d35f      	bcc.n	4d9c <__divsi3+0xd4>
    4cdc:	0a03      	lsrs	r3, r0, #8
    4cde:	428b      	cmp	r3, r1
    4ce0:	d344      	bcc.n	4d6c <__divsi3+0xa4>
    4ce2:	0b03      	lsrs	r3, r0, #12
    4ce4:	428b      	cmp	r3, r1
    4ce6:	d328      	bcc.n	4d3a <__divsi3+0x72>
    4ce8:	0c03      	lsrs	r3, r0, #16
    4cea:	428b      	cmp	r3, r1
    4cec:	d30d      	bcc.n	4d0a <__divsi3+0x42>
    4cee:	22ff      	movs	r2, #255	; 0xff
    4cf0:	0209      	lsls	r1, r1, #8
    4cf2:	ba12      	rev	r2, r2
    4cf4:	0c03      	lsrs	r3, r0, #16
    4cf6:	428b      	cmp	r3, r1
    4cf8:	d302      	bcc.n	4d00 <__divsi3+0x38>
    4cfa:	1212      	asrs	r2, r2, #8
    4cfc:	0209      	lsls	r1, r1, #8
    4cfe:	d065      	beq.n	4dcc <__divsi3+0x104>
    4d00:	0b03      	lsrs	r3, r0, #12
    4d02:	428b      	cmp	r3, r1
    4d04:	d319      	bcc.n	4d3a <__divsi3+0x72>
    4d06:	e000      	b.n	4d0a <__divsi3+0x42>
    4d08:	0a09      	lsrs	r1, r1, #8
    4d0a:	0bc3      	lsrs	r3, r0, #15
    4d0c:	428b      	cmp	r3, r1
    4d0e:	d301      	bcc.n	4d14 <__divsi3+0x4c>
    4d10:	03cb      	lsls	r3, r1, #15
    4d12:	1ac0      	subs	r0, r0, r3
    4d14:	4152      	adcs	r2, r2
    4d16:	0b83      	lsrs	r3, r0, #14
    4d18:	428b      	cmp	r3, r1
    4d1a:	d301      	bcc.n	4d20 <__divsi3+0x58>
    4d1c:	038b      	lsls	r3, r1, #14
    4d1e:	1ac0      	subs	r0, r0, r3
    4d20:	4152      	adcs	r2, r2
    4d22:	0b43      	lsrs	r3, r0, #13
    4d24:	428b      	cmp	r3, r1
    4d26:	d301      	bcc.n	4d2c <__divsi3+0x64>
    4d28:	034b      	lsls	r3, r1, #13
    4d2a:	1ac0      	subs	r0, r0, r3
    4d2c:	4152      	adcs	r2, r2
    4d2e:	0b03      	lsrs	r3, r0, #12
    4d30:	428b      	cmp	r3, r1
    4d32:	d301      	bcc.n	4d38 <__divsi3+0x70>
    4d34:	030b      	lsls	r3, r1, #12
    4d36:	1ac0      	subs	r0, r0, r3
    4d38:	4152      	adcs	r2, r2
    4d3a:	0ac3      	lsrs	r3, r0, #11
    4d3c:	428b      	cmp	r3, r1
    4d3e:	d301      	bcc.n	4d44 <__divsi3+0x7c>
    4d40:	02cb      	lsls	r3, r1, #11
    4d42:	1ac0      	subs	r0, r0, r3
    4d44:	4152      	adcs	r2, r2
    4d46:	0a83      	lsrs	r3, r0, #10
    4d48:	428b      	cmp	r3, r1
    4d4a:	d301      	bcc.n	4d50 <__divsi3+0x88>
    4d4c:	028b      	lsls	r3, r1, #10
    4d4e:	1ac0      	subs	r0, r0, r3
    4d50:	4152      	adcs	r2, r2
    4d52:	0a43      	lsrs	r3, r0, #9
    4d54:	428b      	cmp	r3, r1
    4d56:	d301      	bcc.n	4d5c <__divsi3+0x94>
    4d58:	024b      	lsls	r3, r1, #9
    4d5a:	1ac0      	subs	r0, r0, r3
    4d5c:	4152      	adcs	r2, r2
    4d5e:	0a03      	lsrs	r3, r0, #8
    4d60:	428b      	cmp	r3, r1
    4d62:	d301      	bcc.n	4d68 <__divsi3+0xa0>
    4d64:	020b      	lsls	r3, r1, #8
    4d66:	1ac0      	subs	r0, r0, r3
    4d68:	4152      	adcs	r2, r2
    4d6a:	d2cd      	bcs.n	4d08 <__divsi3+0x40>
    4d6c:	09c3      	lsrs	r3, r0, #7
    4d6e:	428b      	cmp	r3, r1
    4d70:	d301      	bcc.n	4d76 <__divsi3+0xae>
    4d72:	01cb      	lsls	r3, r1, #7
    4d74:	1ac0      	subs	r0, r0, r3
    4d76:	4152      	adcs	r2, r2
    4d78:	0983      	lsrs	r3, r0, #6
    4d7a:	428b      	cmp	r3, r1
    4d7c:	d301      	bcc.n	4d82 <__divsi3+0xba>
    4d7e:	018b      	lsls	r3, r1, #6
    4d80:	1ac0      	subs	r0, r0, r3
    4d82:	4152      	adcs	r2, r2
    4d84:	0943      	lsrs	r3, r0, #5
    4d86:	428b      	cmp	r3, r1
    4d88:	d301      	bcc.n	4d8e <__divsi3+0xc6>
    4d8a:	014b      	lsls	r3, r1, #5
    4d8c:	1ac0      	subs	r0, r0, r3
    4d8e:	4152      	adcs	r2, r2
    4d90:	0903      	lsrs	r3, r0, #4
    4d92:	428b      	cmp	r3, r1
    4d94:	d301      	bcc.n	4d9a <__divsi3+0xd2>
    4d96:	010b      	lsls	r3, r1, #4
    4d98:	1ac0      	subs	r0, r0, r3
    4d9a:	4152      	adcs	r2, r2
    4d9c:	08c3      	lsrs	r3, r0, #3
    4d9e:	428b      	cmp	r3, r1
    4da0:	d301      	bcc.n	4da6 <__divsi3+0xde>
    4da2:	00cb      	lsls	r3, r1, #3
    4da4:	1ac0      	subs	r0, r0, r3
    4da6:	4152      	adcs	r2, r2
    4da8:	0883      	lsrs	r3, r0, #2
    4daa:	428b      	cmp	r3, r1
    4dac:	d301      	bcc.n	4db2 <__divsi3+0xea>
    4dae:	008b      	lsls	r3, r1, #2
    4db0:	1ac0      	subs	r0, r0, r3
    4db2:	4152      	adcs	r2, r2
    4db4:	0843      	lsrs	r3, r0, #1
    4db6:	428b      	cmp	r3, r1
    4db8:	d301      	bcc.n	4dbe <__divsi3+0xf6>
    4dba:	004b      	lsls	r3, r1, #1
    4dbc:	1ac0      	subs	r0, r0, r3
    4dbe:	4152      	adcs	r2, r2
    4dc0:	1a41      	subs	r1, r0, r1
    4dc2:	d200      	bcs.n	4dc6 <__divsi3+0xfe>
    4dc4:	4601      	mov	r1, r0
    4dc6:	4152      	adcs	r2, r2
    4dc8:	4610      	mov	r0, r2
    4dca:	4770      	bx	lr
    4dcc:	e05d      	b.n	4e8a <__divsi3+0x1c2>
    4dce:	0fca      	lsrs	r2, r1, #31
    4dd0:	d000      	beq.n	4dd4 <__divsi3+0x10c>
    4dd2:	4249      	negs	r1, r1
    4dd4:	1003      	asrs	r3, r0, #32
    4dd6:	d300      	bcc.n	4dda <__divsi3+0x112>
    4dd8:	4240      	negs	r0, r0
    4dda:	4053      	eors	r3, r2
    4ddc:	2200      	movs	r2, #0
    4dde:	469c      	mov	ip, r3
    4de0:	0903      	lsrs	r3, r0, #4
    4de2:	428b      	cmp	r3, r1
    4de4:	d32d      	bcc.n	4e42 <__divsi3+0x17a>
    4de6:	0a03      	lsrs	r3, r0, #8
    4de8:	428b      	cmp	r3, r1
    4dea:	d312      	bcc.n	4e12 <__divsi3+0x14a>
    4dec:	22fc      	movs	r2, #252	; 0xfc
    4dee:	0189      	lsls	r1, r1, #6
    4df0:	ba12      	rev	r2, r2
    4df2:	0a03      	lsrs	r3, r0, #8
    4df4:	428b      	cmp	r3, r1
    4df6:	d30c      	bcc.n	4e12 <__divsi3+0x14a>
    4df8:	0189      	lsls	r1, r1, #6
    4dfa:	1192      	asrs	r2, r2, #6
    4dfc:	428b      	cmp	r3, r1
    4dfe:	d308      	bcc.n	4e12 <__divsi3+0x14a>
    4e00:	0189      	lsls	r1, r1, #6
    4e02:	1192      	asrs	r2, r2, #6
    4e04:	428b      	cmp	r3, r1
    4e06:	d304      	bcc.n	4e12 <__divsi3+0x14a>
    4e08:	0189      	lsls	r1, r1, #6
    4e0a:	d03a      	beq.n	4e82 <__divsi3+0x1ba>
    4e0c:	1192      	asrs	r2, r2, #6
    4e0e:	e000      	b.n	4e12 <__divsi3+0x14a>
    4e10:	0989      	lsrs	r1, r1, #6
    4e12:	09c3      	lsrs	r3, r0, #7
    4e14:	428b      	cmp	r3, r1
    4e16:	d301      	bcc.n	4e1c <__divsi3+0x154>
    4e18:	01cb      	lsls	r3, r1, #7
    4e1a:	1ac0      	subs	r0, r0, r3
    4e1c:	4152      	adcs	r2, r2
    4e1e:	0983      	lsrs	r3, r0, #6
    4e20:	428b      	cmp	r3, r1
    4e22:	d301      	bcc.n	4e28 <__divsi3+0x160>
    4e24:	018b      	lsls	r3, r1, #6
    4e26:	1ac0      	subs	r0, r0, r3
    4e28:	4152      	adcs	r2, r2
    4e2a:	0943      	lsrs	r3, r0, #5
    4e2c:	428b      	cmp	r3, r1
    4e2e:	d301      	bcc.n	4e34 <__divsi3+0x16c>
    4e30:	014b      	lsls	r3, r1, #5
    4e32:	1ac0      	subs	r0, r0, r3
    4e34:	4152      	adcs	r2, r2
    4e36:	0903      	lsrs	r3, r0, #4
    4e38:	428b      	cmp	r3, r1
    4e3a:	d301      	bcc.n	4e40 <__divsi3+0x178>
    4e3c:	010b      	lsls	r3, r1, #4
    4e3e:	1ac0      	subs	r0, r0, r3
    4e40:	4152      	adcs	r2, r2
    4e42:	08c3      	lsrs	r3, r0, #3
    4e44:	428b      	cmp	r3, r1
    4e46:	d301      	bcc.n	4e4c <__divsi3+0x184>
    4e48:	00cb      	lsls	r3, r1, #3
    4e4a:	1ac0      	subs	r0, r0, r3
    4e4c:	4152      	adcs	r2, r2
    4e4e:	0883      	lsrs	r3, r0, #2
    4e50:	428b      	cmp	r3, r1
    4e52:	d301      	bcc.n	4e58 <__divsi3+0x190>
    4e54:	008b      	lsls	r3, r1, #2
    4e56:	1ac0      	subs	r0, r0, r3
    4e58:	4152      	adcs	r2, r2
    4e5a:	d2d9      	bcs.n	4e10 <__divsi3+0x148>
    4e5c:	0843      	lsrs	r3, r0, #1
    4e5e:	428b      	cmp	r3, r1
    4e60:	d301      	bcc.n	4e66 <__divsi3+0x19e>
    4e62:	004b      	lsls	r3, r1, #1
    4e64:	1ac0      	subs	r0, r0, r3
    4e66:	4152      	adcs	r2, r2
    4e68:	1a41      	subs	r1, r0, r1
    4e6a:	d200      	bcs.n	4e6e <__divsi3+0x1a6>
    4e6c:	4601      	mov	r1, r0
    4e6e:	4663      	mov	r3, ip
    4e70:	4152      	adcs	r2, r2
    4e72:	105b      	asrs	r3, r3, #1
    4e74:	4610      	mov	r0, r2
    4e76:	d301      	bcc.n	4e7c <__divsi3+0x1b4>
    4e78:	4240      	negs	r0, r0
    4e7a:	2b00      	cmp	r3, #0
    4e7c:	d500      	bpl.n	4e80 <__divsi3+0x1b8>
    4e7e:	4249      	negs	r1, r1
    4e80:	4770      	bx	lr
    4e82:	4663      	mov	r3, ip
    4e84:	105b      	asrs	r3, r3, #1
    4e86:	d300      	bcc.n	4e8a <__divsi3+0x1c2>
    4e88:	4240      	negs	r0, r0
    4e8a:	b501      	push	{r0, lr}
    4e8c:	2000      	movs	r0, #0
    4e8e:	f000 f805 	bl	4e9c <__aeabi_idiv0>
    4e92:	bd02      	pop	{r1, pc}

00004e94 <__aeabi_idivmod>:
    4e94:	2900      	cmp	r1, #0
    4e96:	d0f8      	beq.n	4e8a <__divsi3+0x1c2>
    4e98:	e716      	b.n	4cc8 <__divsi3>
    4e9a:	4770      	bx	lr

00004e9c <__aeabi_idiv0>:
    4e9c:	4770      	bx	lr
    4e9e:	46c0      	nop			; (mov r8, r8)

00004ea0 <__aeabi_cdrcmple>:
    4ea0:	4684      	mov	ip, r0
    4ea2:	1c10      	adds	r0, r2, #0
    4ea4:	4662      	mov	r2, ip
    4ea6:	468c      	mov	ip, r1
    4ea8:	1c19      	adds	r1, r3, #0
    4eaa:	4663      	mov	r3, ip
    4eac:	e000      	b.n	4eb0 <__aeabi_cdcmpeq>
    4eae:	46c0      	nop			; (mov r8, r8)

00004eb0 <__aeabi_cdcmpeq>:
    4eb0:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    4eb2:	f000 ff2f 	bl	5d14 <__ledf2>
    4eb6:	2800      	cmp	r0, #0
    4eb8:	d401      	bmi.n	4ebe <__aeabi_cdcmpeq+0xe>
    4eba:	2100      	movs	r1, #0
    4ebc:	42c8      	cmn	r0, r1
    4ebe:	bd1f      	pop	{r0, r1, r2, r3, r4, pc}

00004ec0 <__aeabi_dcmpeq>:
    4ec0:	b510      	push	{r4, lr}
    4ec2:	f000 fe89 	bl	5bd8 <__eqdf2>
    4ec6:	4240      	negs	r0, r0
    4ec8:	3001      	adds	r0, #1
    4eca:	bd10      	pop	{r4, pc}

00004ecc <__aeabi_dcmplt>:
    4ecc:	b510      	push	{r4, lr}
    4ece:	f000 ff21 	bl	5d14 <__ledf2>
    4ed2:	2800      	cmp	r0, #0
    4ed4:	db01      	blt.n	4eda <__aeabi_dcmplt+0xe>
    4ed6:	2000      	movs	r0, #0
    4ed8:	bd10      	pop	{r4, pc}
    4eda:	2001      	movs	r0, #1
    4edc:	bd10      	pop	{r4, pc}
    4ede:	46c0      	nop			; (mov r8, r8)

00004ee0 <__aeabi_dcmple>:
    4ee0:	b510      	push	{r4, lr}
    4ee2:	f000 ff17 	bl	5d14 <__ledf2>
    4ee6:	2800      	cmp	r0, #0
    4ee8:	dd01      	ble.n	4eee <__aeabi_dcmple+0xe>
    4eea:	2000      	movs	r0, #0
    4eec:	bd10      	pop	{r4, pc}
    4eee:	2001      	movs	r0, #1
    4ef0:	bd10      	pop	{r4, pc}
    4ef2:	46c0      	nop			; (mov r8, r8)

00004ef4 <__aeabi_dcmpgt>:
    4ef4:	b510      	push	{r4, lr}
    4ef6:	f000 fea9 	bl	5c4c <__gedf2>
    4efa:	2800      	cmp	r0, #0
    4efc:	dc01      	bgt.n	4f02 <__aeabi_dcmpgt+0xe>
    4efe:	2000      	movs	r0, #0
    4f00:	bd10      	pop	{r4, pc}
    4f02:	2001      	movs	r0, #1
    4f04:	bd10      	pop	{r4, pc}
    4f06:	46c0      	nop			; (mov r8, r8)

00004f08 <__aeabi_dcmpge>:
    4f08:	b510      	push	{r4, lr}
    4f0a:	f000 fe9f 	bl	5c4c <__gedf2>
    4f0e:	2800      	cmp	r0, #0
    4f10:	da01      	bge.n	4f16 <__aeabi_dcmpge+0xe>
    4f12:	2000      	movs	r0, #0
    4f14:	bd10      	pop	{r4, pc}
    4f16:	2001      	movs	r0, #1
    4f18:	bd10      	pop	{r4, pc}
    4f1a:	46c0      	nop			; (mov r8, r8)

00004f1c <__ffssi2>:
    4f1c:	b510      	push	{r4, lr}
    4f1e:	2300      	movs	r3, #0
    4f20:	2800      	cmp	r0, #0
    4f22:	d002      	beq.n	4f2a <__ffssi2+0xe>
    4f24:	f001 f836 	bl	5f94 <__ctzsi2>
    4f28:	1c43      	adds	r3, r0, #1
    4f2a:	0018      	movs	r0, r3
    4f2c:	bd10      	pop	{r4, pc}
    4f2e:	46c0      	nop			; (mov r8, r8)

00004f30 <__aeabi_f2uiz>:
    4f30:	219e      	movs	r1, #158	; 0x9e
    4f32:	b510      	push	{r4, lr}
    4f34:	05c9      	lsls	r1, r1, #23
    4f36:	1c04      	adds	r4, r0, #0
    4f38:	f001 f804 	bl	5f44 <__aeabi_fcmpge>
    4f3c:	2800      	cmp	r0, #0
    4f3e:	d103      	bne.n	4f48 <__aeabi_f2uiz+0x18>
    4f40:	1c20      	adds	r0, r4, #0
    4f42:	f000 fac9 	bl	54d8 <__aeabi_f2iz>
    4f46:	bd10      	pop	{r4, pc}
    4f48:	219e      	movs	r1, #158	; 0x9e
    4f4a:	1c20      	adds	r0, r4, #0
    4f4c:	05c9      	lsls	r1, r1, #23
    4f4e:	f000 f927 	bl	51a0 <__aeabi_fsub>
    4f52:	f000 fac1 	bl	54d8 <__aeabi_f2iz>
    4f56:	2380      	movs	r3, #128	; 0x80
    4f58:	061b      	lsls	r3, r3, #24
    4f5a:	469c      	mov	ip, r3
    4f5c:	4460      	add	r0, ip
    4f5e:	e7f2      	b.n	4f46 <__aeabi_f2uiz+0x16>

00004f60 <__aeabi_fmul>:
    4f60:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    4f62:	4657      	mov	r7, sl
    4f64:	464e      	mov	r6, r9
    4f66:	4645      	mov	r5, r8
    4f68:	46de      	mov	lr, fp
    4f6a:	b5e0      	push	{r5, r6, r7, lr}
    4f6c:	0247      	lsls	r7, r0, #9
    4f6e:	0046      	lsls	r6, r0, #1
    4f70:	4688      	mov	r8, r1
    4f72:	0a7f      	lsrs	r7, r7, #9
    4f74:	0e36      	lsrs	r6, r6, #24
    4f76:	0fc4      	lsrs	r4, r0, #31
    4f78:	2e00      	cmp	r6, #0
    4f7a:	d047      	beq.n	500c <__aeabi_fmul+0xac>
    4f7c:	2eff      	cmp	r6, #255	; 0xff
    4f7e:	d024      	beq.n	4fca <__aeabi_fmul+0x6a>
    4f80:	00fb      	lsls	r3, r7, #3
    4f82:	2780      	movs	r7, #128	; 0x80
    4f84:	04ff      	lsls	r7, r7, #19
    4f86:	431f      	orrs	r7, r3
    4f88:	2300      	movs	r3, #0
    4f8a:	4699      	mov	r9, r3
    4f8c:	469a      	mov	sl, r3
    4f8e:	3e7f      	subs	r6, #127	; 0x7f
    4f90:	4643      	mov	r3, r8
    4f92:	025d      	lsls	r5, r3, #9
    4f94:	0058      	lsls	r0, r3, #1
    4f96:	0fdb      	lsrs	r3, r3, #31
    4f98:	0a6d      	lsrs	r5, r5, #9
    4f9a:	0e00      	lsrs	r0, r0, #24
    4f9c:	4698      	mov	r8, r3
    4f9e:	d043      	beq.n	5028 <__aeabi_fmul+0xc8>
    4fa0:	28ff      	cmp	r0, #255	; 0xff
    4fa2:	d03b      	beq.n	501c <__aeabi_fmul+0xbc>
    4fa4:	00eb      	lsls	r3, r5, #3
    4fa6:	2580      	movs	r5, #128	; 0x80
    4fa8:	2200      	movs	r2, #0
    4faa:	04ed      	lsls	r5, r5, #19
    4fac:	431d      	orrs	r5, r3
    4fae:	387f      	subs	r0, #127	; 0x7f
    4fb0:	1836      	adds	r6, r6, r0
    4fb2:	1c73      	adds	r3, r6, #1
    4fb4:	4641      	mov	r1, r8
    4fb6:	469b      	mov	fp, r3
    4fb8:	464b      	mov	r3, r9
    4fba:	4061      	eors	r1, r4
    4fbc:	4313      	orrs	r3, r2
    4fbe:	2b0f      	cmp	r3, #15
    4fc0:	d864      	bhi.n	508c <__aeabi_fmul+0x12c>
    4fc2:	4875      	ldr	r0, [pc, #468]	; (5198 <__aeabi_fmul+0x238>)
    4fc4:	009b      	lsls	r3, r3, #2
    4fc6:	58c3      	ldr	r3, [r0, r3]
    4fc8:	469f      	mov	pc, r3
    4fca:	2f00      	cmp	r7, #0
    4fcc:	d142      	bne.n	5054 <__aeabi_fmul+0xf4>
    4fce:	2308      	movs	r3, #8
    4fd0:	4699      	mov	r9, r3
    4fd2:	3b06      	subs	r3, #6
    4fd4:	26ff      	movs	r6, #255	; 0xff
    4fd6:	469a      	mov	sl, r3
    4fd8:	e7da      	b.n	4f90 <__aeabi_fmul+0x30>
    4fda:	4641      	mov	r1, r8
    4fdc:	2a02      	cmp	r2, #2
    4fde:	d028      	beq.n	5032 <__aeabi_fmul+0xd2>
    4fe0:	2a03      	cmp	r2, #3
    4fe2:	d100      	bne.n	4fe6 <__aeabi_fmul+0x86>
    4fe4:	e0ce      	b.n	5184 <__aeabi_fmul+0x224>
    4fe6:	2a01      	cmp	r2, #1
    4fe8:	d000      	beq.n	4fec <__aeabi_fmul+0x8c>
    4fea:	e0ac      	b.n	5146 <__aeabi_fmul+0x1e6>
    4fec:	4011      	ands	r1, r2
    4fee:	2000      	movs	r0, #0
    4ff0:	2200      	movs	r2, #0
    4ff2:	b2cc      	uxtb	r4, r1
    4ff4:	0240      	lsls	r0, r0, #9
    4ff6:	05d2      	lsls	r2, r2, #23
    4ff8:	0a40      	lsrs	r0, r0, #9
    4ffa:	07e4      	lsls	r4, r4, #31
    4ffc:	4310      	orrs	r0, r2
    4ffe:	4320      	orrs	r0, r4
    5000:	bc3c      	pop	{r2, r3, r4, r5}
    5002:	4690      	mov	r8, r2
    5004:	4699      	mov	r9, r3
    5006:	46a2      	mov	sl, r4
    5008:	46ab      	mov	fp, r5
    500a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    500c:	2f00      	cmp	r7, #0
    500e:	d115      	bne.n	503c <__aeabi_fmul+0xdc>
    5010:	2304      	movs	r3, #4
    5012:	4699      	mov	r9, r3
    5014:	3b03      	subs	r3, #3
    5016:	2600      	movs	r6, #0
    5018:	469a      	mov	sl, r3
    501a:	e7b9      	b.n	4f90 <__aeabi_fmul+0x30>
    501c:	20ff      	movs	r0, #255	; 0xff
    501e:	2202      	movs	r2, #2
    5020:	2d00      	cmp	r5, #0
    5022:	d0c5      	beq.n	4fb0 <__aeabi_fmul+0x50>
    5024:	2203      	movs	r2, #3
    5026:	e7c3      	b.n	4fb0 <__aeabi_fmul+0x50>
    5028:	2d00      	cmp	r5, #0
    502a:	d119      	bne.n	5060 <__aeabi_fmul+0x100>
    502c:	2000      	movs	r0, #0
    502e:	2201      	movs	r2, #1
    5030:	e7be      	b.n	4fb0 <__aeabi_fmul+0x50>
    5032:	2401      	movs	r4, #1
    5034:	22ff      	movs	r2, #255	; 0xff
    5036:	400c      	ands	r4, r1
    5038:	2000      	movs	r0, #0
    503a:	e7db      	b.n	4ff4 <__aeabi_fmul+0x94>
    503c:	0038      	movs	r0, r7
    503e:	f000 ff8b 	bl	5f58 <__clzsi2>
    5042:	2676      	movs	r6, #118	; 0x76
    5044:	1f43      	subs	r3, r0, #5
    5046:	409f      	lsls	r7, r3
    5048:	2300      	movs	r3, #0
    504a:	4276      	negs	r6, r6
    504c:	1a36      	subs	r6, r6, r0
    504e:	4699      	mov	r9, r3
    5050:	469a      	mov	sl, r3
    5052:	e79d      	b.n	4f90 <__aeabi_fmul+0x30>
    5054:	230c      	movs	r3, #12
    5056:	4699      	mov	r9, r3
    5058:	3b09      	subs	r3, #9
    505a:	26ff      	movs	r6, #255	; 0xff
    505c:	469a      	mov	sl, r3
    505e:	e797      	b.n	4f90 <__aeabi_fmul+0x30>
    5060:	0028      	movs	r0, r5
    5062:	f000 ff79 	bl	5f58 <__clzsi2>
    5066:	1f43      	subs	r3, r0, #5
    5068:	409d      	lsls	r5, r3
    506a:	2376      	movs	r3, #118	; 0x76
    506c:	425b      	negs	r3, r3
    506e:	1a18      	subs	r0, r3, r0
    5070:	2200      	movs	r2, #0
    5072:	e79d      	b.n	4fb0 <__aeabi_fmul+0x50>
    5074:	2080      	movs	r0, #128	; 0x80
    5076:	2400      	movs	r4, #0
    5078:	03c0      	lsls	r0, r0, #15
    507a:	22ff      	movs	r2, #255	; 0xff
    507c:	e7ba      	b.n	4ff4 <__aeabi_fmul+0x94>
    507e:	003d      	movs	r5, r7
    5080:	4652      	mov	r2, sl
    5082:	e7ab      	b.n	4fdc <__aeabi_fmul+0x7c>
    5084:	003d      	movs	r5, r7
    5086:	0021      	movs	r1, r4
    5088:	4652      	mov	r2, sl
    508a:	e7a7      	b.n	4fdc <__aeabi_fmul+0x7c>
    508c:	0c3b      	lsrs	r3, r7, #16
    508e:	469c      	mov	ip, r3
    5090:	042a      	lsls	r2, r5, #16
    5092:	0c12      	lsrs	r2, r2, #16
    5094:	0c2b      	lsrs	r3, r5, #16
    5096:	0014      	movs	r4, r2
    5098:	4660      	mov	r0, ip
    509a:	4665      	mov	r5, ip
    509c:	043f      	lsls	r7, r7, #16
    509e:	0c3f      	lsrs	r7, r7, #16
    50a0:	437c      	muls	r4, r7
    50a2:	4342      	muls	r2, r0
    50a4:	435d      	muls	r5, r3
    50a6:	437b      	muls	r3, r7
    50a8:	0c27      	lsrs	r7, r4, #16
    50aa:	189b      	adds	r3, r3, r2
    50ac:	18ff      	adds	r7, r7, r3
    50ae:	42ba      	cmp	r2, r7
    50b0:	d903      	bls.n	50ba <__aeabi_fmul+0x15a>
    50b2:	2380      	movs	r3, #128	; 0x80
    50b4:	025b      	lsls	r3, r3, #9
    50b6:	469c      	mov	ip, r3
    50b8:	4465      	add	r5, ip
    50ba:	0424      	lsls	r4, r4, #16
    50bc:	043a      	lsls	r2, r7, #16
    50be:	0c24      	lsrs	r4, r4, #16
    50c0:	1912      	adds	r2, r2, r4
    50c2:	0193      	lsls	r3, r2, #6
    50c4:	1e5c      	subs	r4, r3, #1
    50c6:	41a3      	sbcs	r3, r4
    50c8:	0c3f      	lsrs	r7, r7, #16
    50ca:	0e92      	lsrs	r2, r2, #26
    50cc:	197d      	adds	r5, r7, r5
    50ce:	431a      	orrs	r2, r3
    50d0:	01ad      	lsls	r5, r5, #6
    50d2:	4315      	orrs	r5, r2
    50d4:	012b      	lsls	r3, r5, #4
    50d6:	d504      	bpl.n	50e2 <__aeabi_fmul+0x182>
    50d8:	2301      	movs	r3, #1
    50da:	465e      	mov	r6, fp
    50dc:	086a      	lsrs	r2, r5, #1
    50de:	401d      	ands	r5, r3
    50e0:	4315      	orrs	r5, r2
    50e2:	0032      	movs	r2, r6
    50e4:	327f      	adds	r2, #127	; 0x7f
    50e6:	2a00      	cmp	r2, #0
    50e8:	dd25      	ble.n	5136 <__aeabi_fmul+0x1d6>
    50ea:	076b      	lsls	r3, r5, #29
    50ec:	d004      	beq.n	50f8 <__aeabi_fmul+0x198>
    50ee:	230f      	movs	r3, #15
    50f0:	402b      	ands	r3, r5
    50f2:	2b04      	cmp	r3, #4
    50f4:	d000      	beq.n	50f8 <__aeabi_fmul+0x198>
    50f6:	3504      	adds	r5, #4
    50f8:	012b      	lsls	r3, r5, #4
    50fa:	d503      	bpl.n	5104 <__aeabi_fmul+0x1a4>
    50fc:	0032      	movs	r2, r6
    50fe:	4b27      	ldr	r3, [pc, #156]	; (519c <__aeabi_fmul+0x23c>)
    5100:	3280      	adds	r2, #128	; 0x80
    5102:	401d      	ands	r5, r3
    5104:	2afe      	cmp	r2, #254	; 0xfe
    5106:	dc94      	bgt.n	5032 <__aeabi_fmul+0xd2>
    5108:	2401      	movs	r4, #1
    510a:	01a8      	lsls	r0, r5, #6
    510c:	0a40      	lsrs	r0, r0, #9
    510e:	b2d2      	uxtb	r2, r2
    5110:	400c      	ands	r4, r1
    5112:	e76f      	b.n	4ff4 <__aeabi_fmul+0x94>
    5114:	2080      	movs	r0, #128	; 0x80
    5116:	03c0      	lsls	r0, r0, #15
    5118:	4207      	tst	r7, r0
    511a:	d007      	beq.n	512c <__aeabi_fmul+0x1cc>
    511c:	4205      	tst	r5, r0
    511e:	d105      	bne.n	512c <__aeabi_fmul+0x1cc>
    5120:	4328      	orrs	r0, r5
    5122:	0240      	lsls	r0, r0, #9
    5124:	0a40      	lsrs	r0, r0, #9
    5126:	4644      	mov	r4, r8
    5128:	22ff      	movs	r2, #255	; 0xff
    512a:	e763      	b.n	4ff4 <__aeabi_fmul+0x94>
    512c:	4338      	orrs	r0, r7
    512e:	0240      	lsls	r0, r0, #9
    5130:	0a40      	lsrs	r0, r0, #9
    5132:	22ff      	movs	r2, #255	; 0xff
    5134:	e75e      	b.n	4ff4 <__aeabi_fmul+0x94>
    5136:	2401      	movs	r4, #1
    5138:	1aa3      	subs	r3, r4, r2
    513a:	2b1b      	cmp	r3, #27
    513c:	dd05      	ble.n	514a <__aeabi_fmul+0x1ea>
    513e:	400c      	ands	r4, r1
    5140:	2200      	movs	r2, #0
    5142:	2000      	movs	r0, #0
    5144:	e756      	b.n	4ff4 <__aeabi_fmul+0x94>
    5146:	465e      	mov	r6, fp
    5148:	e7cb      	b.n	50e2 <__aeabi_fmul+0x182>
    514a:	002a      	movs	r2, r5
    514c:	2020      	movs	r0, #32
    514e:	40da      	lsrs	r2, r3
    5150:	1ac3      	subs	r3, r0, r3
    5152:	409d      	lsls	r5, r3
    5154:	002b      	movs	r3, r5
    5156:	1e5d      	subs	r5, r3, #1
    5158:	41ab      	sbcs	r3, r5
    515a:	4313      	orrs	r3, r2
    515c:	075a      	lsls	r2, r3, #29
    515e:	d004      	beq.n	516a <__aeabi_fmul+0x20a>
    5160:	220f      	movs	r2, #15
    5162:	401a      	ands	r2, r3
    5164:	2a04      	cmp	r2, #4
    5166:	d000      	beq.n	516a <__aeabi_fmul+0x20a>
    5168:	3304      	adds	r3, #4
    516a:	015a      	lsls	r2, r3, #5
    516c:	d504      	bpl.n	5178 <__aeabi_fmul+0x218>
    516e:	2401      	movs	r4, #1
    5170:	2201      	movs	r2, #1
    5172:	400c      	ands	r4, r1
    5174:	2000      	movs	r0, #0
    5176:	e73d      	b.n	4ff4 <__aeabi_fmul+0x94>
    5178:	2401      	movs	r4, #1
    517a:	019b      	lsls	r3, r3, #6
    517c:	0a58      	lsrs	r0, r3, #9
    517e:	400c      	ands	r4, r1
    5180:	2200      	movs	r2, #0
    5182:	e737      	b.n	4ff4 <__aeabi_fmul+0x94>
    5184:	2080      	movs	r0, #128	; 0x80
    5186:	2401      	movs	r4, #1
    5188:	03c0      	lsls	r0, r0, #15
    518a:	4328      	orrs	r0, r5
    518c:	0240      	lsls	r0, r0, #9
    518e:	0a40      	lsrs	r0, r0, #9
    5190:	400c      	ands	r4, r1
    5192:	22ff      	movs	r2, #255	; 0xff
    5194:	e72e      	b.n	4ff4 <__aeabi_fmul+0x94>
    5196:	46c0      	nop			; (mov r8, r8)
    5198:	000083cc 	.word	0x000083cc
    519c:	f7ffffff 	.word	0xf7ffffff

000051a0 <__aeabi_fsub>:
    51a0:	b5f0      	push	{r4, r5, r6, r7, lr}
    51a2:	464f      	mov	r7, r9
    51a4:	46d6      	mov	lr, sl
    51a6:	4646      	mov	r6, r8
    51a8:	0044      	lsls	r4, r0, #1
    51aa:	b5c0      	push	{r6, r7, lr}
    51ac:	0fc2      	lsrs	r2, r0, #31
    51ae:	0247      	lsls	r7, r0, #9
    51b0:	0248      	lsls	r0, r1, #9
    51b2:	0a40      	lsrs	r0, r0, #9
    51b4:	4684      	mov	ip, r0
    51b6:	4666      	mov	r6, ip
    51b8:	0a7b      	lsrs	r3, r7, #9
    51ba:	0048      	lsls	r0, r1, #1
    51bc:	0fc9      	lsrs	r1, r1, #31
    51be:	469a      	mov	sl, r3
    51c0:	0e24      	lsrs	r4, r4, #24
    51c2:	0015      	movs	r5, r2
    51c4:	00db      	lsls	r3, r3, #3
    51c6:	0e00      	lsrs	r0, r0, #24
    51c8:	4689      	mov	r9, r1
    51ca:	00f6      	lsls	r6, r6, #3
    51cc:	28ff      	cmp	r0, #255	; 0xff
    51ce:	d100      	bne.n	51d2 <__aeabi_fsub+0x32>
    51d0:	e08f      	b.n	52f2 <__aeabi_fsub+0x152>
    51d2:	2101      	movs	r1, #1
    51d4:	464f      	mov	r7, r9
    51d6:	404f      	eors	r7, r1
    51d8:	0039      	movs	r1, r7
    51da:	4291      	cmp	r1, r2
    51dc:	d066      	beq.n	52ac <__aeabi_fsub+0x10c>
    51de:	1a22      	subs	r2, r4, r0
    51e0:	2a00      	cmp	r2, #0
    51e2:	dc00      	bgt.n	51e6 <__aeabi_fsub+0x46>
    51e4:	e09d      	b.n	5322 <__aeabi_fsub+0x182>
    51e6:	2800      	cmp	r0, #0
    51e8:	d13d      	bne.n	5266 <__aeabi_fsub+0xc6>
    51ea:	2e00      	cmp	r6, #0
    51ec:	d100      	bne.n	51f0 <__aeabi_fsub+0x50>
    51ee:	e08b      	b.n	5308 <__aeabi_fsub+0x168>
    51f0:	1e51      	subs	r1, r2, #1
    51f2:	2900      	cmp	r1, #0
    51f4:	d000      	beq.n	51f8 <__aeabi_fsub+0x58>
    51f6:	e0b5      	b.n	5364 <__aeabi_fsub+0x1c4>
    51f8:	2401      	movs	r4, #1
    51fa:	1b9b      	subs	r3, r3, r6
    51fc:	015a      	lsls	r2, r3, #5
    51fe:	d544      	bpl.n	528a <__aeabi_fsub+0xea>
    5200:	019b      	lsls	r3, r3, #6
    5202:	099f      	lsrs	r7, r3, #6
    5204:	0038      	movs	r0, r7
    5206:	f000 fea7 	bl	5f58 <__clzsi2>
    520a:	3805      	subs	r0, #5
    520c:	4087      	lsls	r7, r0
    520e:	4284      	cmp	r4, r0
    5210:	dd00      	ble.n	5214 <__aeabi_fsub+0x74>
    5212:	e096      	b.n	5342 <__aeabi_fsub+0x1a2>
    5214:	1b04      	subs	r4, r0, r4
    5216:	003a      	movs	r2, r7
    5218:	2020      	movs	r0, #32
    521a:	3401      	adds	r4, #1
    521c:	40e2      	lsrs	r2, r4
    521e:	1b04      	subs	r4, r0, r4
    5220:	40a7      	lsls	r7, r4
    5222:	003b      	movs	r3, r7
    5224:	1e5f      	subs	r7, r3, #1
    5226:	41bb      	sbcs	r3, r7
    5228:	2400      	movs	r4, #0
    522a:	4313      	orrs	r3, r2
    522c:	075a      	lsls	r2, r3, #29
    522e:	d004      	beq.n	523a <__aeabi_fsub+0x9a>
    5230:	220f      	movs	r2, #15
    5232:	401a      	ands	r2, r3
    5234:	2a04      	cmp	r2, #4
    5236:	d000      	beq.n	523a <__aeabi_fsub+0x9a>
    5238:	3304      	adds	r3, #4
    523a:	015a      	lsls	r2, r3, #5
    523c:	d527      	bpl.n	528e <__aeabi_fsub+0xee>
    523e:	3401      	adds	r4, #1
    5240:	2cff      	cmp	r4, #255	; 0xff
    5242:	d100      	bne.n	5246 <__aeabi_fsub+0xa6>
    5244:	e079      	b.n	533a <__aeabi_fsub+0x19a>
    5246:	2201      	movs	r2, #1
    5248:	019b      	lsls	r3, r3, #6
    524a:	0a5b      	lsrs	r3, r3, #9
    524c:	b2e4      	uxtb	r4, r4
    524e:	402a      	ands	r2, r5
    5250:	025b      	lsls	r3, r3, #9
    5252:	05e4      	lsls	r4, r4, #23
    5254:	0a58      	lsrs	r0, r3, #9
    5256:	07d2      	lsls	r2, r2, #31
    5258:	4320      	orrs	r0, r4
    525a:	4310      	orrs	r0, r2
    525c:	bc1c      	pop	{r2, r3, r4}
    525e:	4690      	mov	r8, r2
    5260:	4699      	mov	r9, r3
    5262:	46a2      	mov	sl, r4
    5264:	bdf0      	pop	{r4, r5, r6, r7, pc}
    5266:	2cff      	cmp	r4, #255	; 0xff
    5268:	d0e0      	beq.n	522c <__aeabi_fsub+0x8c>
    526a:	2180      	movs	r1, #128	; 0x80
    526c:	04c9      	lsls	r1, r1, #19
    526e:	430e      	orrs	r6, r1
    5270:	2a1b      	cmp	r2, #27
    5272:	dc7b      	bgt.n	536c <__aeabi_fsub+0x1cc>
    5274:	0031      	movs	r1, r6
    5276:	2020      	movs	r0, #32
    5278:	40d1      	lsrs	r1, r2
    527a:	1a82      	subs	r2, r0, r2
    527c:	4096      	lsls	r6, r2
    527e:	1e72      	subs	r2, r6, #1
    5280:	4196      	sbcs	r6, r2
    5282:	430e      	orrs	r6, r1
    5284:	1b9b      	subs	r3, r3, r6
    5286:	015a      	lsls	r2, r3, #5
    5288:	d4ba      	bmi.n	5200 <__aeabi_fsub+0x60>
    528a:	075a      	lsls	r2, r3, #29
    528c:	d1d0      	bne.n	5230 <__aeabi_fsub+0x90>
    528e:	2201      	movs	r2, #1
    5290:	08df      	lsrs	r7, r3, #3
    5292:	402a      	ands	r2, r5
    5294:	2cff      	cmp	r4, #255	; 0xff
    5296:	d133      	bne.n	5300 <__aeabi_fsub+0x160>
    5298:	2f00      	cmp	r7, #0
    529a:	d100      	bne.n	529e <__aeabi_fsub+0xfe>
    529c:	e0a8      	b.n	53f0 <__aeabi_fsub+0x250>
    529e:	2380      	movs	r3, #128	; 0x80
    52a0:	03db      	lsls	r3, r3, #15
    52a2:	433b      	orrs	r3, r7
    52a4:	025b      	lsls	r3, r3, #9
    52a6:	0a5b      	lsrs	r3, r3, #9
    52a8:	24ff      	movs	r4, #255	; 0xff
    52aa:	e7d1      	b.n	5250 <__aeabi_fsub+0xb0>
    52ac:	1a21      	subs	r1, r4, r0
    52ae:	2900      	cmp	r1, #0
    52b0:	dd4c      	ble.n	534c <__aeabi_fsub+0x1ac>
    52b2:	2800      	cmp	r0, #0
    52b4:	d02a      	beq.n	530c <__aeabi_fsub+0x16c>
    52b6:	2cff      	cmp	r4, #255	; 0xff
    52b8:	d0b8      	beq.n	522c <__aeabi_fsub+0x8c>
    52ba:	2080      	movs	r0, #128	; 0x80
    52bc:	04c0      	lsls	r0, r0, #19
    52be:	4306      	orrs	r6, r0
    52c0:	291b      	cmp	r1, #27
    52c2:	dd00      	ble.n	52c6 <__aeabi_fsub+0x126>
    52c4:	e0af      	b.n	5426 <__aeabi_fsub+0x286>
    52c6:	0030      	movs	r0, r6
    52c8:	2720      	movs	r7, #32
    52ca:	40c8      	lsrs	r0, r1
    52cc:	1a79      	subs	r1, r7, r1
    52ce:	408e      	lsls	r6, r1
    52d0:	1e71      	subs	r1, r6, #1
    52d2:	418e      	sbcs	r6, r1
    52d4:	4306      	orrs	r6, r0
    52d6:	199b      	adds	r3, r3, r6
    52d8:	0159      	lsls	r1, r3, #5
    52da:	d5d6      	bpl.n	528a <__aeabi_fsub+0xea>
    52dc:	3401      	adds	r4, #1
    52de:	2cff      	cmp	r4, #255	; 0xff
    52e0:	d100      	bne.n	52e4 <__aeabi_fsub+0x144>
    52e2:	e085      	b.n	53f0 <__aeabi_fsub+0x250>
    52e4:	2201      	movs	r2, #1
    52e6:	497a      	ldr	r1, [pc, #488]	; (54d0 <__aeabi_fsub+0x330>)
    52e8:	401a      	ands	r2, r3
    52ea:	085b      	lsrs	r3, r3, #1
    52ec:	400b      	ands	r3, r1
    52ee:	4313      	orrs	r3, r2
    52f0:	e79c      	b.n	522c <__aeabi_fsub+0x8c>
    52f2:	2e00      	cmp	r6, #0
    52f4:	d000      	beq.n	52f8 <__aeabi_fsub+0x158>
    52f6:	e770      	b.n	51da <__aeabi_fsub+0x3a>
    52f8:	e76b      	b.n	51d2 <__aeabi_fsub+0x32>
    52fa:	1e3b      	subs	r3, r7, #0
    52fc:	d1c5      	bne.n	528a <__aeabi_fsub+0xea>
    52fe:	2200      	movs	r2, #0
    5300:	027b      	lsls	r3, r7, #9
    5302:	0a5b      	lsrs	r3, r3, #9
    5304:	b2e4      	uxtb	r4, r4
    5306:	e7a3      	b.n	5250 <__aeabi_fsub+0xb0>
    5308:	0014      	movs	r4, r2
    530a:	e78f      	b.n	522c <__aeabi_fsub+0x8c>
    530c:	2e00      	cmp	r6, #0
    530e:	d04d      	beq.n	53ac <__aeabi_fsub+0x20c>
    5310:	1e48      	subs	r0, r1, #1
    5312:	2800      	cmp	r0, #0
    5314:	d157      	bne.n	53c6 <__aeabi_fsub+0x226>
    5316:	199b      	adds	r3, r3, r6
    5318:	2401      	movs	r4, #1
    531a:	015a      	lsls	r2, r3, #5
    531c:	d5b5      	bpl.n	528a <__aeabi_fsub+0xea>
    531e:	2402      	movs	r4, #2
    5320:	e7e0      	b.n	52e4 <__aeabi_fsub+0x144>
    5322:	2a00      	cmp	r2, #0
    5324:	d125      	bne.n	5372 <__aeabi_fsub+0x1d2>
    5326:	1c62      	adds	r2, r4, #1
    5328:	b2d2      	uxtb	r2, r2
    532a:	2a01      	cmp	r2, #1
    532c:	dd72      	ble.n	5414 <__aeabi_fsub+0x274>
    532e:	1b9f      	subs	r7, r3, r6
    5330:	017a      	lsls	r2, r7, #5
    5332:	d535      	bpl.n	53a0 <__aeabi_fsub+0x200>
    5334:	1af7      	subs	r7, r6, r3
    5336:	000d      	movs	r5, r1
    5338:	e764      	b.n	5204 <__aeabi_fsub+0x64>
    533a:	2201      	movs	r2, #1
    533c:	2300      	movs	r3, #0
    533e:	402a      	ands	r2, r5
    5340:	e786      	b.n	5250 <__aeabi_fsub+0xb0>
    5342:	003b      	movs	r3, r7
    5344:	4a63      	ldr	r2, [pc, #396]	; (54d4 <__aeabi_fsub+0x334>)
    5346:	1a24      	subs	r4, r4, r0
    5348:	4013      	ands	r3, r2
    534a:	e76f      	b.n	522c <__aeabi_fsub+0x8c>
    534c:	2900      	cmp	r1, #0
    534e:	d16c      	bne.n	542a <__aeabi_fsub+0x28a>
    5350:	1c61      	adds	r1, r4, #1
    5352:	b2c8      	uxtb	r0, r1
    5354:	2801      	cmp	r0, #1
    5356:	dd4e      	ble.n	53f6 <__aeabi_fsub+0x256>
    5358:	29ff      	cmp	r1, #255	; 0xff
    535a:	d049      	beq.n	53f0 <__aeabi_fsub+0x250>
    535c:	199b      	adds	r3, r3, r6
    535e:	085b      	lsrs	r3, r3, #1
    5360:	000c      	movs	r4, r1
    5362:	e763      	b.n	522c <__aeabi_fsub+0x8c>
    5364:	2aff      	cmp	r2, #255	; 0xff
    5366:	d041      	beq.n	53ec <__aeabi_fsub+0x24c>
    5368:	000a      	movs	r2, r1
    536a:	e781      	b.n	5270 <__aeabi_fsub+0xd0>
    536c:	2601      	movs	r6, #1
    536e:	1b9b      	subs	r3, r3, r6
    5370:	e789      	b.n	5286 <__aeabi_fsub+0xe6>
    5372:	2c00      	cmp	r4, #0
    5374:	d01c      	beq.n	53b0 <__aeabi_fsub+0x210>
    5376:	28ff      	cmp	r0, #255	; 0xff
    5378:	d021      	beq.n	53be <__aeabi_fsub+0x21e>
    537a:	2480      	movs	r4, #128	; 0x80
    537c:	04e4      	lsls	r4, r4, #19
    537e:	4252      	negs	r2, r2
    5380:	4323      	orrs	r3, r4
    5382:	2a1b      	cmp	r2, #27
    5384:	dd00      	ble.n	5388 <__aeabi_fsub+0x1e8>
    5386:	e096      	b.n	54b6 <__aeabi_fsub+0x316>
    5388:	001c      	movs	r4, r3
    538a:	2520      	movs	r5, #32
    538c:	40d4      	lsrs	r4, r2
    538e:	1aaa      	subs	r2, r5, r2
    5390:	4093      	lsls	r3, r2
    5392:	1e5a      	subs	r2, r3, #1
    5394:	4193      	sbcs	r3, r2
    5396:	4323      	orrs	r3, r4
    5398:	1af3      	subs	r3, r6, r3
    539a:	0004      	movs	r4, r0
    539c:	000d      	movs	r5, r1
    539e:	e72d      	b.n	51fc <__aeabi_fsub+0x5c>
    53a0:	2f00      	cmp	r7, #0
    53a2:	d000      	beq.n	53a6 <__aeabi_fsub+0x206>
    53a4:	e72e      	b.n	5204 <__aeabi_fsub+0x64>
    53a6:	2200      	movs	r2, #0
    53a8:	2400      	movs	r4, #0
    53aa:	e7a9      	b.n	5300 <__aeabi_fsub+0x160>
    53ac:	000c      	movs	r4, r1
    53ae:	e73d      	b.n	522c <__aeabi_fsub+0x8c>
    53b0:	2b00      	cmp	r3, #0
    53b2:	d058      	beq.n	5466 <__aeabi_fsub+0x2c6>
    53b4:	43d2      	mvns	r2, r2
    53b6:	2a00      	cmp	r2, #0
    53b8:	d0ee      	beq.n	5398 <__aeabi_fsub+0x1f8>
    53ba:	28ff      	cmp	r0, #255	; 0xff
    53bc:	d1e1      	bne.n	5382 <__aeabi_fsub+0x1e2>
    53be:	0033      	movs	r3, r6
    53c0:	24ff      	movs	r4, #255	; 0xff
    53c2:	000d      	movs	r5, r1
    53c4:	e732      	b.n	522c <__aeabi_fsub+0x8c>
    53c6:	29ff      	cmp	r1, #255	; 0xff
    53c8:	d010      	beq.n	53ec <__aeabi_fsub+0x24c>
    53ca:	0001      	movs	r1, r0
    53cc:	e778      	b.n	52c0 <__aeabi_fsub+0x120>
    53ce:	2b00      	cmp	r3, #0
    53d0:	d06e      	beq.n	54b0 <__aeabi_fsub+0x310>
    53d2:	24ff      	movs	r4, #255	; 0xff
    53d4:	2e00      	cmp	r6, #0
    53d6:	d100      	bne.n	53da <__aeabi_fsub+0x23a>
    53d8:	e728      	b.n	522c <__aeabi_fsub+0x8c>
    53da:	2280      	movs	r2, #128	; 0x80
    53dc:	4651      	mov	r1, sl
    53de:	03d2      	lsls	r2, r2, #15
    53e0:	4211      	tst	r1, r2
    53e2:	d003      	beq.n	53ec <__aeabi_fsub+0x24c>
    53e4:	4661      	mov	r1, ip
    53e6:	4211      	tst	r1, r2
    53e8:	d100      	bne.n	53ec <__aeabi_fsub+0x24c>
    53ea:	0033      	movs	r3, r6
    53ec:	24ff      	movs	r4, #255	; 0xff
    53ee:	e71d      	b.n	522c <__aeabi_fsub+0x8c>
    53f0:	24ff      	movs	r4, #255	; 0xff
    53f2:	2300      	movs	r3, #0
    53f4:	e72c      	b.n	5250 <__aeabi_fsub+0xb0>
    53f6:	2c00      	cmp	r4, #0
    53f8:	d1e9      	bne.n	53ce <__aeabi_fsub+0x22e>
    53fa:	2b00      	cmp	r3, #0
    53fc:	d063      	beq.n	54c6 <__aeabi_fsub+0x326>
    53fe:	2e00      	cmp	r6, #0
    5400:	d100      	bne.n	5404 <__aeabi_fsub+0x264>
    5402:	e713      	b.n	522c <__aeabi_fsub+0x8c>
    5404:	199b      	adds	r3, r3, r6
    5406:	015a      	lsls	r2, r3, #5
    5408:	d400      	bmi.n	540c <__aeabi_fsub+0x26c>
    540a:	e73e      	b.n	528a <__aeabi_fsub+0xea>
    540c:	4a31      	ldr	r2, [pc, #196]	; (54d4 <__aeabi_fsub+0x334>)
    540e:	000c      	movs	r4, r1
    5410:	4013      	ands	r3, r2
    5412:	e70b      	b.n	522c <__aeabi_fsub+0x8c>
    5414:	2c00      	cmp	r4, #0
    5416:	d11e      	bne.n	5456 <__aeabi_fsub+0x2b6>
    5418:	2b00      	cmp	r3, #0
    541a:	d12f      	bne.n	547c <__aeabi_fsub+0x2dc>
    541c:	2e00      	cmp	r6, #0
    541e:	d04f      	beq.n	54c0 <__aeabi_fsub+0x320>
    5420:	0033      	movs	r3, r6
    5422:	000d      	movs	r5, r1
    5424:	e702      	b.n	522c <__aeabi_fsub+0x8c>
    5426:	2601      	movs	r6, #1
    5428:	e755      	b.n	52d6 <__aeabi_fsub+0x136>
    542a:	2c00      	cmp	r4, #0
    542c:	d11f      	bne.n	546e <__aeabi_fsub+0x2ce>
    542e:	2b00      	cmp	r3, #0
    5430:	d043      	beq.n	54ba <__aeabi_fsub+0x31a>
    5432:	43c9      	mvns	r1, r1
    5434:	2900      	cmp	r1, #0
    5436:	d00b      	beq.n	5450 <__aeabi_fsub+0x2b0>
    5438:	28ff      	cmp	r0, #255	; 0xff
    543a:	d039      	beq.n	54b0 <__aeabi_fsub+0x310>
    543c:	291b      	cmp	r1, #27
    543e:	dc44      	bgt.n	54ca <__aeabi_fsub+0x32a>
    5440:	001c      	movs	r4, r3
    5442:	2720      	movs	r7, #32
    5444:	40cc      	lsrs	r4, r1
    5446:	1a79      	subs	r1, r7, r1
    5448:	408b      	lsls	r3, r1
    544a:	1e59      	subs	r1, r3, #1
    544c:	418b      	sbcs	r3, r1
    544e:	4323      	orrs	r3, r4
    5450:	199b      	adds	r3, r3, r6
    5452:	0004      	movs	r4, r0
    5454:	e740      	b.n	52d8 <__aeabi_fsub+0x138>
    5456:	2b00      	cmp	r3, #0
    5458:	d11a      	bne.n	5490 <__aeabi_fsub+0x2f0>
    545a:	2e00      	cmp	r6, #0
    545c:	d124      	bne.n	54a8 <__aeabi_fsub+0x308>
    545e:	2780      	movs	r7, #128	; 0x80
    5460:	2200      	movs	r2, #0
    5462:	03ff      	lsls	r7, r7, #15
    5464:	e71b      	b.n	529e <__aeabi_fsub+0xfe>
    5466:	0033      	movs	r3, r6
    5468:	0004      	movs	r4, r0
    546a:	000d      	movs	r5, r1
    546c:	e6de      	b.n	522c <__aeabi_fsub+0x8c>
    546e:	28ff      	cmp	r0, #255	; 0xff
    5470:	d01e      	beq.n	54b0 <__aeabi_fsub+0x310>
    5472:	2480      	movs	r4, #128	; 0x80
    5474:	04e4      	lsls	r4, r4, #19
    5476:	4249      	negs	r1, r1
    5478:	4323      	orrs	r3, r4
    547a:	e7df      	b.n	543c <__aeabi_fsub+0x29c>
    547c:	2e00      	cmp	r6, #0
    547e:	d100      	bne.n	5482 <__aeabi_fsub+0x2e2>
    5480:	e6d4      	b.n	522c <__aeabi_fsub+0x8c>
    5482:	1b9f      	subs	r7, r3, r6
    5484:	017a      	lsls	r2, r7, #5
    5486:	d400      	bmi.n	548a <__aeabi_fsub+0x2ea>
    5488:	e737      	b.n	52fa <__aeabi_fsub+0x15a>
    548a:	1af3      	subs	r3, r6, r3
    548c:	000d      	movs	r5, r1
    548e:	e6cd      	b.n	522c <__aeabi_fsub+0x8c>
    5490:	24ff      	movs	r4, #255	; 0xff
    5492:	2e00      	cmp	r6, #0
    5494:	d100      	bne.n	5498 <__aeabi_fsub+0x2f8>
    5496:	e6c9      	b.n	522c <__aeabi_fsub+0x8c>
    5498:	2280      	movs	r2, #128	; 0x80
    549a:	4650      	mov	r0, sl
    549c:	03d2      	lsls	r2, r2, #15
    549e:	4210      	tst	r0, r2
    54a0:	d0a4      	beq.n	53ec <__aeabi_fsub+0x24c>
    54a2:	4660      	mov	r0, ip
    54a4:	4210      	tst	r0, r2
    54a6:	d1a1      	bne.n	53ec <__aeabi_fsub+0x24c>
    54a8:	0033      	movs	r3, r6
    54aa:	000d      	movs	r5, r1
    54ac:	24ff      	movs	r4, #255	; 0xff
    54ae:	e6bd      	b.n	522c <__aeabi_fsub+0x8c>
    54b0:	0033      	movs	r3, r6
    54b2:	24ff      	movs	r4, #255	; 0xff
    54b4:	e6ba      	b.n	522c <__aeabi_fsub+0x8c>
    54b6:	2301      	movs	r3, #1
    54b8:	e76e      	b.n	5398 <__aeabi_fsub+0x1f8>
    54ba:	0033      	movs	r3, r6
    54bc:	0004      	movs	r4, r0
    54be:	e6b5      	b.n	522c <__aeabi_fsub+0x8c>
    54c0:	2700      	movs	r7, #0
    54c2:	2200      	movs	r2, #0
    54c4:	e71c      	b.n	5300 <__aeabi_fsub+0x160>
    54c6:	0033      	movs	r3, r6
    54c8:	e6b0      	b.n	522c <__aeabi_fsub+0x8c>
    54ca:	2301      	movs	r3, #1
    54cc:	e7c0      	b.n	5450 <__aeabi_fsub+0x2b0>
    54ce:	46c0      	nop			; (mov r8, r8)
    54d0:	7dffffff 	.word	0x7dffffff
    54d4:	fbffffff 	.word	0xfbffffff

000054d8 <__aeabi_f2iz>:
    54d8:	0241      	lsls	r1, r0, #9
    54da:	0043      	lsls	r3, r0, #1
    54dc:	0fc2      	lsrs	r2, r0, #31
    54de:	0a49      	lsrs	r1, r1, #9
    54e0:	0e1b      	lsrs	r3, r3, #24
    54e2:	2000      	movs	r0, #0
    54e4:	2b7e      	cmp	r3, #126	; 0x7e
    54e6:	dd0d      	ble.n	5504 <__aeabi_f2iz+0x2c>
    54e8:	2b9d      	cmp	r3, #157	; 0x9d
    54ea:	dc0c      	bgt.n	5506 <__aeabi_f2iz+0x2e>
    54ec:	2080      	movs	r0, #128	; 0x80
    54ee:	0400      	lsls	r0, r0, #16
    54f0:	4301      	orrs	r1, r0
    54f2:	2b95      	cmp	r3, #149	; 0x95
    54f4:	dc0a      	bgt.n	550c <__aeabi_f2iz+0x34>
    54f6:	2096      	movs	r0, #150	; 0x96
    54f8:	1ac3      	subs	r3, r0, r3
    54fa:	40d9      	lsrs	r1, r3
    54fc:	4248      	negs	r0, r1
    54fe:	2a00      	cmp	r2, #0
    5500:	d100      	bne.n	5504 <__aeabi_f2iz+0x2c>
    5502:	0008      	movs	r0, r1
    5504:	4770      	bx	lr
    5506:	4b03      	ldr	r3, [pc, #12]	; (5514 <__aeabi_f2iz+0x3c>)
    5508:	18d0      	adds	r0, r2, r3
    550a:	e7fb      	b.n	5504 <__aeabi_f2iz+0x2c>
    550c:	3b96      	subs	r3, #150	; 0x96
    550e:	4099      	lsls	r1, r3
    5510:	e7f4      	b.n	54fc <__aeabi_f2iz+0x24>
    5512:	46c0      	nop			; (mov r8, r8)
    5514:	7fffffff 	.word	0x7fffffff

00005518 <__aeabi_i2f>:
    5518:	b570      	push	{r4, r5, r6, lr}
    551a:	2800      	cmp	r0, #0
    551c:	d030      	beq.n	5580 <__aeabi_i2f+0x68>
    551e:	17c3      	asrs	r3, r0, #31
    5520:	18c4      	adds	r4, r0, r3
    5522:	405c      	eors	r4, r3
    5524:	0fc5      	lsrs	r5, r0, #31
    5526:	0020      	movs	r0, r4
    5528:	f000 fd16 	bl	5f58 <__clzsi2>
    552c:	239e      	movs	r3, #158	; 0x9e
    552e:	1a1b      	subs	r3, r3, r0
    5530:	2b96      	cmp	r3, #150	; 0x96
    5532:	dc0d      	bgt.n	5550 <__aeabi_i2f+0x38>
    5534:	2296      	movs	r2, #150	; 0x96
    5536:	1ad2      	subs	r2, r2, r3
    5538:	4094      	lsls	r4, r2
    553a:	002a      	movs	r2, r5
    553c:	0264      	lsls	r4, r4, #9
    553e:	0a64      	lsrs	r4, r4, #9
    5540:	b2db      	uxtb	r3, r3
    5542:	0264      	lsls	r4, r4, #9
    5544:	05db      	lsls	r3, r3, #23
    5546:	0a60      	lsrs	r0, r4, #9
    5548:	07d2      	lsls	r2, r2, #31
    554a:	4318      	orrs	r0, r3
    554c:	4310      	orrs	r0, r2
    554e:	bd70      	pop	{r4, r5, r6, pc}
    5550:	2b99      	cmp	r3, #153	; 0x99
    5552:	dc19      	bgt.n	5588 <__aeabi_i2f+0x70>
    5554:	2299      	movs	r2, #153	; 0x99
    5556:	1ad2      	subs	r2, r2, r3
    5558:	2a00      	cmp	r2, #0
    555a:	dd29      	ble.n	55b0 <__aeabi_i2f+0x98>
    555c:	4094      	lsls	r4, r2
    555e:	0022      	movs	r2, r4
    5560:	4c14      	ldr	r4, [pc, #80]	; (55b4 <__aeabi_i2f+0x9c>)
    5562:	4014      	ands	r4, r2
    5564:	0751      	lsls	r1, r2, #29
    5566:	d004      	beq.n	5572 <__aeabi_i2f+0x5a>
    5568:	210f      	movs	r1, #15
    556a:	400a      	ands	r2, r1
    556c:	2a04      	cmp	r2, #4
    556e:	d000      	beq.n	5572 <__aeabi_i2f+0x5a>
    5570:	3404      	adds	r4, #4
    5572:	0162      	lsls	r2, r4, #5
    5574:	d413      	bmi.n	559e <__aeabi_i2f+0x86>
    5576:	01a4      	lsls	r4, r4, #6
    5578:	0a64      	lsrs	r4, r4, #9
    557a:	b2db      	uxtb	r3, r3
    557c:	002a      	movs	r2, r5
    557e:	e7e0      	b.n	5542 <__aeabi_i2f+0x2a>
    5580:	2200      	movs	r2, #0
    5582:	2300      	movs	r3, #0
    5584:	2400      	movs	r4, #0
    5586:	e7dc      	b.n	5542 <__aeabi_i2f+0x2a>
    5588:	2205      	movs	r2, #5
    558a:	0021      	movs	r1, r4
    558c:	1a12      	subs	r2, r2, r0
    558e:	40d1      	lsrs	r1, r2
    5590:	22b9      	movs	r2, #185	; 0xb9
    5592:	1ad2      	subs	r2, r2, r3
    5594:	4094      	lsls	r4, r2
    5596:	1e62      	subs	r2, r4, #1
    5598:	4194      	sbcs	r4, r2
    559a:	430c      	orrs	r4, r1
    559c:	e7da      	b.n	5554 <__aeabi_i2f+0x3c>
    559e:	4b05      	ldr	r3, [pc, #20]	; (55b4 <__aeabi_i2f+0x9c>)
    55a0:	002a      	movs	r2, r5
    55a2:	401c      	ands	r4, r3
    55a4:	239f      	movs	r3, #159	; 0x9f
    55a6:	01a4      	lsls	r4, r4, #6
    55a8:	1a1b      	subs	r3, r3, r0
    55aa:	0a64      	lsrs	r4, r4, #9
    55ac:	b2db      	uxtb	r3, r3
    55ae:	e7c8      	b.n	5542 <__aeabi_i2f+0x2a>
    55b0:	0022      	movs	r2, r4
    55b2:	e7d5      	b.n	5560 <__aeabi_i2f+0x48>
    55b4:	fbffffff 	.word	0xfbffffff

000055b8 <__aeabi_dadd>:
    55b8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    55ba:	4645      	mov	r5, r8
    55bc:	46de      	mov	lr, fp
    55be:	4657      	mov	r7, sl
    55c0:	464e      	mov	r6, r9
    55c2:	030c      	lsls	r4, r1, #12
    55c4:	b5e0      	push	{r5, r6, r7, lr}
    55c6:	004e      	lsls	r6, r1, #1
    55c8:	0fc9      	lsrs	r1, r1, #31
    55ca:	4688      	mov	r8, r1
    55cc:	000d      	movs	r5, r1
    55ce:	0a61      	lsrs	r1, r4, #9
    55d0:	0f44      	lsrs	r4, r0, #29
    55d2:	430c      	orrs	r4, r1
    55d4:	00c7      	lsls	r7, r0, #3
    55d6:	0319      	lsls	r1, r3, #12
    55d8:	0058      	lsls	r0, r3, #1
    55da:	0fdb      	lsrs	r3, r3, #31
    55dc:	469b      	mov	fp, r3
    55de:	0a4b      	lsrs	r3, r1, #9
    55e0:	0f51      	lsrs	r1, r2, #29
    55e2:	430b      	orrs	r3, r1
    55e4:	0d76      	lsrs	r6, r6, #21
    55e6:	0d40      	lsrs	r0, r0, #21
    55e8:	0019      	movs	r1, r3
    55ea:	00d2      	lsls	r2, r2, #3
    55ec:	45d8      	cmp	r8, fp
    55ee:	d100      	bne.n	55f2 <__aeabi_dadd+0x3a>
    55f0:	e0ae      	b.n	5750 <__aeabi_dadd+0x198>
    55f2:	1a35      	subs	r5, r6, r0
    55f4:	2d00      	cmp	r5, #0
    55f6:	dc00      	bgt.n	55fa <__aeabi_dadd+0x42>
    55f8:	e0f6      	b.n	57e8 <__aeabi_dadd+0x230>
    55fa:	2800      	cmp	r0, #0
    55fc:	d10f      	bne.n	561e <__aeabi_dadd+0x66>
    55fe:	4313      	orrs	r3, r2
    5600:	d100      	bne.n	5604 <__aeabi_dadd+0x4c>
    5602:	e0db      	b.n	57bc <__aeabi_dadd+0x204>
    5604:	1e6b      	subs	r3, r5, #1
    5606:	2b00      	cmp	r3, #0
    5608:	d000      	beq.n	560c <__aeabi_dadd+0x54>
    560a:	e137      	b.n	587c <__aeabi_dadd+0x2c4>
    560c:	1aba      	subs	r2, r7, r2
    560e:	4297      	cmp	r7, r2
    5610:	41bf      	sbcs	r7, r7
    5612:	1a64      	subs	r4, r4, r1
    5614:	427f      	negs	r7, r7
    5616:	1be4      	subs	r4, r4, r7
    5618:	2601      	movs	r6, #1
    561a:	0017      	movs	r7, r2
    561c:	e024      	b.n	5668 <__aeabi_dadd+0xb0>
    561e:	4bc6      	ldr	r3, [pc, #792]	; (5938 <__aeabi_dadd+0x380>)
    5620:	429e      	cmp	r6, r3
    5622:	d04d      	beq.n	56c0 <__aeabi_dadd+0x108>
    5624:	2380      	movs	r3, #128	; 0x80
    5626:	041b      	lsls	r3, r3, #16
    5628:	4319      	orrs	r1, r3
    562a:	2d38      	cmp	r5, #56	; 0x38
    562c:	dd00      	ble.n	5630 <__aeabi_dadd+0x78>
    562e:	e107      	b.n	5840 <__aeabi_dadd+0x288>
    5630:	2d1f      	cmp	r5, #31
    5632:	dd00      	ble.n	5636 <__aeabi_dadd+0x7e>
    5634:	e138      	b.n	58a8 <__aeabi_dadd+0x2f0>
    5636:	2020      	movs	r0, #32
    5638:	1b43      	subs	r3, r0, r5
    563a:	469a      	mov	sl, r3
    563c:	000b      	movs	r3, r1
    563e:	4650      	mov	r0, sl
    5640:	4083      	lsls	r3, r0
    5642:	4699      	mov	r9, r3
    5644:	0013      	movs	r3, r2
    5646:	4648      	mov	r0, r9
    5648:	40eb      	lsrs	r3, r5
    564a:	4318      	orrs	r0, r3
    564c:	0003      	movs	r3, r0
    564e:	4650      	mov	r0, sl
    5650:	4082      	lsls	r2, r0
    5652:	1e50      	subs	r0, r2, #1
    5654:	4182      	sbcs	r2, r0
    5656:	40e9      	lsrs	r1, r5
    5658:	431a      	orrs	r2, r3
    565a:	1aba      	subs	r2, r7, r2
    565c:	1a61      	subs	r1, r4, r1
    565e:	4297      	cmp	r7, r2
    5660:	41a4      	sbcs	r4, r4
    5662:	0017      	movs	r7, r2
    5664:	4264      	negs	r4, r4
    5666:	1b0c      	subs	r4, r1, r4
    5668:	0223      	lsls	r3, r4, #8
    566a:	d562      	bpl.n	5732 <__aeabi_dadd+0x17a>
    566c:	0264      	lsls	r4, r4, #9
    566e:	0a65      	lsrs	r5, r4, #9
    5670:	2d00      	cmp	r5, #0
    5672:	d100      	bne.n	5676 <__aeabi_dadd+0xbe>
    5674:	e0df      	b.n	5836 <__aeabi_dadd+0x27e>
    5676:	0028      	movs	r0, r5
    5678:	f000 fc6e 	bl	5f58 <__clzsi2>
    567c:	0003      	movs	r3, r0
    567e:	3b08      	subs	r3, #8
    5680:	2b1f      	cmp	r3, #31
    5682:	dd00      	ble.n	5686 <__aeabi_dadd+0xce>
    5684:	e0d2      	b.n	582c <__aeabi_dadd+0x274>
    5686:	2220      	movs	r2, #32
    5688:	003c      	movs	r4, r7
    568a:	1ad2      	subs	r2, r2, r3
    568c:	409d      	lsls	r5, r3
    568e:	40d4      	lsrs	r4, r2
    5690:	409f      	lsls	r7, r3
    5692:	4325      	orrs	r5, r4
    5694:	429e      	cmp	r6, r3
    5696:	dd00      	ble.n	569a <__aeabi_dadd+0xe2>
    5698:	e0c4      	b.n	5824 <__aeabi_dadd+0x26c>
    569a:	1b9e      	subs	r6, r3, r6
    569c:	1c73      	adds	r3, r6, #1
    569e:	2b1f      	cmp	r3, #31
    56a0:	dd00      	ble.n	56a4 <__aeabi_dadd+0xec>
    56a2:	e0f1      	b.n	5888 <__aeabi_dadd+0x2d0>
    56a4:	2220      	movs	r2, #32
    56a6:	0038      	movs	r0, r7
    56a8:	0029      	movs	r1, r5
    56aa:	1ad2      	subs	r2, r2, r3
    56ac:	40d8      	lsrs	r0, r3
    56ae:	4091      	lsls	r1, r2
    56b0:	4097      	lsls	r7, r2
    56b2:	002c      	movs	r4, r5
    56b4:	4301      	orrs	r1, r0
    56b6:	1e78      	subs	r0, r7, #1
    56b8:	4187      	sbcs	r7, r0
    56ba:	40dc      	lsrs	r4, r3
    56bc:	2600      	movs	r6, #0
    56be:	430f      	orrs	r7, r1
    56c0:	077b      	lsls	r3, r7, #29
    56c2:	d009      	beq.n	56d8 <__aeabi_dadd+0x120>
    56c4:	230f      	movs	r3, #15
    56c6:	403b      	ands	r3, r7
    56c8:	2b04      	cmp	r3, #4
    56ca:	d005      	beq.n	56d8 <__aeabi_dadd+0x120>
    56cc:	1d3b      	adds	r3, r7, #4
    56ce:	42bb      	cmp	r3, r7
    56d0:	41bf      	sbcs	r7, r7
    56d2:	427f      	negs	r7, r7
    56d4:	19e4      	adds	r4, r4, r7
    56d6:	001f      	movs	r7, r3
    56d8:	0223      	lsls	r3, r4, #8
    56da:	d52c      	bpl.n	5736 <__aeabi_dadd+0x17e>
    56dc:	4b96      	ldr	r3, [pc, #600]	; (5938 <__aeabi_dadd+0x380>)
    56de:	3601      	adds	r6, #1
    56e0:	429e      	cmp	r6, r3
    56e2:	d100      	bne.n	56e6 <__aeabi_dadd+0x12e>
    56e4:	e09a      	b.n	581c <__aeabi_dadd+0x264>
    56e6:	4645      	mov	r5, r8
    56e8:	4b94      	ldr	r3, [pc, #592]	; (593c <__aeabi_dadd+0x384>)
    56ea:	08ff      	lsrs	r7, r7, #3
    56ec:	401c      	ands	r4, r3
    56ee:	0760      	lsls	r0, r4, #29
    56f0:	0576      	lsls	r6, r6, #21
    56f2:	0264      	lsls	r4, r4, #9
    56f4:	4307      	orrs	r7, r0
    56f6:	0b24      	lsrs	r4, r4, #12
    56f8:	0d76      	lsrs	r6, r6, #21
    56fa:	2100      	movs	r1, #0
    56fc:	0324      	lsls	r4, r4, #12
    56fe:	0b23      	lsrs	r3, r4, #12
    5700:	0d0c      	lsrs	r4, r1, #20
    5702:	4a8f      	ldr	r2, [pc, #572]	; (5940 <__aeabi_dadd+0x388>)
    5704:	0524      	lsls	r4, r4, #20
    5706:	431c      	orrs	r4, r3
    5708:	4014      	ands	r4, r2
    570a:	0533      	lsls	r3, r6, #20
    570c:	4323      	orrs	r3, r4
    570e:	005b      	lsls	r3, r3, #1
    5710:	07ed      	lsls	r5, r5, #31
    5712:	085b      	lsrs	r3, r3, #1
    5714:	432b      	orrs	r3, r5
    5716:	0038      	movs	r0, r7
    5718:	0019      	movs	r1, r3
    571a:	bc3c      	pop	{r2, r3, r4, r5}
    571c:	4690      	mov	r8, r2
    571e:	4699      	mov	r9, r3
    5720:	46a2      	mov	sl, r4
    5722:	46ab      	mov	fp, r5
    5724:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    5726:	4664      	mov	r4, ip
    5728:	4304      	orrs	r4, r0
    572a:	d100      	bne.n	572e <__aeabi_dadd+0x176>
    572c:	e211      	b.n	5b52 <__aeabi_dadd+0x59a>
    572e:	0004      	movs	r4, r0
    5730:	4667      	mov	r7, ip
    5732:	077b      	lsls	r3, r7, #29
    5734:	d1c6      	bne.n	56c4 <__aeabi_dadd+0x10c>
    5736:	4645      	mov	r5, r8
    5738:	0760      	lsls	r0, r4, #29
    573a:	08ff      	lsrs	r7, r7, #3
    573c:	4307      	orrs	r7, r0
    573e:	08e4      	lsrs	r4, r4, #3
    5740:	4b7d      	ldr	r3, [pc, #500]	; (5938 <__aeabi_dadd+0x380>)
    5742:	429e      	cmp	r6, r3
    5744:	d030      	beq.n	57a8 <__aeabi_dadd+0x1f0>
    5746:	0324      	lsls	r4, r4, #12
    5748:	0576      	lsls	r6, r6, #21
    574a:	0b24      	lsrs	r4, r4, #12
    574c:	0d76      	lsrs	r6, r6, #21
    574e:	e7d4      	b.n	56fa <__aeabi_dadd+0x142>
    5750:	1a33      	subs	r3, r6, r0
    5752:	469a      	mov	sl, r3
    5754:	2b00      	cmp	r3, #0
    5756:	dd78      	ble.n	584a <__aeabi_dadd+0x292>
    5758:	2800      	cmp	r0, #0
    575a:	d031      	beq.n	57c0 <__aeabi_dadd+0x208>
    575c:	4876      	ldr	r0, [pc, #472]	; (5938 <__aeabi_dadd+0x380>)
    575e:	4286      	cmp	r6, r0
    5760:	d0ae      	beq.n	56c0 <__aeabi_dadd+0x108>
    5762:	2080      	movs	r0, #128	; 0x80
    5764:	0400      	lsls	r0, r0, #16
    5766:	4301      	orrs	r1, r0
    5768:	4653      	mov	r3, sl
    576a:	2b38      	cmp	r3, #56	; 0x38
    576c:	dc00      	bgt.n	5770 <__aeabi_dadd+0x1b8>
    576e:	e0e9      	b.n	5944 <__aeabi_dadd+0x38c>
    5770:	430a      	orrs	r2, r1
    5772:	1e51      	subs	r1, r2, #1
    5774:	418a      	sbcs	r2, r1
    5776:	2100      	movs	r1, #0
    5778:	19d2      	adds	r2, r2, r7
    577a:	42ba      	cmp	r2, r7
    577c:	41bf      	sbcs	r7, r7
    577e:	1909      	adds	r1, r1, r4
    5780:	427c      	negs	r4, r7
    5782:	0017      	movs	r7, r2
    5784:	190c      	adds	r4, r1, r4
    5786:	0223      	lsls	r3, r4, #8
    5788:	d5d3      	bpl.n	5732 <__aeabi_dadd+0x17a>
    578a:	4b6b      	ldr	r3, [pc, #428]	; (5938 <__aeabi_dadd+0x380>)
    578c:	3601      	adds	r6, #1
    578e:	429e      	cmp	r6, r3
    5790:	d100      	bne.n	5794 <__aeabi_dadd+0x1dc>
    5792:	e13a      	b.n	5a0a <__aeabi_dadd+0x452>
    5794:	2001      	movs	r0, #1
    5796:	4b69      	ldr	r3, [pc, #420]	; (593c <__aeabi_dadd+0x384>)
    5798:	401c      	ands	r4, r3
    579a:	087b      	lsrs	r3, r7, #1
    579c:	4007      	ands	r7, r0
    579e:	431f      	orrs	r7, r3
    57a0:	07e0      	lsls	r0, r4, #31
    57a2:	4307      	orrs	r7, r0
    57a4:	0864      	lsrs	r4, r4, #1
    57a6:	e78b      	b.n	56c0 <__aeabi_dadd+0x108>
    57a8:	0023      	movs	r3, r4
    57aa:	433b      	orrs	r3, r7
    57ac:	d100      	bne.n	57b0 <__aeabi_dadd+0x1f8>
    57ae:	e1cb      	b.n	5b48 <__aeabi_dadd+0x590>
    57b0:	2280      	movs	r2, #128	; 0x80
    57b2:	0312      	lsls	r2, r2, #12
    57b4:	4314      	orrs	r4, r2
    57b6:	0324      	lsls	r4, r4, #12
    57b8:	0b24      	lsrs	r4, r4, #12
    57ba:	e79e      	b.n	56fa <__aeabi_dadd+0x142>
    57bc:	002e      	movs	r6, r5
    57be:	e77f      	b.n	56c0 <__aeabi_dadd+0x108>
    57c0:	0008      	movs	r0, r1
    57c2:	4310      	orrs	r0, r2
    57c4:	d100      	bne.n	57c8 <__aeabi_dadd+0x210>
    57c6:	e0b4      	b.n	5932 <__aeabi_dadd+0x37a>
    57c8:	1e58      	subs	r0, r3, #1
    57ca:	2800      	cmp	r0, #0
    57cc:	d000      	beq.n	57d0 <__aeabi_dadd+0x218>
    57ce:	e0de      	b.n	598e <__aeabi_dadd+0x3d6>
    57d0:	18ba      	adds	r2, r7, r2
    57d2:	42ba      	cmp	r2, r7
    57d4:	419b      	sbcs	r3, r3
    57d6:	1864      	adds	r4, r4, r1
    57d8:	425b      	negs	r3, r3
    57da:	18e4      	adds	r4, r4, r3
    57dc:	0017      	movs	r7, r2
    57de:	2601      	movs	r6, #1
    57e0:	0223      	lsls	r3, r4, #8
    57e2:	d5a6      	bpl.n	5732 <__aeabi_dadd+0x17a>
    57e4:	2602      	movs	r6, #2
    57e6:	e7d5      	b.n	5794 <__aeabi_dadd+0x1dc>
    57e8:	2d00      	cmp	r5, #0
    57ea:	d16e      	bne.n	58ca <__aeabi_dadd+0x312>
    57ec:	1c70      	adds	r0, r6, #1
    57ee:	0540      	lsls	r0, r0, #21
    57f0:	0d40      	lsrs	r0, r0, #21
    57f2:	2801      	cmp	r0, #1
    57f4:	dc00      	bgt.n	57f8 <__aeabi_dadd+0x240>
    57f6:	e0f9      	b.n	59ec <__aeabi_dadd+0x434>
    57f8:	1ab8      	subs	r0, r7, r2
    57fa:	4684      	mov	ip, r0
    57fc:	4287      	cmp	r7, r0
    57fe:	4180      	sbcs	r0, r0
    5800:	1ae5      	subs	r5, r4, r3
    5802:	4240      	negs	r0, r0
    5804:	1a2d      	subs	r5, r5, r0
    5806:	0228      	lsls	r0, r5, #8
    5808:	d400      	bmi.n	580c <__aeabi_dadd+0x254>
    580a:	e089      	b.n	5920 <__aeabi_dadd+0x368>
    580c:	1bd7      	subs	r7, r2, r7
    580e:	42ba      	cmp	r2, r7
    5810:	4192      	sbcs	r2, r2
    5812:	1b1c      	subs	r4, r3, r4
    5814:	4252      	negs	r2, r2
    5816:	1aa5      	subs	r5, r4, r2
    5818:	46d8      	mov	r8, fp
    581a:	e729      	b.n	5670 <__aeabi_dadd+0xb8>
    581c:	4645      	mov	r5, r8
    581e:	2400      	movs	r4, #0
    5820:	2700      	movs	r7, #0
    5822:	e76a      	b.n	56fa <__aeabi_dadd+0x142>
    5824:	4c45      	ldr	r4, [pc, #276]	; (593c <__aeabi_dadd+0x384>)
    5826:	1af6      	subs	r6, r6, r3
    5828:	402c      	ands	r4, r5
    582a:	e749      	b.n	56c0 <__aeabi_dadd+0x108>
    582c:	003d      	movs	r5, r7
    582e:	3828      	subs	r0, #40	; 0x28
    5830:	4085      	lsls	r5, r0
    5832:	2700      	movs	r7, #0
    5834:	e72e      	b.n	5694 <__aeabi_dadd+0xdc>
    5836:	0038      	movs	r0, r7
    5838:	f000 fb8e 	bl	5f58 <__clzsi2>
    583c:	3020      	adds	r0, #32
    583e:	e71d      	b.n	567c <__aeabi_dadd+0xc4>
    5840:	430a      	orrs	r2, r1
    5842:	1e51      	subs	r1, r2, #1
    5844:	418a      	sbcs	r2, r1
    5846:	2100      	movs	r1, #0
    5848:	e707      	b.n	565a <__aeabi_dadd+0xa2>
    584a:	2b00      	cmp	r3, #0
    584c:	d000      	beq.n	5850 <__aeabi_dadd+0x298>
    584e:	e0f3      	b.n	5a38 <__aeabi_dadd+0x480>
    5850:	1c70      	adds	r0, r6, #1
    5852:	0543      	lsls	r3, r0, #21
    5854:	0d5b      	lsrs	r3, r3, #21
    5856:	2b01      	cmp	r3, #1
    5858:	dc00      	bgt.n	585c <__aeabi_dadd+0x2a4>
    585a:	e0ad      	b.n	59b8 <__aeabi_dadd+0x400>
    585c:	4b36      	ldr	r3, [pc, #216]	; (5938 <__aeabi_dadd+0x380>)
    585e:	4298      	cmp	r0, r3
    5860:	d100      	bne.n	5864 <__aeabi_dadd+0x2ac>
    5862:	e0d1      	b.n	5a08 <__aeabi_dadd+0x450>
    5864:	18ba      	adds	r2, r7, r2
    5866:	42ba      	cmp	r2, r7
    5868:	41bf      	sbcs	r7, r7
    586a:	1864      	adds	r4, r4, r1
    586c:	427f      	negs	r7, r7
    586e:	19e4      	adds	r4, r4, r7
    5870:	07e7      	lsls	r7, r4, #31
    5872:	0852      	lsrs	r2, r2, #1
    5874:	4317      	orrs	r7, r2
    5876:	0864      	lsrs	r4, r4, #1
    5878:	0006      	movs	r6, r0
    587a:	e721      	b.n	56c0 <__aeabi_dadd+0x108>
    587c:	482e      	ldr	r0, [pc, #184]	; (5938 <__aeabi_dadd+0x380>)
    587e:	4285      	cmp	r5, r0
    5880:	d100      	bne.n	5884 <__aeabi_dadd+0x2cc>
    5882:	e093      	b.n	59ac <__aeabi_dadd+0x3f4>
    5884:	001d      	movs	r5, r3
    5886:	e6d0      	b.n	562a <__aeabi_dadd+0x72>
    5888:	0029      	movs	r1, r5
    588a:	3e1f      	subs	r6, #31
    588c:	40f1      	lsrs	r1, r6
    588e:	2b20      	cmp	r3, #32
    5890:	d100      	bne.n	5894 <__aeabi_dadd+0x2dc>
    5892:	e08d      	b.n	59b0 <__aeabi_dadd+0x3f8>
    5894:	2240      	movs	r2, #64	; 0x40
    5896:	1ad3      	subs	r3, r2, r3
    5898:	409d      	lsls	r5, r3
    589a:	432f      	orrs	r7, r5
    589c:	1e7d      	subs	r5, r7, #1
    589e:	41af      	sbcs	r7, r5
    58a0:	2400      	movs	r4, #0
    58a2:	430f      	orrs	r7, r1
    58a4:	2600      	movs	r6, #0
    58a6:	e744      	b.n	5732 <__aeabi_dadd+0x17a>
    58a8:	002b      	movs	r3, r5
    58aa:	0008      	movs	r0, r1
    58ac:	3b20      	subs	r3, #32
    58ae:	40d8      	lsrs	r0, r3
    58b0:	0003      	movs	r3, r0
    58b2:	2d20      	cmp	r5, #32
    58b4:	d100      	bne.n	58b8 <__aeabi_dadd+0x300>
    58b6:	e07d      	b.n	59b4 <__aeabi_dadd+0x3fc>
    58b8:	2040      	movs	r0, #64	; 0x40
    58ba:	1b45      	subs	r5, r0, r5
    58bc:	40a9      	lsls	r1, r5
    58be:	430a      	orrs	r2, r1
    58c0:	1e51      	subs	r1, r2, #1
    58c2:	418a      	sbcs	r2, r1
    58c4:	2100      	movs	r1, #0
    58c6:	431a      	orrs	r2, r3
    58c8:	e6c7      	b.n	565a <__aeabi_dadd+0xa2>
    58ca:	2e00      	cmp	r6, #0
    58cc:	d050      	beq.n	5970 <__aeabi_dadd+0x3b8>
    58ce:	4e1a      	ldr	r6, [pc, #104]	; (5938 <__aeabi_dadd+0x380>)
    58d0:	42b0      	cmp	r0, r6
    58d2:	d057      	beq.n	5984 <__aeabi_dadd+0x3cc>
    58d4:	2680      	movs	r6, #128	; 0x80
    58d6:	426b      	negs	r3, r5
    58d8:	4699      	mov	r9, r3
    58da:	0436      	lsls	r6, r6, #16
    58dc:	4334      	orrs	r4, r6
    58de:	464b      	mov	r3, r9
    58e0:	2b38      	cmp	r3, #56	; 0x38
    58e2:	dd00      	ble.n	58e6 <__aeabi_dadd+0x32e>
    58e4:	e0d6      	b.n	5a94 <__aeabi_dadd+0x4dc>
    58e6:	2b1f      	cmp	r3, #31
    58e8:	dd00      	ble.n	58ec <__aeabi_dadd+0x334>
    58ea:	e135      	b.n	5b58 <__aeabi_dadd+0x5a0>
    58ec:	2620      	movs	r6, #32
    58ee:	1af5      	subs	r5, r6, r3
    58f0:	0026      	movs	r6, r4
    58f2:	40ae      	lsls	r6, r5
    58f4:	46b2      	mov	sl, r6
    58f6:	003e      	movs	r6, r7
    58f8:	40de      	lsrs	r6, r3
    58fa:	46ac      	mov	ip, r5
    58fc:	0035      	movs	r5, r6
    58fe:	4656      	mov	r6, sl
    5900:	432e      	orrs	r6, r5
    5902:	4665      	mov	r5, ip
    5904:	40af      	lsls	r7, r5
    5906:	1e7d      	subs	r5, r7, #1
    5908:	41af      	sbcs	r7, r5
    590a:	40dc      	lsrs	r4, r3
    590c:	4337      	orrs	r7, r6
    590e:	1bd7      	subs	r7, r2, r7
    5910:	42ba      	cmp	r2, r7
    5912:	4192      	sbcs	r2, r2
    5914:	1b0c      	subs	r4, r1, r4
    5916:	4252      	negs	r2, r2
    5918:	1aa4      	subs	r4, r4, r2
    591a:	0006      	movs	r6, r0
    591c:	46d8      	mov	r8, fp
    591e:	e6a3      	b.n	5668 <__aeabi_dadd+0xb0>
    5920:	4664      	mov	r4, ip
    5922:	4667      	mov	r7, ip
    5924:	432c      	orrs	r4, r5
    5926:	d000      	beq.n	592a <__aeabi_dadd+0x372>
    5928:	e6a2      	b.n	5670 <__aeabi_dadd+0xb8>
    592a:	2500      	movs	r5, #0
    592c:	2600      	movs	r6, #0
    592e:	2700      	movs	r7, #0
    5930:	e706      	b.n	5740 <__aeabi_dadd+0x188>
    5932:	001e      	movs	r6, r3
    5934:	e6c4      	b.n	56c0 <__aeabi_dadd+0x108>
    5936:	46c0      	nop			; (mov r8, r8)
    5938:	000007ff 	.word	0x000007ff
    593c:	ff7fffff 	.word	0xff7fffff
    5940:	800fffff 	.word	0x800fffff
    5944:	2b1f      	cmp	r3, #31
    5946:	dc63      	bgt.n	5a10 <__aeabi_dadd+0x458>
    5948:	2020      	movs	r0, #32
    594a:	1ac3      	subs	r3, r0, r3
    594c:	0008      	movs	r0, r1
    594e:	4098      	lsls	r0, r3
    5950:	469c      	mov	ip, r3
    5952:	4683      	mov	fp, r0
    5954:	4653      	mov	r3, sl
    5956:	0010      	movs	r0, r2
    5958:	40d8      	lsrs	r0, r3
    595a:	0003      	movs	r3, r0
    595c:	4658      	mov	r0, fp
    595e:	4318      	orrs	r0, r3
    5960:	4663      	mov	r3, ip
    5962:	409a      	lsls	r2, r3
    5964:	1e53      	subs	r3, r2, #1
    5966:	419a      	sbcs	r2, r3
    5968:	4653      	mov	r3, sl
    596a:	4302      	orrs	r2, r0
    596c:	40d9      	lsrs	r1, r3
    596e:	e703      	b.n	5778 <__aeabi_dadd+0x1c0>
    5970:	0026      	movs	r6, r4
    5972:	433e      	orrs	r6, r7
    5974:	d006      	beq.n	5984 <__aeabi_dadd+0x3cc>
    5976:	43eb      	mvns	r3, r5
    5978:	4699      	mov	r9, r3
    597a:	2b00      	cmp	r3, #0
    597c:	d0c7      	beq.n	590e <__aeabi_dadd+0x356>
    597e:	4e94      	ldr	r6, [pc, #592]	; (5bd0 <__aeabi_dadd+0x618>)
    5980:	42b0      	cmp	r0, r6
    5982:	d1ac      	bne.n	58de <__aeabi_dadd+0x326>
    5984:	000c      	movs	r4, r1
    5986:	0017      	movs	r7, r2
    5988:	0006      	movs	r6, r0
    598a:	46d8      	mov	r8, fp
    598c:	e698      	b.n	56c0 <__aeabi_dadd+0x108>
    598e:	4b90      	ldr	r3, [pc, #576]	; (5bd0 <__aeabi_dadd+0x618>)
    5990:	459a      	cmp	sl, r3
    5992:	d00b      	beq.n	59ac <__aeabi_dadd+0x3f4>
    5994:	4682      	mov	sl, r0
    5996:	e6e7      	b.n	5768 <__aeabi_dadd+0x1b0>
    5998:	2800      	cmp	r0, #0
    599a:	d000      	beq.n	599e <__aeabi_dadd+0x3e6>
    599c:	e09e      	b.n	5adc <__aeabi_dadd+0x524>
    599e:	0018      	movs	r0, r3
    59a0:	4310      	orrs	r0, r2
    59a2:	d100      	bne.n	59a6 <__aeabi_dadd+0x3ee>
    59a4:	e0e9      	b.n	5b7a <__aeabi_dadd+0x5c2>
    59a6:	001c      	movs	r4, r3
    59a8:	0017      	movs	r7, r2
    59aa:	46d8      	mov	r8, fp
    59ac:	4e88      	ldr	r6, [pc, #544]	; (5bd0 <__aeabi_dadd+0x618>)
    59ae:	e687      	b.n	56c0 <__aeabi_dadd+0x108>
    59b0:	2500      	movs	r5, #0
    59b2:	e772      	b.n	589a <__aeabi_dadd+0x2e2>
    59b4:	2100      	movs	r1, #0
    59b6:	e782      	b.n	58be <__aeabi_dadd+0x306>
    59b8:	0023      	movs	r3, r4
    59ba:	433b      	orrs	r3, r7
    59bc:	2e00      	cmp	r6, #0
    59be:	d000      	beq.n	59c2 <__aeabi_dadd+0x40a>
    59c0:	e0ab      	b.n	5b1a <__aeabi_dadd+0x562>
    59c2:	2b00      	cmp	r3, #0
    59c4:	d100      	bne.n	59c8 <__aeabi_dadd+0x410>
    59c6:	e0e7      	b.n	5b98 <__aeabi_dadd+0x5e0>
    59c8:	000b      	movs	r3, r1
    59ca:	4313      	orrs	r3, r2
    59cc:	d100      	bne.n	59d0 <__aeabi_dadd+0x418>
    59ce:	e677      	b.n	56c0 <__aeabi_dadd+0x108>
    59d0:	18ba      	adds	r2, r7, r2
    59d2:	42ba      	cmp	r2, r7
    59d4:	41bf      	sbcs	r7, r7
    59d6:	1864      	adds	r4, r4, r1
    59d8:	427f      	negs	r7, r7
    59da:	19e4      	adds	r4, r4, r7
    59dc:	0223      	lsls	r3, r4, #8
    59de:	d400      	bmi.n	59e2 <__aeabi_dadd+0x42a>
    59e0:	e0f2      	b.n	5bc8 <__aeabi_dadd+0x610>
    59e2:	4b7c      	ldr	r3, [pc, #496]	; (5bd4 <__aeabi_dadd+0x61c>)
    59e4:	0017      	movs	r7, r2
    59e6:	401c      	ands	r4, r3
    59e8:	0006      	movs	r6, r0
    59ea:	e669      	b.n	56c0 <__aeabi_dadd+0x108>
    59ec:	0020      	movs	r0, r4
    59ee:	4338      	orrs	r0, r7
    59f0:	2e00      	cmp	r6, #0
    59f2:	d1d1      	bne.n	5998 <__aeabi_dadd+0x3e0>
    59f4:	2800      	cmp	r0, #0
    59f6:	d15b      	bne.n	5ab0 <__aeabi_dadd+0x4f8>
    59f8:	001c      	movs	r4, r3
    59fa:	4314      	orrs	r4, r2
    59fc:	d100      	bne.n	5a00 <__aeabi_dadd+0x448>
    59fe:	e0a8      	b.n	5b52 <__aeabi_dadd+0x59a>
    5a00:	001c      	movs	r4, r3
    5a02:	0017      	movs	r7, r2
    5a04:	46d8      	mov	r8, fp
    5a06:	e65b      	b.n	56c0 <__aeabi_dadd+0x108>
    5a08:	0006      	movs	r6, r0
    5a0a:	2400      	movs	r4, #0
    5a0c:	2700      	movs	r7, #0
    5a0e:	e697      	b.n	5740 <__aeabi_dadd+0x188>
    5a10:	4650      	mov	r0, sl
    5a12:	000b      	movs	r3, r1
    5a14:	3820      	subs	r0, #32
    5a16:	40c3      	lsrs	r3, r0
    5a18:	4699      	mov	r9, r3
    5a1a:	4653      	mov	r3, sl
    5a1c:	2b20      	cmp	r3, #32
    5a1e:	d100      	bne.n	5a22 <__aeabi_dadd+0x46a>
    5a20:	e095      	b.n	5b4e <__aeabi_dadd+0x596>
    5a22:	2340      	movs	r3, #64	; 0x40
    5a24:	4650      	mov	r0, sl
    5a26:	1a1b      	subs	r3, r3, r0
    5a28:	4099      	lsls	r1, r3
    5a2a:	430a      	orrs	r2, r1
    5a2c:	1e51      	subs	r1, r2, #1
    5a2e:	418a      	sbcs	r2, r1
    5a30:	464b      	mov	r3, r9
    5a32:	2100      	movs	r1, #0
    5a34:	431a      	orrs	r2, r3
    5a36:	e69f      	b.n	5778 <__aeabi_dadd+0x1c0>
    5a38:	2e00      	cmp	r6, #0
    5a3a:	d130      	bne.n	5a9e <__aeabi_dadd+0x4e6>
    5a3c:	0026      	movs	r6, r4
    5a3e:	433e      	orrs	r6, r7
    5a40:	d067      	beq.n	5b12 <__aeabi_dadd+0x55a>
    5a42:	43db      	mvns	r3, r3
    5a44:	469a      	mov	sl, r3
    5a46:	2b00      	cmp	r3, #0
    5a48:	d01c      	beq.n	5a84 <__aeabi_dadd+0x4cc>
    5a4a:	4e61      	ldr	r6, [pc, #388]	; (5bd0 <__aeabi_dadd+0x618>)
    5a4c:	42b0      	cmp	r0, r6
    5a4e:	d060      	beq.n	5b12 <__aeabi_dadd+0x55a>
    5a50:	4653      	mov	r3, sl
    5a52:	2b38      	cmp	r3, #56	; 0x38
    5a54:	dd00      	ble.n	5a58 <__aeabi_dadd+0x4a0>
    5a56:	e096      	b.n	5b86 <__aeabi_dadd+0x5ce>
    5a58:	2b1f      	cmp	r3, #31
    5a5a:	dd00      	ble.n	5a5e <__aeabi_dadd+0x4a6>
    5a5c:	e09f      	b.n	5b9e <__aeabi_dadd+0x5e6>
    5a5e:	2620      	movs	r6, #32
    5a60:	1af3      	subs	r3, r6, r3
    5a62:	0026      	movs	r6, r4
    5a64:	409e      	lsls	r6, r3
    5a66:	469c      	mov	ip, r3
    5a68:	46b3      	mov	fp, r6
    5a6a:	4653      	mov	r3, sl
    5a6c:	003e      	movs	r6, r7
    5a6e:	40de      	lsrs	r6, r3
    5a70:	0033      	movs	r3, r6
    5a72:	465e      	mov	r6, fp
    5a74:	431e      	orrs	r6, r3
    5a76:	4663      	mov	r3, ip
    5a78:	409f      	lsls	r7, r3
    5a7a:	1e7b      	subs	r3, r7, #1
    5a7c:	419f      	sbcs	r7, r3
    5a7e:	4653      	mov	r3, sl
    5a80:	40dc      	lsrs	r4, r3
    5a82:	4337      	orrs	r7, r6
    5a84:	18bf      	adds	r7, r7, r2
    5a86:	4297      	cmp	r7, r2
    5a88:	4192      	sbcs	r2, r2
    5a8a:	1864      	adds	r4, r4, r1
    5a8c:	4252      	negs	r2, r2
    5a8e:	18a4      	adds	r4, r4, r2
    5a90:	0006      	movs	r6, r0
    5a92:	e678      	b.n	5786 <__aeabi_dadd+0x1ce>
    5a94:	4327      	orrs	r7, r4
    5a96:	1e7c      	subs	r4, r7, #1
    5a98:	41a7      	sbcs	r7, r4
    5a9a:	2400      	movs	r4, #0
    5a9c:	e737      	b.n	590e <__aeabi_dadd+0x356>
    5a9e:	4e4c      	ldr	r6, [pc, #304]	; (5bd0 <__aeabi_dadd+0x618>)
    5aa0:	42b0      	cmp	r0, r6
    5aa2:	d036      	beq.n	5b12 <__aeabi_dadd+0x55a>
    5aa4:	2680      	movs	r6, #128	; 0x80
    5aa6:	425b      	negs	r3, r3
    5aa8:	0436      	lsls	r6, r6, #16
    5aaa:	469a      	mov	sl, r3
    5aac:	4334      	orrs	r4, r6
    5aae:	e7cf      	b.n	5a50 <__aeabi_dadd+0x498>
    5ab0:	0018      	movs	r0, r3
    5ab2:	4310      	orrs	r0, r2
    5ab4:	d100      	bne.n	5ab8 <__aeabi_dadd+0x500>
    5ab6:	e603      	b.n	56c0 <__aeabi_dadd+0x108>
    5ab8:	1ab8      	subs	r0, r7, r2
    5aba:	4684      	mov	ip, r0
    5abc:	4567      	cmp	r7, ip
    5abe:	41ad      	sbcs	r5, r5
    5ac0:	1ae0      	subs	r0, r4, r3
    5ac2:	426d      	negs	r5, r5
    5ac4:	1b40      	subs	r0, r0, r5
    5ac6:	0205      	lsls	r5, r0, #8
    5ac8:	d400      	bmi.n	5acc <__aeabi_dadd+0x514>
    5aca:	e62c      	b.n	5726 <__aeabi_dadd+0x16e>
    5acc:	1bd7      	subs	r7, r2, r7
    5ace:	42ba      	cmp	r2, r7
    5ad0:	4192      	sbcs	r2, r2
    5ad2:	1b1c      	subs	r4, r3, r4
    5ad4:	4252      	negs	r2, r2
    5ad6:	1aa4      	subs	r4, r4, r2
    5ad8:	46d8      	mov	r8, fp
    5ada:	e5f1      	b.n	56c0 <__aeabi_dadd+0x108>
    5adc:	0018      	movs	r0, r3
    5ade:	4310      	orrs	r0, r2
    5ae0:	d100      	bne.n	5ae4 <__aeabi_dadd+0x52c>
    5ae2:	e763      	b.n	59ac <__aeabi_dadd+0x3f4>
    5ae4:	08f8      	lsrs	r0, r7, #3
    5ae6:	0767      	lsls	r7, r4, #29
    5ae8:	4307      	orrs	r7, r0
    5aea:	2080      	movs	r0, #128	; 0x80
    5aec:	08e4      	lsrs	r4, r4, #3
    5aee:	0300      	lsls	r0, r0, #12
    5af0:	4204      	tst	r4, r0
    5af2:	d008      	beq.n	5b06 <__aeabi_dadd+0x54e>
    5af4:	08dd      	lsrs	r5, r3, #3
    5af6:	4205      	tst	r5, r0
    5af8:	d105      	bne.n	5b06 <__aeabi_dadd+0x54e>
    5afa:	08d2      	lsrs	r2, r2, #3
    5afc:	0759      	lsls	r1, r3, #29
    5afe:	4311      	orrs	r1, r2
    5b00:	000f      	movs	r7, r1
    5b02:	002c      	movs	r4, r5
    5b04:	46d8      	mov	r8, fp
    5b06:	0f7b      	lsrs	r3, r7, #29
    5b08:	00e4      	lsls	r4, r4, #3
    5b0a:	431c      	orrs	r4, r3
    5b0c:	00ff      	lsls	r7, r7, #3
    5b0e:	4e30      	ldr	r6, [pc, #192]	; (5bd0 <__aeabi_dadd+0x618>)
    5b10:	e5d6      	b.n	56c0 <__aeabi_dadd+0x108>
    5b12:	000c      	movs	r4, r1
    5b14:	0017      	movs	r7, r2
    5b16:	0006      	movs	r6, r0
    5b18:	e5d2      	b.n	56c0 <__aeabi_dadd+0x108>
    5b1a:	2b00      	cmp	r3, #0
    5b1c:	d038      	beq.n	5b90 <__aeabi_dadd+0x5d8>
    5b1e:	000b      	movs	r3, r1
    5b20:	4313      	orrs	r3, r2
    5b22:	d100      	bne.n	5b26 <__aeabi_dadd+0x56e>
    5b24:	e742      	b.n	59ac <__aeabi_dadd+0x3f4>
    5b26:	08f8      	lsrs	r0, r7, #3
    5b28:	0767      	lsls	r7, r4, #29
    5b2a:	4307      	orrs	r7, r0
    5b2c:	2080      	movs	r0, #128	; 0x80
    5b2e:	08e4      	lsrs	r4, r4, #3
    5b30:	0300      	lsls	r0, r0, #12
    5b32:	4204      	tst	r4, r0
    5b34:	d0e7      	beq.n	5b06 <__aeabi_dadd+0x54e>
    5b36:	08cb      	lsrs	r3, r1, #3
    5b38:	4203      	tst	r3, r0
    5b3a:	d1e4      	bne.n	5b06 <__aeabi_dadd+0x54e>
    5b3c:	08d2      	lsrs	r2, r2, #3
    5b3e:	0749      	lsls	r1, r1, #29
    5b40:	4311      	orrs	r1, r2
    5b42:	000f      	movs	r7, r1
    5b44:	001c      	movs	r4, r3
    5b46:	e7de      	b.n	5b06 <__aeabi_dadd+0x54e>
    5b48:	2700      	movs	r7, #0
    5b4a:	2400      	movs	r4, #0
    5b4c:	e5d5      	b.n	56fa <__aeabi_dadd+0x142>
    5b4e:	2100      	movs	r1, #0
    5b50:	e76b      	b.n	5a2a <__aeabi_dadd+0x472>
    5b52:	2500      	movs	r5, #0
    5b54:	2700      	movs	r7, #0
    5b56:	e5f3      	b.n	5740 <__aeabi_dadd+0x188>
    5b58:	464e      	mov	r6, r9
    5b5a:	0025      	movs	r5, r4
    5b5c:	3e20      	subs	r6, #32
    5b5e:	40f5      	lsrs	r5, r6
    5b60:	464b      	mov	r3, r9
    5b62:	002e      	movs	r6, r5
    5b64:	2b20      	cmp	r3, #32
    5b66:	d02d      	beq.n	5bc4 <__aeabi_dadd+0x60c>
    5b68:	2540      	movs	r5, #64	; 0x40
    5b6a:	1aed      	subs	r5, r5, r3
    5b6c:	40ac      	lsls	r4, r5
    5b6e:	4327      	orrs	r7, r4
    5b70:	1e7c      	subs	r4, r7, #1
    5b72:	41a7      	sbcs	r7, r4
    5b74:	2400      	movs	r4, #0
    5b76:	4337      	orrs	r7, r6
    5b78:	e6c9      	b.n	590e <__aeabi_dadd+0x356>
    5b7a:	2480      	movs	r4, #128	; 0x80
    5b7c:	2500      	movs	r5, #0
    5b7e:	0324      	lsls	r4, r4, #12
    5b80:	4e13      	ldr	r6, [pc, #76]	; (5bd0 <__aeabi_dadd+0x618>)
    5b82:	2700      	movs	r7, #0
    5b84:	e5dc      	b.n	5740 <__aeabi_dadd+0x188>
    5b86:	4327      	orrs	r7, r4
    5b88:	1e7c      	subs	r4, r7, #1
    5b8a:	41a7      	sbcs	r7, r4
    5b8c:	2400      	movs	r4, #0
    5b8e:	e779      	b.n	5a84 <__aeabi_dadd+0x4cc>
    5b90:	000c      	movs	r4, r1
    5b92:	0017      	movs	r7, r2
    5b94:	4e0e      	ldr	r6, [pc, #56]	; (5bd0 <__aeabi_dadd+0x618>)
    5b96:	e593      	b.n	56c0 <__aeabi_dadd+0x108>
    5b98:	000c      	movs	r4, r1
    5b9a:	0017      	movs	r7, r2
    5b9c:	e590      	b.n	56c0 <__aeabi_dadd+0x108>
    5b9e:	4656      	mov	r6, sl
    5ba0:	0023      	movs	r3, r4
    5ba2:	3e20      	subs	r6, #32
    5ba4:	40f3      	lsrs	r3, r6
    5ba6:	4699      	mov	r9, r3
    5ba8:	4653      	mov	r3, sl
    5baa:	2b20      	cmp	r3, #32
    5bac:	d00e      	beq.n	5bcc <__aeabi_dadd+0x614>
    5bae:	2340      	movs	r3, #64	; 0x40
    5bb0:	4656      	mov	r6, sl
    5bb2:	1b9b      	subs	r3, r3, r6
    5bb4:	409c      	lsls	r4, r3
    5bb6:	4327      	orrs	r7, r4
    5bb8:	1e7c      	subs	r4, r7, #1
    5bba:	41a7      	sbcs	r7, r4
    5bbc:	464b      	mov	r3, r9
    5bbe:	2400      	movs	r4, #0
    5bc0:	431f      	orrs	r7, r3
    5bc2:	e75f      	b.n	5a84 <__aeabi_dadd+0x4cc>
    5bc4:	2400      	movs	r4, #0
    5bc6:	e7d2      	b.n	5b6e <__aeabi_dadd+0x5b6>
    5bc8:	0017      	movs	r7, r2
    5bca:	e5b2      	b.n	5732 <__aeabi_dadd+0x17a>
    5bcc:	2400      	movs	r4, #0
    5bce:	e7f2      	b.n	5bb6 <__aeabi_dadd+0x5fe>
    5bd0:	000007ff 	.word	0x000007ff
    5bd4:	ff7fffff 	.word	0xff7fffff

00005bd8 <__eqdf2>:
    5bd8:	b5f0      	push	{r4, r5, r6, r7, lr}
    5bda:	464f      	mov	r7, r9
    5bdc:	4646      	mov	r6, r8
    5bde:	46d6      	mov	lr, sl
    5be0:	005c      	lsls	r4, r3, #1
    5be2:	b5c0      	push	{r6, r7, lr}
    5be4:	031f      	lsls	r7, r3, #12
    5be6:	0fdb      	lsrs	r3, r3, #31
    5be8:	469a      	mov	sl, r3
    5bea:	4b17      	ldr	r3, [pc, #92]	; (5c48 <__eqdf2+0x70>)
    5bec:	030e      	lsls	r6, r1, #12
    5bee:	004d      	lsls	r5, r1, #1
    5bf0:	4684      	mov	ip, r0
    5bf2:	4680      	mov	r8, r0
    5bf4:	0b36      	lsrs	r6, r6, #12
    5bf6:	0d6d      	lsrs	r5, r5, #21
    5bf8:	0fc9      	lsrs	r1, r1, #31
    5bfa:	4691      	mov	r9, r2
    5bfc:	0b3f      	lsrs	r7, r7, #12
    5bfe:	0d64      	lsrs	r4, r4, #21
    5c00:	2001      	movs	r0, #1
    5c02:	429d      	cmp	r5, r3
    5c04:	d008      	beq.n	5c18 <__eqdf2+0x40>
    5c06:	429c      	cmp	r4, r3
    5c08:	d001      	beq.n	5c0e <__eqdf2+0x36>
    5c0a:	42a5      	cmp	r5, r4
    5c0c:	d00b      	beq.n	5c26 <__eqdf2+0x4e>
    5c0e:	bc1c      	pop	{r2, r3, r4}
    5c10:	4690      	mov	r8, r2
    5c12:	4699      	mov	r9, r3
    5c14:	46a2      	mov	sl, r4
    5c16:	bdf0      	pop	{r4, r5, r6, r7, pc}
    5c18:	4663      	mov	r3, ip
    5c1a:	4333      	orrs	r3, r6
    5c1c:	d1f7      	bne.n	5c0e <__eqdf2+0x36>
    5c1e:	42ac      	cmp	r4, r5
    5c20:	d1f5      	bne.n	5c0e <__eqdf2+0x36>
    5c22:	433a      	orrs	r2, r7
    5c24:	d1f3      	bne.n	5c0e <__eqdf2+0x36>
    5c26:	2001      	movs	r0, #1
    5c28:	42be      	cmp	r6, r7
    5c2a:	d1f0      	bne.n	5c0e <__eqdf2+0x36>
    5c2c:	45c8      	cmp	r8, r9
    5c2e:	d1ee      	bne.n	5c0e <__eqdf2+0x36>
    5c30:	4551      	cmp	r1, sl
    5c32:	d007      	beq.n	5c44 <__eqdf2+0x6c>
    5c34:	2d00      	cmp	r5, #0
    5c36:	d1ea      	bne.n	5c0e <__eqdf2+0x36>
    5c38:	4663      	mov	r3, ip
    5c3a:	431e      	orrs	r6, r3
    5c3c:	0030      	movs	r0, r6
    5c3e:	1e46      	subs	r6, r0, #1
    5c40:	41b0      	sbcs	r0, r6
    5c42:	e7e4      	b.n	5c0e <__eqdf2+0x36>
    5c44:	2000      	movs	r0, #0
    5c46:	e7e2      	b.n	5c0e <__eqdf2+0x36>
    5c48:	000007ff 	.word	0x000007ff

00005c4c <__gedf2>:
    5c4c:	b5f0      	push	{r4, r5, r6, r7, lr}
    5c4e:	4645      	mov	r5, r8
    5c50:	46de      	mov	lr, fp
    5c52:	4657      	mov	r7, sl
    5c54:	464e      	mov	r6, r9
    5c56:	b5e0      	push	{r5, r6, r7, lr}
    5c58:	031f      	lsls	r7, r3, #12
    5c5a:	0b3d      	lsrs	r5, r7, #12
    5c5c:	4f2c      	ldr	r7, [pc, #176]	; (5d10 <__gedf2+0xc4>)
    5c5e:	030e      	lsls	r6, r1, #12
    5c60:	004c      	lsls	r4, r1, #1
    5c62:	46ab      	mov	fp, r5
    5c64:	005d      	lsls	r5, r3, #1
    5c66:	4684      	mov	ip, r0
    5c68:	0b36      	lsrs	r6, r6, #12
    5c6a:	0d64      	lsrs	r4, r4, #21
    5c6c:	0fc9      	lsrs	r1, r1, #31
    5c6e:	4690      	mov	r8, r2
    5c70:	0d6d      	lsrs	r5, r5, #21
    5c72:	0fdb      	lsrs	r3, r3, #31
    5c74:	42bc      	cmp	r4, r7
    5c76:	d02a      	beq.n	5cce <__gedf2+0x82>
    5c78:	4f25      	ldr	r7, [pc, #148]	; (5d10 <__gedf2+0xc4>)
    5c7a:	42bd      	cmp	r5, r7
    5c7c:	d02d      	beq.n	5cda <__gedf2+0x8e>
    5c7e:	2c00      	cmp	r4, #0
    5c80:	d10f      	bne.n	5ca2 <__gedf2+0x56>
    5c82:	4330      	orrs	r0, r6
    5c84:	0007      	movs	r7, r0
    5c86:	4681      	mov	r9, r0
    5c88:	4278      	negs	r0, r7
    5c8a:	4178      	adcs	r0, r7
    5c8c:	b2c0      	uxtb	r0, r0
    5c8e:	2d00      	cmp	r5, #0
    5c90:	d117      	bne.n	5cc2 <__gedf2+0x76>
    5c92:	465f      	mov	r7, fp
    5c94:	433a      	orrs	r2, r7
    5c96:	d114      	bne.n	5cc2 <__gedf2+0x76>
    5c98:	464b      	mov	r3, r9
    5c9a:	2000      	movs	r0, #0
    5c9c:	2b00      	cmp	r3, #0
    5c9e:	d00a      	beq.n	5cb6 <__gedf2+0x6a>
    5ca0:	e006      	b.n	5cb0 <__gedf2+0x64>
    5ca2:	2d00      	cmp	r5, #0
    5ca4:	d102      	bne.n	5cac <__gedf2+0x60>
    5ca6:	4658      	mov	r0, fp
    5ca8:	4302      	orrs	r2, r0
    5caa:	d001      	beq.n	5cb0 <__gedf2+0x64>
    5cac:	4299      	cmp	r1, r3
    5cae:	d018      	beq.n	5ce2 <__gedf2+0x96>
    5cb0:	4248      	negs	r0, r1
    5cb2:	2101      	movs	r1, #1
    5cb4:	4308      	orrs	r0, r1
    5cb6:	bc3c      	pop	{r2, r3, r4, r5}
    5cb8:	4690      	mov	r8, r2
    5cba:	4699      	mov	r9, r3
    5cbc:	46a2      	mov	sl, r4
    5cbe:	46ab      	mov	fp, r5
    5cc0:	bdf0      	pop	{r4, r5, r6, r7, pc}
    5cc2:	2800      	cmp	r0, #0
    5cc4:	d0f2      	beq.n	5cac <__gedf2+0x60>
    5cc6:	2001      	movs	r0, #1
    5cc8:	3b01      	subs	r3, #1
    5cca:	4318      	orrs	r0, r3
    5ccc:	e7f3      	b.n	5cb6 <__gedf2+0x6a>
    5cce:	0037      	movs	r7, r6
    5cd0:	4307      	orrs	r7, r0
    5cd2:	d0d1      	beq.n	5c78 <__gedf2+0x2c>
    5cd4:	2002      	movs	r0, #2
    5cd6:	4240      	negs	r0, r0
    5cd8:	e7ed      	b.n	5cb6 <__gedf2+0x6a>
    5cda:	465f      	mov	r7, fp
    5cdc:	4317      	orrs	r7, r2
    5cde:	d0ce      	beq.n	5c7e <__gedf2+0x32>
    5ce0:	e7f8      	b.n	5cd4 <__gedf2+0x88>
    5ce2:	42ac      	cmp	r4, r5
    5ce4:	dce4      	bgt.n	5cb0 <__gedf2+0x64>
    5ce6:	da03      	bge.n	5cf0 <__gedf2+0xa4>
    5ce8:	1e48      	subs	r0, r1, #1
    5cea:	2101      	movs	r1, #1
    5cec:	4308      	orrs	r0, r1
    5cee:	e7e2      	b.n	5cb6 <__gedf2+0x6a>
    5cf0:	455e      	cmp	r6, fp
    5cf2:	d8dd      	bhi.n	5cb0 <__gedf2+0x64>
    5cf4:	d006      	beq.n	5d04 <__gedf2+0xb8>
    5cf6:	2000      	movs	r0, #0
    5cf8:	455e      	cmp	r6, fp
    5cfa:	d2dc      	bcs.n	5cb6 <__gedf2+0x6a>
    5cfc:	2301      	movs	r3, #1
    5cfe:	1e48      	subs	r0, r1, #1
    5d00:	4318      	orrs	r0, r3
    5d02:	e7d8      	b.n	5cb6 <__gedf2+0x6a>
    5d04:	45c4      	cmp	ip, r8
    5d06:	d8d3      	bhi.n	5cb0 <__gedf2+0x64>
    5d08:	2000      	movs	r0, #0
    5d0a:	45c4      	cmp	ip, r8
    5d0c:	d3f6      	bcc.n	5cfc <__gedf2+0xb0>
    5d0e:	e7d2      	b.n	5cb6 <__gedf2+0x6a>
    5d10:	000007ff 	.word	0x000007ff

00005d14 <__ledf2>:
    5d14:	b5f0      	push	{r4, r5, r6, r7, lr}
    5d16:	464e      	mov	r6, r9
    5d18:	4645      	mov	r5, r8
    5d1a:	46de      	mov	lr, fp
    5d1c:	4657      	mov	r7, sl
    5d1e:	005c      	lsls	r4, r3, #1
    5d20:	b5e0      	push	{r5, r6, r7, lr}
    5d22:	031f      	lsls	r7, r3, #12
    5d24:	0fdb      	lsrs	r3, r3, #31
    5d26:	4699      	mov	r9, r3
    5d28:	4b2a      	ldr	r3, [pc, #168]	; (5dd4 <__ledf2+0xc0>)
    5d2a:	030e      	lsls	r6, r1, #12
    5d2c:	004d      	lsls	r5, r1, #1
    5d2e:	0fc9      	lsrs	r1, r1, #31
    5d30:	4684      	mov	ip, r0
    5d32:	0b36      	lsrs	r6, r6, #12
    5d34:	0d6d      	lsrs	r5, r5, #21
    5d36:	468b      	mov	fp, r1
    5d38:	4690      	mov	r8, r2
    5d3a:	0b3f      	lsrs	r7, r7, #12
    5d3c:	0d64      	lsrs	r4, r4, #21
    5d3e:	429d      	cmp	r5, r3
    5d40:	d020      	beq.n	5d84 <__ledf2+0x70>
    5d42:	4b24      	ldr	r3, [pc, #144]	; (5dd4 <__ledf2+0xc0>)
    5d44:	429c      	cmp	r4, r3
    5d46:	d022      	beq.n	5d8e <__ledf2+0x7a>
    5d48:	2d00      	cmp	r5, #0
    5d4a:	d112      	bne.n	5d72 <__ledf2+0x5e>
    5d4c:	4330      	orrs	r0, r6
    5d4e:	4243      	negs	r3, r0
    5d50:	4143      	adcs	r3, r0
    5d52:	b2db      	uxtb	r3, r3
    5d54:	2c00      	cmp	r4, #0
    5d56:	d01f      	beq.n	5d98 <__ledf2+0x84>
    5d58:	2b00      	cmp	r3, #0
    5d5a:	d00c      	beq.n	5d76 <__ledf2+0x62>
    5d5c:	464b      	mov	r3, r9
    5d5e:	2001      	movs	r0, #1
    5d60:	3b01      	subs	r3, #1
    5d62:	4303      	orrs	r3, r0
    5d64:	0018      	movs	r0, r3
    5d66:	bc3c      	pop	{r2, r3, r4, r5}
    5d68:	4690      	mov	r8, r2
    5d6a:	4699      	mov	r9, r3
    5d6c:	46a2      	mov	sl, r4
    5d6e:	46ab      	mov	fp, r5
    5d70:	bdf0      	pop	{r4, r5, r6, r7, pc}
    5d72:	2c00      	cmp	r4, #0
    5d74:	d016      	beq.n	5da4 <__ledf2+0x90>
    5d76:	45cb      	cmp	fp, r9
    5d78:	d017      	beq.n	5daa <__ledf2+0x96>
    5d7a:	465b      	mov	r3, fp
    5d7c:	4259      	negs	r1, r3
    5d7e:	2301      	movs	r3, #1
    5d80:	430b      	orrs	r3, r1
    5d82:	e7ef      	b.n	5d64 <__ledf2+0x50>
    5d84:	0031      	movs	r1, r6
    5d86:	2302      	movs	r3, #2
    5d88:	4301      	orrs	r1, r0
    5d8a:	d1eb      	bne.n	5d64 <__ledf2+0x50>
    5d8c:	e7d9      	b.n	5d42 <__ledf2+0x2e>
    5d8e:	0039      	movs	r1, r7
    5d90:	2302      	movs	r3, #2
    5d92:	4311      	orrs	r1, r2
    5d94:	d1e6      	bne.n	5d64 <__ledf2+0x50>
    5d96:	e7d7      	b.n	5d48 <__ledf2+0x34>
    5d98:	433a      	orrs	r2, r7
    5d9a:	d1dd      	bne.n	5d58 <__ledf2+0x44>
    5d9c:	2300      	movs	r3, #0
    5d9e:	2800      	cmp	r0, #0
    5da0:	d0e0      	beq.n	5d64 <__ledf2+0x50>
    5da2:	e7ea      	b.n	5d7a <__ledf2+0x66>
    5da4:	433a      	orrs	r2, r7
    5da6:	d1e6      	bne.n	5d76 <__ledf2+0x62>
    5da8:	e7e7      	b.n	5d7a <__ledf2+0x66>
    5daa:	42a5      	cmp	r5, r4
    5dac:	dce5      	bgt.n	5d7a <__ledf2+0x66>
    5dae:	db05      	blt.n	5dbc <__ledf2+0xa8>
    5db0:	42be      	cmp	r6, r7
    5db2:	d8e2      	bhi.n	5d7a <__ledf2+0x66>
    5db4:	d007      	beq.n	5dc6 <__ledf2+0xb2>
    5db6:	2300      	movs	r3, #0
    5db8:	42be      	cmp	r6, r7
    5dba:	d2d3      	bcs.n	5d64 <__ledf2+0x50>
    5dbc:	4659      	mov	r1, fp
    5dbe:	2301      	movs	r3, #1
    5dc0:	3901      	subs	r1, #1
    5dc2:	430b      	orrs	r3, r1
    5dc4:	e7ce      	b.n	5d64 <__ledf2+0x50>
    5dc6:	45c4      	cmp	ip, r8
    5dc8:	d8d7      	bhi.n	5d7a <__ledf2+0x66>
    5dca:	2300      	movs	r3, #0
    5dcc:	45c4      	cmp	ip, r8
    5dce:	d3f5      	bcc.n	5dbc <__ledf2+0xa8>
    5dd0:	e7c8      	b.n	5d64 <__ledf2+0x50>
    5dd2:	46c0      	nop			; (mov r8, r8)
    5dd4:	000007ff 	.word	0x000007ff

00005dd8 <__aeabi_d2iz>:
    5dd8:	b530      	push	{r4, r5, lr}
    5dda:	4d13      	ldr	r5, [pc, #76]	; (5e28 <__aeabi_d2iz+0x50>)
    5ddc:	030a      	lsls	r2, r1, #12
    5dde:	004b      	lsls	r3, r1, #1
    5de0:	0b12      	lsrs	r2, r2, #12
    5de2:	0d5b      	lsrs	r3, r3, #21
    5de4:	0fc9      	lsrs	r1, r1, #31
    5de6:	2400      	movs	r4, #0
    5de8:	42ab      	cmp	r3, r5
    5dea:	dd10      	ble.n	5e0e <__aeabi_d2iz+0x36>
    5dec:	4c0f      	ldr	r4, [pc, #60]	; (5e2c <__aeabi_d2iz+0x54>)
    5dee:	42a3      	cmp	r3, r4
    5df0:	dc0f      	bgt.n	5e12 <__aeabi_d2iz+0x3a>
    5df2:	2480      	movs	r4, #128	; 0x80
    5df4:	4d0e      	ldr	r5, [pc, #56]	; (5e30 <__aeabi_d2iz+0x58>)
    5df6:	0364      	lsls	r4, r4, #13
    5df8:	4322      	orrs	r2, r4
    5dfa:	1aed      	subs	r5, r5, r3
    5dfc:	2d1f      	cmp	r5, #31
    5dfe:	dd0b      	ble.n	5e18 <__aeabi_d2iz+0x40>
    5e00:	480c      	ldr	r0, [pc, #48]	; (5e34 <__aeabi_d2iz+0x5c>)
    5e02:	1ac3      	subs	r3, r0, r3
    5e04:	40da      	lsrs	r2, r3
    5e06:	4254      	negs	r4, r2
    5e08:	2900      	cmp	r1, #0
    5e0a:	d100      	bne.n	5e0e <__aeabi_d2iz+0x36>
    5e0c:	0014      	movs	r4, r2
    5e0e:	0020      	movs	r0, r4
    5e10:	bd30      	pop	{r4, r5, pc}
    5e12:	4b09      	ldr	r3, [pc, #36]	; (5e38 <__aeabi_d2iz+0x60>)
    5e14:	18cc      	adds	r4, r1, r3
    5e16:	e7fa      	b.n	5e0e <__aeabi_d2iz+0x36>
    5e18:	4c08      	ldr	r4, [pc, #32]	; (5e3c <__aeabi_d2iz+0x64>)
    5e1a:	40e8      	lsrs	r0, r5
    5e1c:	46a4      	mov	ip, r4
    5e1e:	4463      	add	r3, ip
    5e20:	409a      	lsls	r2, r3
    5e22:	4302      	orrs	r2, r0
    5e24:	e7ef      	b.n	5e06 <__aeabi_d2iz+0x2e>
    5e26:	46c0      	nop			; (mov r8, r8)
    5e28:	000003fe 	.word	0x000003fe
    5e2c:	0000041d 	.word	0x0000041d
    5e30:	00000433 	.word	0x00000433
    5e34:	00000413 	.word	0x00000413
    5e38:	7fffffff 	.word	0x7fffffff
    5e3c:	fffffbed 	.word	0xfffffbed

00005e40 <__aeabi_f2d>:
    5e40:	0041      	lsls	r1, r0, #1
    5e42:	0e09      	lsrs	r1, r1, #24
    5e44:	1c4b      	adds	r3, r1, #1
    5e46:	b570      	push	{r4, r5, r6, lr}
    5e48:	b2db      	uxtb	r3, r3
    5e4a:	0246      	lsls	r6, r0, #9
    5e4c:	0a75      	lsrs	r5, r6, #9
    5e4e:	0fc4      	lsrs	r4, r0, #31
    5e50:	2b01      	cmp	r3, #1
    5e52:	dd14      	ble.n	5e7e <__aeabi_f2d+0x3e>
    5e54:	23e0      	movs	r3, #224	; 0xe0
    5e56:	009b      	lsls	r3, r3, #2
    5e58:	076d      	lsls	r5, r5, #29
    5e5a:	0b36      	lsrs	r6, r6, #12
    5e5c:	18cb      	adds	r3, r1, r3
    5e5e:	2100      	movs	r1, #0
    5e60:	0d0a      	lsrs	r2, r1, #20
    5e62:	0028      	movs	r0, r5
    5e64:	0512      	lsls	r2, r2, #20
    5e66:	4d1c      	ldr	r5, [pc, #112]	; (5ed8 <__aeabi_f2d+0x98>)
    5e68:	4332      	orrs	r2, r6
    5e6a:	055b      	lsls	r3, r3, #21
    5e6c:	402a      	ands	r2, r5
    5e6e:	085b      	lsrs	r3, r3, #1
    5e70:	4313      	orrs	r3, r2
    5e72:	005b      	lsls	r3, r3, #1
    5e74:	07e4      	lsls	r4, r4, #31
    5e76:	085b      	lsrs	r3, r3, #1
    5e78:	4323      	orrs	r3, r4
    5e7a:	0019      	movs	r1, r3
    5e7c:	bd70      	pop	{r4, r5, r6, pc}
    5e7e:	2900      	cmp	r1, #0
    5e80:	d114      	bne.n	5eac <__aeabi_f2d+0x6c>
    5e82:	2d00      	cmp	r5, #0
    5e84:	d01e      	beq.n	5ec4 <__aeabi_f2d+0x84>
    5e86:	0028      	movs	r0, r5
    5e88:	f000 f866 	bl	5f58 <__clzsi2>
    5e8c:	280a      	cmp	r0, #10
    5e8e:	dc1c      	bgt.n	5eca <__aeabi_f2d+0x8a>
    5e90:	230b      	movs	r3, #11
    5e92:	002a      	movs	r2, r5
    5e94:	1a1b      	subs	r3, r3, r0
    5e96:	40da      	lsrs	r2, r3
    5e98:	0003      	movs	r3, r0
    5e9a:	3315      	adds	r3, #21
    5e9c:	409d      	lsls	r5, r3
    5e9e:	4b0f      	ldr	r3, [pc, #60]	; (5edc <__aeabi_f2d+0x9c>)
    5ea0:	0312      	lsls	r2, r2, #12
    5ea2:	1a1b      	subs	r3, r3, r0
    5ea4:	055b      	lsls	r3, r3, #21
    5ea6:	0b16      	lsrs	r6, r2, #12
    5ea8:	0d5b      	lsrs	r3, r3, #21
    5eaa:	e7d8      	b.n	5e5e <__aeabi_f2d+0x1e>
    5eac:	2d00      	cmp	r5, #0
    5eae:	d006      	beq.n	5ebe <__aeabi_f2d+0x7e>
    5eb0:	0b32      	lsrs	r2, r6, #12
    5eb2:	2680      	movs	r6, #128	; 0x80
    5eb4:	0336      	lsls	r6, r6, #12
    5eb6:	076d      	lsls	r5, r5, #29
    5eb8:	4316      	orrs	r6, r2
    5eba:	4b09      	ldr	r3, [pc, #36]	; (5ee0 <__aeabi_f2d+0xa0>)
    5ebc:	e7cf      	b.n	5e5e <__aeabi_f2d+0x1e>
    5ebe:	4b08      	ldr	r3, [pc, #32]	; (5ee0 <__aeabi_f2d+0xa0>)
    5ec0:	2600      	movs	r6, #0
    5ec2:	e7cc      	b.n	5e5e <__aeabi_f2d+0x1e>
    5ec4:	2300      	movs	r3, #0
    5ec6:	2600      	movs	r6, #0
    5ec8:	e7c9      	b.n	5e5e <__aeabi_f2d+0x1e>
    5eca:	0003      	movs	r3, r0
    5ecc:	002a      	movs	r2, r5
    5ece:	3b0b      	subs	r3, #11
    5ed0:	409a      	lsls	r2, r3
    5ed2:	2500      	movs	r5, #0
    5ed4:	e7e3      	b.n	5e9e <__aeabi_f2d+0x5e>
    5ed6:	46c0      	nop			; (mov r8, r8)
    5ed8:	800fffff 	.word	0x800fffff
    5edc:	00000389 	.word	0x00000389
    5ee0:	000007ff 	.word	0x000007ff

00005ee4 <__aeabi_cfrcmple>:
    5ee4:	4684      	mov	ip, r0
    5ee6:	1c08      	adds	r0, r1, #0
    5ee8:	4661      	mov	r1, ip
    5eea:	e7ff      	b.n	5eec <__aeabi_cfcmpeq>

00005eec <__aeabi_cfcmpeq>:
    5eec:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    5eee:	f000 f8d7 	bl	60a0 <__lesf2>
    5ef2:	2800      	cmp	r0, #0
    5ef4:	d401      	bmi.n	5efa <__aeabi_cfcmpeq+0xe>
    5ef6:	2100      	movs	r1, #0
    5ef8:	42c8      	cmn	r0, r1
    5efa:	bd1f      	pop	{r0, r1, r2, r3, r4, pc}

00005efc <__aeabi_fcmpeq>:
    5efc:	b510      	push	{r4, lr}
    5efe:	f000 f869 	bl	5fd4 <__eqsf2>
    5f02:	4240      	negs	r0, r0
    5f04:	3001      	adds	r0, #1
    5f06:	bd10      	pop	{r4, pc}

00005f08 <__aeabi_fcmplt>:
    5f08:	b510      	push	{r4, lr}
    5f0a:	f000 f8c9 	bl	60a0 <__lesf2>
    5f0e:	2800      	cmp	r0, #0
    5f10:	db01      	blt.n	5f16 <__aeabi_fcmplt+0xe>
    5f12:	2000      	movs	r0, #0
    5f14:	bd10      	pop	{r4, pc}
    5f16:	2001      	movs	r0, #1
    5f18:	bd10      	pop	{r4, pc}
    5f1a:	46c0      	nop			; (mov r8, r8)

00005f1c <__aeabi_fcmple>:
    5f1c:	b510      	push	{r4, lr}
    5f1e:	f000 f8bf 	bl	60a0 <__lesf2>
    5f22:	2800      	cmp	r0, #0
    5f24:	dd01      	ble.n	5f2a <__aeabi_fcmple+0xe>
    5f26:	2000      	movs	r0, #0
    5f28:	bd10      	pop	{r4, pc}
    5f2a:	2001      	movs	r0, #1
    5f2c:	bd10      	pop	{r4, pc}
    5f2e:	46c0      	nop			; (mov r8, r8)

00005f30 <__aeabi_fcmpgt>:
    5f30:	b510      	push	{r4, lr}
    5f32:	f000 f875 	bl	6020 <__gesf2>
    5f36:	2800      	cmp	r0, #0
    5f38:	dc01      	bgt.n	5f3e <__aeabi_fcmpgt+0xe>
    5f3a:	2000      	movs	r0, #0
    5f3c:	bd10      	pop	{r4, pc}
    5f3e:	2001      	movs	r0, #1
    5f40:	bd10      	pop	{r4, pc}
    5f42:	46c0      	nop			; (mov r8, r8)

00005f44 <__aeabi_fcmpge>:
    5f44:	b510      	push	{r4, lr}
    5f46:	f000 f86b 	bl	6020 <__gesf2>
    5f4a:	2800      	cmp	r0, #0
    5f4c:	da01      	bge.n	5f52 <__aeabi_fcmpge+0xe>
    5f4e:	2000      	movs	r0, #0
    5f50:	bd10      	pop	{r4, pc}
    5f52:	2001      	movs	r0, #1
    5f54:	bd10      	pop	{r4, pc}
    5f56:	46c0      	nop			; (mov r8, r8)

00005f58 <__clzsi2>:
    5f58:	211c      	movs	r1, #28
    5f5a:	2301      	movs	r3, #1
    5f5c:	041b      	lsls	r3, r3, #16
    5f5e:	4298      	cmp	r0, r3
    5f60:	d301      	bcc.n	5f66 <__clzsi2+0xe>
    5f62:	0c00      	lsrs	r0, r0, #16
    5f64:	3910      	subs	r1, #16
    5f66:	0a1b      	lsrs	r3, r3, #8
    5f68:	4298      	cmp	r0, r3
    5f6a:	d301      	bcc.n	5f70 <__clzsi2+0x18>
    5f6c:	0a00      	lsrs	r0, r0, #8
    5f6e:	3908      	subs	r1, #8
    5f70:	091b      	lsrs	r3, r3, #4
    5f72:	4298      	cmp	r0, r3
    5f74:	d301      	bcc.n	5f7a <__clzsi2+0x22>
    5f76:	0900      	lsrs	r0, r0, #4
    5f78:	3904      	subs	r1, #4
    5f7a:	a202      	add	r2, pc, #8	; (adr r2, 5f84 <__clzsi2+0x2c>)
    5f7c:	5c10      	ldrb	r0, [r2, r0]
    5f7e:	1840      	adds	r0, r0, r1
    5f80:	4770      	bx	lr
    5f82:	46c0      	nop			; (mov r8, r8)
    5f84:	02020304 	.word	0x02020304
    5f88:	01010101 	.word	0x01010101
	...

00005f94 <__ctzsi2>:
    5f94:	4241      	negs	r1, r0
    5f96:	4008      	ands	r0, r1
    5f98:	211c      	movs	r1, #28
    5f9a:	2301      	movs	r3, #1
    5f9c:	041b      	lsls	r3, r3, #16
    5f9e:	4298      	cmp	r0, r3
    5fa0:	d301      	bcc.n	5fa6 <__ctzsi2+0x12>
    5fa2:	0c00      	lsrs	r0, r0, #16
    5fa4:	3910      	subs	r1, #16
    5fa6:	0a1b      	lsrs	r3, r3, #8
    5fa8:	4298      	cmp	r0, r3
    5faa:	d301      	bcc.n	5fb0 <__ctzsi2+0x1c>
    5fac:	0a00      	lsrs	r0, r0, #8
    5fae:	3908      	subs	r1, #8
    5fb0:	091b      	lsrs	r3, r3, #4
    5fb2:	4298      	cmp	r0, r3
    5fb4:	d301      	bcc.n	5fba <__ctzsi2+0x26>
    5fb6:	0900      	lsrs	r0, r0, #4
    5fb8:	3904      	subs	r1, #4
    5fba:	a202      	add	r2, pc, #8	; (adr r2, 5fc4 <__ctzsi2+0x30>)
    5fbc:	5c10      	ldrb	r0, [r2, r0]
    5fbe:	1a40      	subs	r0, r0, r1
    5fc0:	4770      	bx	lr
    5fc2:	46c0      	nop			; (mov r8, r8)
    5fc4:	1d1d1c1b 	.word	0x1d1d1c1b
    5fc8:	1e1e1e1e 	.word	0x1e1e1e1e
    5fcc:	1f1f1f1f 	.word	0x1f1f1f1f
    5fd0:	1f1f1f1f 	.word	0x1f1f1f1f

00005fd4 <__eqsf2>:
    5fd4:	b570      	push	{r4, r5, r6, lr}
    5fd6:	0042      	lsls	r2, r0, #1
    5fd8:	0245      	lsls	r5, r0, #9
    5fda:	024e      	lsls	r6, r1, #9
    5fdc:	004c      	lsls	r4, r1, #1
    5fde:	0fc3      	lsrs	r3, r0, #31
    5fe0:	0a6d      	lsrs	r5, r5, #9
    5fe2:	0e12      	lsrs	r2, r2, #24
    5fe4:	0a76      	lsrs	r6, r6, #9
    5fe6:	0e24      	lsrs	r4, r4, #24
    5fe8:	0fc9      	lsrs	r1, r1, #31
    5fea:	2001      	movs	r0, #1
    5fec:	2aff      	cmp	r2, #255	; 0xff
    5fee:	d006      	beq.n	5ffe <__eqsf2+0x2a>
    5ff0:	2cff      	cmp	r4, #255	; 0xff
    5ff2:	d003      	beq.n	5ffc <__eqsf2+0x28>
    5ff4:	42a2      	cmp	r2, r4
    5ff6:	d101      	bne.n	5ffc <__eqsf2+0x28>
    5ff8:	42b5      	cmp	r5, r6
    5ffa:	d006      	beq.n	600a <__eqsf2+0x36>
    5ffc:	bd70      	pop	{r4, r5, r6, pc}
    5ffe:	2d00      	cmp	r5, #0
    6000:	d1fc      	bne.n	5ffc <__eqsf2+0x28>
    6002:	2cff      	cmp	r4, #255	; 0xff
    6004:	d1fa      	bne.n	5ffc <__eqsf2+0x28>
    6006:	2e00      	cmp	r6, #0
    6008:	d1f8      	bne.n	5ffc <__eqsf2+0x28>
    600a:	428b      	cmp	r3, r1
    600c:	d006      	beq.n	601c <__eqsf2+0x48>
    600e:	2001      	movs	r0, #1
    6010:	2a00      	cmp	r2, #0
    6012:	d1f3      	bne.n	5ffc <__eqsf2+0x28>
    6014:	0028      	movs	r0, r5
    6016:	1e45      	subs	r5, r0, #1
    6018:	41a8      	sbcs	r0, r5
    601a:	e7ef      	b.n	5ffc <__eqsf2+0x28>
    601c:	2000      	movs	r0, #0
    601e:	e7ed      	b.n	5ffc <__eqsf2+0x28>

00006020 <__gesf2>:
    6020:	b5f0      	push	{r4, r5, r6, r7, lr}
    6022:	0042      	lsls	r2, r0, #1
    6024:	0245      	lsls	r5, r0, #9
    6026:	024c      	lsls	r4, r1, #9
    6028:	0fc3      	lsrs	r3, r0, #31
    602a:	0048      	lsls	r0, r1, #1
    602c:	0a6d      	lsrs	r5, r5, #9
    602e:	0e12      	lsrs	r2, r2, #24
    6030:	0a64      	lsrs	r4, r4, #9
    6032:	0e00      	lsrs	r0, r0, #24
    6034:	0fc9      	lsrs	r1, r1, #31
    6036:	2aff      	cmp	r2, #255	; 0xff
    6038:	d01e      	beq.n	6078 <__gesf2+0x58>
    603a:	28ff      	cmp	r0, #255	; 0xff
    603c:	d021      	beq.n	6082 <__gesf2+0x62>
    603e:	2a00      	cmp	r2, #0
    6040:	d10a      	bne.n	6058 <__gesf2+0x38>
    6042:	426e      	negs	r6, r5
    6044:	416e      	adcs	r6, r5
    6046:	b2f6      	uxtb	r6, r6
    6048:	2800      	cmp	r0, #0
    604a:	d10f      	bne.n	606c <__gesf2+0x4c>
    604c:	2c00      	cmp	r4, #0
    604e:	d10d      	bne.n	606c <__gesf2+0x4c>
    6050:	2000      	movs	r0, #0
    6052:	2d00      	cmp	r5, #0
    6054:	d009      	beq.n	606a <__gesf2+0x4a>
    6056:	e005      	b.n	6064 <__gesf2+0x44>
    6058:	2800      	cmp	r0, #0
    605a:	d101      	bne.n	6060 <__gesf2+0x40>
    605c:	2c00      	cmp	r4, #0
    605e:	d001      	beq.n	6064 <__gesf2+0x44>
    6060:	428b      	cmp	r3, r1
    6062:	d011      	beq.n	6088 <__gesf2+0x68>
    6064:	2101      	movs	r1, #1
    6066:	4258      	negs	r0, r3
    6068:	4308      	orrs	r0, r1
    606a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    606c:	2e00      	cmp	r6, #0
    606e:	d0f7      	beq.n	6060 <__gesf2+0x40>
    6070:	2001      	movs	r0, #1
    6072:	3901      	subs	r1, #1
    6074:	4308      	orrs	r0, r1
    6076:	e7f8      	b.n	606a <__gesf2+0x4a>
    6078:	2d00      	cmp	r5, #0
    607a:	d0de      	beq.n	603a <__gesf2+0x1a>
    607c:	2002      	movs	r0, #2
    607e:	4240      	negs	r0, r0
    6080:	e7f3      	b.n	606a <__gesf2+0x4a>
    6082:	2c00      	cmp	r4, #0
    6084:	d0db      	beq.n	603e <__gesf2+0x1e>
    6086:	e7f9      	b.n	607c <__gesf2+0x5c>
    6088:	4282      	cmp	r2, r0
    608a:	dceb      	bgt.n	6064 <__gesf2+0x44>
    608c:	db04      	blt.n	6098 <__gesf2+0x78>
    608e:	42a5      	cmp	r5, r4
    6090:	d8e8      	bhi.n	6064 <__gesf2+0x44>
    6092:	2000      	movs	r0, #0
    6094:	42a5      	cmp	r5, r4
    6096:	d2e8      	bcs.n	606a <__gesf2+0x4a>
    6098:	2101      	movs	r1, #1
    609a:	1e58      	subs	r0, r3, #1
    609c:	4308      	orrs	r0, r1
    609e:	e7e4      	b.n	606a <__gesf2+0x4a>

000060a0 <__lesf2>:
    60a0:	b5f0      	push	{r4, r5, r6, r7, lr}
    60a2:	0042      	lsls	r2, r0, #1
    60a4:	024d      	lsls	r5, r1, #9
    60a6:	004c      	lsls	r4, r1, #1
    60a8:	0246      	lsls	r6, r0, #9
    60aa:	0a76      	lsrs	r6, r6, #9
    60ac:	0e12      	lsrs	r2, r2, #24
    60ae:	0fc3      	lsrs	r3, r0, #31
    60b0:	0a6d      	lsrs	r5, r5, #9
    60b2:	0e24      	lsrs	r4, r4, #24
    60b4:	0fc9      	lsrs	r1, r1, #31
    60b6:	2aff      	cmp	r2, #255	; 0xff
    60b8:	d016      	beq.n	60e8 <__lesf2+0x48>
    60ba:	2cff      	cmp	r4, #255	; 0xff
    60bc:	d018      	beq.n	60f0 <__lesf2+0x50>
    60be:	2a00      	cmp	r2, #0
    60c0:	d10a      	bne.n	60d8 <__lesf2+0x38>
    60c2:	4270      	negs	r0, r6
    60c4:	4170      	adcs	r0, r6
    60c6:	b2c0      	uxtb	r0, r0
    60c8:	2c00      	cmp	r4, #0
    60ca:	d015      	beq.n	60f8 <__lesf2+0x58>
    60cc:	2800      	cmp	r0, #0
    60ce:	d005      	beq.n	60dc <__lesf2+0x3c>
    60d0:	2001      	movs	r0, #1
    60d2:	3901      	subs	r1, #1
    60d4:	4308      	orrs	r0, r1
    60d6:	bdf0      	pop	{r4, r5, r6, r7, pc}
    60d8:	2c00      	cmp	r4, #0
    60da:	d013      	beq.n	6104 <__lesf2+0x64>
    60dc:	4299      	cmp	r1, r3
    60de:	d014      	beq.n	610a <__lesf2+0x6a>
    60e0:	2001      	movs	r0, #1
    60e2:	425b      	negs	r3, r3
    60e4:	4318      	orrs	r0, r3
    60e6:	e7f6      	b.n	60d6 <__lesf2+0x36>
    60e8:	2002      	movs	r0, #2
    60ea:	2e00      	cmp	r6, #0
    60ec:	d1f3      	bne.n	60d6 <__lesf2+0x36>
    60ee:	e7e4      	b.n	60ba <__lesf2+0x1a>
    60f0:	2002      	movs	r0, #2
    60f2:	2d00      	cmp	r5, #0
    60f4:	d1ef      	bne.n	60d6 <__lesf2+0x36>
    60f6:	e7e2      	b.n	60be <__lesf2+0x1e>
    60f8:	2d00      	cmp	r5, #0
    60fa:	d1e7      	bne.n	60cc <__lesf2+0x2c>
    60fc:	2000      	movs	r0, #0
    60fe:	2e00      	cmp	r6, #0
    6100:	d0e9      	beq.n	60d6 <__lesf2+0x36>
    6102:	e7ed      	b.n	60e0 <__lesf2+0x40>
    6104:	2d00      	cmp	r5, #0
    6106:	d1e9      	bne.n	60dc <__lesf2+0x3c>
    6108:	e7ea      	b.n	60e0 <__lesf2+0x40>
    610a:	42a2      	cmp	r2, r4
    610c:	dc06      	bgt.n	611c <__lesf2+0x7c>
    610e:	dbdf      	blt.n	60d0 <__lesf2+0x30>
    6110:	42ae      	cmp	r6, r5
    6112:	d803      	bhi.n	611c <__lesf2+0x7c>
    6114:	2000      	movs	r0, #0
    6116:	42ae      	cmp	r6, r5
    6118:	d3da      	bcc.n	60d0 <__lesf2+0x30>
    611a:	e7dc      	b.n	60d6 <__lesf2+0x36>
    611c:	2001      	movs	r0, #1
    611e:	4249      	negs	r1, r1
    6120:	4308      	orrs	r0, r1
    6122:	e7d8      	b.n	60d6 <__lesf2+0x36>

00006124 <atoi>:
    6124:	b510      	push	{r4, lr}
    6126:	220a      	movs	r2, #10
    6128:	2100      	movs	r1, #0
    612a:	f000 f9b5 	bl	6498 <strtol>
    612e:	bd10      	pop	{r4, pc}

00006130 <calloc>:
    6130:	b510      	push	{r4, lr}
    6132:	4b03      	ldr	r3, [pc, #12]	; (6140 <calloc+0x10>)
    6134:	000a      	movs	r2, r1
    6136:	0001      	movs	r1, r0
    6138:	6818      	ldr	r0, [r3, #0]
    613a:	f000 f842 	bl	61c2 <_calloc_r>
    613e:	bd10      	pop	{r4, pc}
    6140:	20000070 	.word	0x20000070

00006144 <__libc_init_array>:
    6144:	b570      	push	{r4, r5, r6, lr}
    6146:	2600      	movs	r6, #0
    6148:	4d0c      	ldr	r5, [pc, #48]	; (617c <__libc_init_array+0x38>)
    614a:	4c0d      	ldr	r4, [pc, #52]	; (6180 <__libc_init_array+0x3c>)
    614c:	1b64      	subs	r4, r4, r5
    614e:	10a4      	asrs	r4, r4, #2
    6150:	42a6      	cmp	r6, r4
    6152:	d109      	bne.n	6168 <__libc_init_array+0x24>
    6154:	2600      	movs	r6, #0
    6156:	f002 fa29 	bl	85ac <_init>
    615a:	4d0a      	ldr	r5, [pc, #40]	; (6184 <__libc_init_array+0x40>)
    615c:	4c0a      	ldr	r4, [pc, #40]	; (6188 <__libc_init_array+0x44>)
    615e:	1b64      	subs	r4, r4, r5
    6160:	10a4      	asrs	r4, r4, #2
    6162:	42a6      	cmp	r6, r4
    6164:	d105      	bne.n	6172 <__libc_init_array+0x2e>
    6166:	bd70      	pop	{r4, r5, r6, pc}
    6168:	00b3      	lsls	r3, r6, #2
    616a:	58eb      	ldr	r3, [r5, r3]
    616c:	4798      	blx	r3
    616e:	3601      	adds	r6, #1
    6170:	e7ee      	b.n	6150 <__libc_init_array+0xc>
    6172:	00b3      	lsls	r3, r6, #2
    6174:	58eb      	ldr	r3, [r5, r3]
    6176:	4798      	blx	r3
    6178:	3601      	adds	r6, #1
    617a:	e7f2      	b.n	6162 <__libc_init_array+0x1e>
    617c:	000085b8 	.word	0x000085b8
    6180:	000085b8 	.word	0x000085b8
    6184:	000085b8 	.word	0x000085b8
    6188:	000085bc 	.word	0x000085bc

0000618c <free>:
    618c:	b510      	push	{r4, lr}
    618e:	4b03      	ldr	r3, [pc, #12]	; (619c <free+0x10>)
    6190:	0001      	movs	r1, r0
    6192:	6818      	ldr	r0, [r3, #0]
    6194:	f000 f824 	bl	61e0 <_free_r>
    6198:	bd10      	pop	{r4, pc}
    619a:	46c0      	nop			; (mov r8, r8)
    619c:	20000070 	.word	0x20000070

000061a0 <memcpy>:
    61a0:	2300      	movs	r3, #0
    61a2:	b510      	push	{r4, lr}
    61a4:	429a      	cmp	r2, r3
    61a6:	d100      	bne.n	61aa <memcpy+0xa>
    61a8:	bd10      	pop	{r4, pc}
    61aa:	5ccc      	ldrb	r4, [r1, r3]
    61ac:	54c4      	strb	r4, [r0, r3]
    61ae:	3301      	adds	r3, #1
    61b0:	e7f8      	b.n	61a4 <memcpy+0x4>

000061b2 <memset>:
    61b2:	0003      	movs	r3, r0
    61b4:	1882      	adds	r2, r0, r2
    61b6:	4293      	cmp	r3, r2
    61b8:	d100      	bne.n	61bc <memset+0xa>
    61ba:	4770      	bx	lr
    61bc:	7019      	strb	r1, [r3, #0]
    61be:	3301      	adds	r3, #1
    61c0:	e7f9      	b.n	61b6 <memset+0x4>

000061c2 <_calloc_r>:
    61c2:	434a      	muls	r2, r1
    61c4:	b570      	push	{r4, r5, r6, lr}
    61c6:	0011      	movs	r1, r2
    61c8:	0014      	movs	r4, r2
    61ca:	f000 f853 	bl	6274 <_malloc_r>
    61ce:	1e05      	subs	r5, r0, #0
    61d0:	d003      	beq.n	61da <_calloc_r+0x18>
    61d2:	0022      	movs	r2, r4
    61d4:	2100      	movs	r1, #0
    61d6:	f7ff ffec 	bl	61b2 <memset>
    61da:	0028      	movs	r0, r5
    61dc:	bd70      	pop	{r4, r5, r6, pc}
	...

000061e0 <_free_r>:
    61e0:	b570      	push	{r4, r5, r6, lr}
    61e2:	0005      	movs	r5, r0
    61e4:	2900      	cmp	r1, #0
    61e6:	d010      	beq.n	620a <_free_r+0x2a>
    61e8:	1f0c      	subs	r4, r1, #4
    61ea:	6823      	ldr	r3, [r4, #0]
    61ec:	2b00      	cmp	r3, #0
    61ee:	da00      	bge.n	61f2 <_free_r+0x12>
    61f0:	18e4      	adds	r4, r4, r3
    61f2:	0028      	movs	r0, r5
    61f4:	f000 f9b1 	bl	655a <__malloc_lock>
    61f8:	4a1d      	ldr	r2, [pc, #116]	; (6270 <_free_r+0x90>)
    61fa:	6813      	ldr	r3, [r2, #0]
    61fc:	2b00      	cmp	r3, #0
    61fe:	d105      	bne.n	620c <_free_r+0x2c>
    6200:	6063      	str	r3, [r4, #4]
    6202:	6014      	str	r4, [r2, #0]
    6204:	0028      	movs	r0, r5
    6206:	f000 f9a9 	bl	655c <__malloc_unlock>
    620a:	bd70      	pop	{r4, r5, r6, pc}
    620c:	42a3      	cmp	r3, r4
    620e:	d909      	bls.n	6224 <_free_r+0x44>
    6210:	6821      	ldr	r1, [r4, #0]
    6212:	1860      	adds	r0, r4, r1
    6214:	4283      	cmp	r3, r0
    6216:	d1f3      	bne.n	6200 <_free_r+0x20>
    6218:	6818      	ldr	r0, [r3, #0]
    621a:	685b      	ldr	r3, [r3, #4]
    621c:	1841      	adds	r1, r0, r1
    621e:	6021      	str	r1, [r4, #0]
    6220:	e7ee      	b.n	6200 <_free_r+0x20>
    6222:	0013      	movs	r3, r2
    6224:	685a      	ldr	r2, [r3, #4]
    6226:	2a00      	cmp	r2, #0
    6228:	d001      	beq.n	622e <_free_r+0x4e>
    622a:	42a2      	cmp	r2, r4
    622c:	d9f9      	bls.n	6222 <_free_r+0x42>
    622e:	6819      	ldr	r1, [r3, #0]
    6230:	1858      	adds	r0, r3, r1
    6232:	42a0      	cmp	r0, r4
    6234:	d10b      	bne.n	624e <_free_r+0x6e>
    6236:	6820      	ldr	r0, [r4, #0]
    6238:	1809      	adds	r1, r1, r0
    623a:	1858      	adds	r0, r3, r1
    623c:	6019      	str	r1, [r3, #0]
    623e:	4282      	cmp	r2, r0
    6240:	d1e0      	bne.n	6204 <_free_r+0x24>
    6242:	6810      	ldr	r0, [r2, #0]
    6244:	6852      	ldr	r2, [r2, #4]
    6246:	1841      	adds	r1, r0, r1
    6248:	6019      	str	r1, [r3, #0]
    624a:	605a      	str	r2, [r3, #4]
    624c:	e7da      	b.n	6204 <_free_r+0x24>
    624e:	42a0      	cmp	r0, r4
    6250:	d902      	bls.n	6258 <_free_r+0x78>
    6252:	230c      	movs	r3, #12
    6254:	602b      	str	r3, [r5, #0]
    6256:	e7d5      	b.n	6204 <_free_r+0x24>
    6258:	6821      	ldr	r1, [r4, #0]
    625a:	1860      	adds	r0, r4, r1
    625c:	4282      	cmp	r2, r0
    625e:	d103      	bne.n	6268 <_free_r+0x88>
    6260:	6810      	ldr	r0, [r2, #0]
    6262:	6852      	ldr	r2, [r2, #4]
    6264:	1841      	adds	r1, r0, r1
    6266:	6021      	str	r1, [r4, #0]
    6268:	6062      	str	r2, [r4, #4]
    626a:	605c      	str	r4, [r3, #4]
    626c:	e7ca      	b.n	6204 <_free_r+0x24>
    626e:	46c0      	nop			; (mov r8, r8)
    6270:	20000368 	.word	0x20000368

00006274 <_malloc_r>:
    6274:	2303      	movs	r3, #3
    6276:	b570      	push	{r4, r5, r6, lr}
    6278:	1ccd      	adds	r5, r1, #3
    627a:	439d      	bics	r5, r3
    627c:	3508      	adds	r5, #8
    627e:	0006      	movs	r6, r0
    6280:	2d0c      	cmp	r5, #12
    6282:	d21e      	bcs.n	62c2 <_malloc_r+0x4e>
    6284:	250c      	movs	r5, #12
    6286:	42a9      	cmp	r1, r5
    6288:	d81d      	bhi.n	62c6 <_malloc_r+0x52>
    628a:	0030      	movs	r0, r6
    628c:	f000 f965 	bl	655a <__malloc_lock>
    6290:	4a25      	ldr	r2, [pc, #148]	; (6328 <_malloc_r+0xb4>)
    6292:	6814      	ldr	r4, [r2, #0]
    6294:	0021      	movs	r1, r4
    6296:	2900      	cmp	r1, #0
    6298:	d119      	bne.n	62ce <_malloc_r+0x5a>
    629a:	4c24      	ldr	r4, [pc, #144]	; (632c <_malloc_r+0xb8>)
    629c:	6823      	ldr	r3, [r4, #0]
    629e:	2b00      	cmp	r3, #0
    62a0:	d103      	bne.n	62aa <_malloc_r+0x36>
    62a2:	0030      	movs	r0, r6
    62a4:	f000 f844 	bl	6330 <_sbrk_r>
    62a8:	6020      	str	r0, [r4, #0]
    62aa:	0029      	movs	r1, r5
    62ac:	0030      	movs	r0, r6
    62ae:	f000 f83f 	bl	6330 <_sbrk_r>
    62b2:	1c43      	adds	r3, r0, #1
    62b4:	d12c      	bne.n	6310 <_malloc_r+0x9c>
    62b6:	230c      	movs	r3, #12
    62b8:	0030      	movs	r0, r6
    62ba:	6033      	str	r3, [r6, #0]
    62bc:	f000 f94e 	bl	655c <__malloc_unlock>
    62c0:	e003      	b.n	62ca <_malloc_r+0x56>
    62c2:	2d00      	cmp	r5, #0
    62c4:	dadf      	bge.n	6286 <_malloc_r+0x12>
    62c6:	230c      	movs	r3, #12
    62c8:	6033      	str	r3, [r6, #0]
    62ca:	2000      	movs	r0, #0
    62cc:	bd70      	pop	{r4, r5, r6, pc}
    62ce:	680b      	ldr	r3, [r1, #0]
    62d0:	1b5b      	subs	r3, r3, r5
    62d2:	d41a      	bmi.n	630a <_malloc_r+0x96>
    62d4:	2b0b      	cmp	r3, #11
    62d6:	d903      	bls.n	62e0 <_malloc_r+0x6c>
    62d8:	600b      	str	r3, [r1, #0]
    62da:	18cc      	adds	r4, r1, r3
    62dc:	6025      	str	r5, [r4, #0]
    62de:	e003      	b.n	62e8 <_malloc_r+0x74>
    62e0:	428c      	cmp	r4, r1
    62e2:	d10e      	bne.n	6302 <_malloc_r+0x8e>
    62e4:	6863      	ldr	r3, [r4, #4]
    62e6:	6013      	str	r3, [r2, #0]
    62e8:	0030      	movs	r0, r6
    62ea:	f000 f937 	bl	655c <__malloc_unlock>
    62ee:	0020      	movs	r0, r4
    62f0:	2207      	movs	r2, #7
    62f2:	300b      	adds	r0, #11
    62f4:	1d23      	adds	r3, r4, #4
    62f6:	4390      	bics	r0, r2
    62f8:	1ac3      	subs	r3, r0, r3
    62fa:	d0e7      	beq.n	62cc <_malloc_r+0x58>
    62fc:	425a      	negs	r2, r3
    62fe:	50e2      	str	r2, [r4, r3]
    6300:	e7e4      	b.n	62cc <_malloc_r+0x58>
    6302:	684b      	ldr	r3, [r1, #4]
    6304:	6063      	str	r3, [r4, #4]
    6306:	000c      	movs	r4, r1
    6308:	e7ee      	b.n	62e8 <_malloc_r+0x74>
    630a:	000c      	movs	r4, r1
    630c:	6849      	ldr	r1, [r1, #4]
    630e:	e7c2      	b.n	6296 <_malloc_r+0x22>
    6310:	2303      	movs	r3, #3
    6312:	1cc4      	adds	r4, r0, #3
    6314:	439c      	bics	r4, r3
    6316:	42a0      	cmp	r0, r4
    6318:	d0e0      	beq.n	62dc <_malloc_r+0x68>
    631a:	1a21      	subs	r1, r4, r0
    631c:	0030      	movs	r0, r6
    631e:	f000 f807 	bl	6330 <_sbrk_r>
    6322:	1c43      	adds	r3, r0, #1
    6324:	d1da      	bne.n	62dc <_malloc_r+0x68>
    6326:	e7c6      	b.n	62b6 <_malloc_r+0x42>
    6328:	20000368 	.word	0x20000368
    632c:	2000036c 	.word	0x2000036c

00006330 <_sbrk_r>:
    6330:	2300      	movs	r3, #0
    6332:	b570      	push	{r4, r5, r6, lr}
    6334:	4c06      	ldr	r4, [pc, #24]	; (6350 <_sbrk_r+0x20>)
    6336:	0005      	movs	r5, r0
    6338:	0008      	movs	r0, r1
    633a:	6023      	str	r3, [r4, #0]
    633c:	f7fa fa92 	bl	864 <_sbrk>
    6340:	1c43      	adds	r3, r0, #1
    6342:	d103      	bne.n	634c <_sbrk_r+0x1c>
    6344:	6823      	ldr	r3, [r4, #0]
    6346:	2b00      	cmp	r3, #0
    6348:	d000      	beq.n	634c <_sbrk_r+0x1c>
    634a:	602b      	str	r3, [r5, #0]
    634c:	bd70      	pop	{r4, r5, r6, pc}
    634e:	46c0      	nop			; (mov r8, r8)
    6350:	20000408 	.word	0x20000408

00006354 <strlen>:
    6354:	2300      	movs	r3, #0
    6356:	5cc2      	ldrb	r2, [r0, r3]
    6358:	3301      	adds	r3, #1
    635a:	2a00      	cmp	r2, #0
    635c:	d1fb      	bne.n	6356 <strlen+0x2>
    635e:	1e58      	subs	r0, r3, #1
    6360:	4770      	bx	lr

00006362 <strncpy>:
    6362:	b570      	push	{r4, r5, r6, lr}
    6364:	0004      	movs	r4, r0
    6366:	2a00      	cmp	r2, #0
    6368:	d100      	bne.n	636c <strncpy+0xa>
    636a:	bd70      	pop	{r4, r5, r6, pc}
    636c:	780d      	ldrb	r5, [r1, #0]
    636e:	1e56      	subs	r6, r2, #1
    6370:	1c63      	adds	r3, r4, #1
    6372:	7025      	strb	r5, [r4, #0]
    6374:	3101      	adds	r1, #1
    6376:	2d00      	cmp	r5, #0
    6378:	d105      	bne.n	6386 <strncpy+0x24>
    637a:	18a4      	adds	r4, r4, r2
    637c:	429c      	cmp	r4, r3
    637e:	d0f4      	beq.n	636a <strncpy+0x8>
    6380:	701d      	strb	r5, [r3, #0]
    6382:	3301      	adds	r3, #1
    6384:	e7fa      	b.n	637c <strncpy+0x1a>
    6386:	001c      	movs	r4, r3
    6388:	0032      	movs	r2, r6
    638a:	e7ec      	b.n	6366 <strncpy+0x4>

0000638c <_strtol_l.isra.0>:
    638c:	b5f0      	push	{r4, r5, r6, r7, lr}
    638e:	001f      	movs	r7, r3
    6390:	000e      	movs	r6, r1
    6392:	b087      	sub	sp, #28
    6394:	9005      	str	r0, [sp, #20]
    6396:	9103      	str	r1, [sp, #12]
    6398:	9202      	str	r2, [sp, #8]
    639a:	980c      	ldr	r0, [sp, #48]	; 0x30
    639c:	7834      	ldrb	r4, [r6, #0]
    639e:	f000 f8c7 	bl	6530 <__locale_ctype_ptr_l>
    63a2:	2208      	movs	r2, #8
    63a4:	1900      	adds	r0, r0, r4
    63a6:	7843      	ldrb	r3, [r0, #1]
    63a8:	1c75      	adds	r5, r6, #1
    63aa:	4013      	ands	r3, r2
    63ac:	d10c      	bne.n	63c8 <_strtol_l.isra.0+0x3c>
    63ae:	2c2d      	cmp	r4, #45	; 0x2d
    63b0:	d10c      	bne.n	63cc <_strtol_l.isra.0+0x40>
    63b2:	3301      	adds	r3, #1
    63b4:	782c      	ldrb	r4, [r5, #0]
    63b6:	9301      	str	r3, [sp, #4]
    63b8:	1cb5      	adds	r5, r6, #2
    63ba:	2f00      	cmp	r7, #0
    63bc:	d00c      	beq.n	63d8 <_strtol_l.isra.0+0x4c>
    63be:	2f10      	cmp	r7, #16
    63c0:	d114      	bne.n	63ec <_strtol_l.isra.0+0x60>
    63c2:	2c30      	cmp	r4, #48	; 0x30
    63c4:	d00a      	beq.n	63dc <_strtol_l.isra.0+0x50>
    63c6:	e011      	b.n	63ec <_strtol_l.isra.0+0x60>
    63c8:	002e      	movs	r6, r5
    63ca:	e7e6      	b.n	639a <_strtol_l.isra.0+0xe>
    63cc:	9301      	str	r3, [sp, #4]
    63ce:	2c2b      	cmp	r4, #43	; 0x2b
    63d0:	d1f3      	bne.n	63ba <_strtol_l.isra.0+0x2e>
    63d2:	782c      	ldrb	r4, [r5, #0]
    63d4:	1cb5      	adds	r5, r6, #2
    63d6:	e7f0      	b.n	63ba <_strtol_l.isra.0+0x2e>
    63d8:	2c30      	cmp	r4, #48	; 0x30
    63da:	d12f      	bne.n	643c <_strtol_l.isra.0+0xb0>
    63dc:	2220      	movs	r2, #32
    63de:	782b      	ldrb	r3, [r5, #0]
    63e0:	4393      	bics	r3, r2
    63e2:	2b58      	cmp	r3, #88	; 0x58
    63e4:	d151      	bne.n	648a <_strtol_l.isra.0+0xfe>
    63e6:	2710      	movs	r7, #16
    63e8:	786c      	ldrb	r4, [r5, #1]
    63ea:	3502      	adds	r5, #2
    63ec:	9b01      	ldr	r3, [sp, #4]
    63ee:	4a29      	ldr	r2, [pc, #164]	; (6494 <_strtol_l.isra.0+0x108>)
    63f0:	0039      	movs	r1, r7
    63f2:	189e      	adds	r6, r3, r2
    63f4:	0030      	movs	r0, r6
    63f6:	f7fe fc63 	bl	4cc0 <__aeabi_uidivmod>
    63fa:	0030      	movs	r0, r6
    63fc:	9104      	str	r1, [sp, #16]
    63fe:	0039      	movs	r1, r7
    6400:	f7fe fbd8 	bl	4bb4 <__udivsi3>
    6404:	2101      	movs	r1, #1
    6406:	2300      	movs	r3, #0
    6408:	4249      	negs	r1, r1
    640a:	0002      	movs	r2, r0
    640c:	468c      	mov	ip, r1
    640e:	0018      	movs	r0, r3
    6410:	0021      	movs	r1, r4
    6412:	3930      	subs	r1, #48	; 0x30
    6414:	2909      	cmp	r1, #9
    6416:	d813      	bhi.n	6440 <_strtol_l.isra.0+0xb4>
    6418:	000c      	movs	r4, r1
    641a:	42a7      	cmp	r7, r4
    641c:	dd1c      	ble.n	6458 <_strtol_l.isra.0+0xcc>
    641e:	1c59      	adds	r1, r3, #1
    6420:	d009      	beq.n	6436 <_strtol_l.isra.0+0xaa>
    6422:	4663      	mov	r3, ip
    6424:	4282      	cmp	r2, r0
    6426:	d306      	bcc.n	6436 <_strtol_l.isra.0+0xaa>
    6428:	d102      	bne.n	6430 <_strtol_l.isra.0+0xa4>
    642a:	9904      	ldr	r1, [sp, #16]
    642c:	42a1      	cmp	r1, r4
    642e:	db02      	blt.n	6436 <_strtol_l.isra.0+0xaa>
    6430:	2301      	movs	r3, #1
    6432:	4378      	muls	r0, r7
    6434:	1820      	adds	r0, r4, r0
    6436:	782c      	ldrb	r4, [r5, #0]
    6438:	3501      	adds	r5, #1
    643a:	e7e9      	b.n	6410 <_strtol_l.isra.0+0x84>
    643c:	270a      	movs	r7, #10
    643e:	e7d5      	b.n	63ec <_strtol_l.isra.0+0x60>
    6440:	0021      	movs	r1, r4
    6442:	3941      	subs	r1, #65	; 0x41
    6444:	2919      	cmp	r1, #25
    6446:	d801      	bhi.n	644c <_strtol_l.isra.0+0xc0>
    6448:	3c37      	subs	r4, #55	; 0x37
    644a:	e7e6      	b.n	641a <_strtol_l.isra.0+0x8e>
    644c:	0021      	movs	r1, r4
    644e:	3961      	subs	r1, #97	; 0x61
    6450:	2919      	cmp	r1, #25
    6452:	d801      	bhi.n	6458 <_strtol_l.isra.0+0xcc>
    6454:	3c57      	subs	r4, #87	; 0x57
    6456:	e7e0      	b.n	641a <_strtol_l.isra.0+0x8e>
    6458:	1c5a      	adds	r2, r3, #1
    645a:	d108      	bne.n	646e <_strtol_l.isra.0+0xe2>
    645c:	9a05      	ldr	r2, [sp, #20]
    645e:	3323      	adds	r3, #35	; 0x23
    6460:	6013      	str	r3, [r2, #0]
    6462:	9b02      	ldr	r3, [sp, #8]
    6464:	0030      	movs	r0, r6
    6466:	2b00      	cmp	r3, #0
    6468:	d10b      	bne.n	6482 <_strtol_l.isra.0+0xf6>
    646a:	b007      	add	sp, #28
    646c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    646e:	9a01      	ldr	r2, [sp, #4]
    6470:	2a00      	cmp	r2, #0
    6472:	d000      	beq.n	6476 <_strtol_l.isra.0+0xea>
    6474:	4240      	negs	r0, r0
    6476:	9a02      	ldr	r2, [sp, #8]
    6478:	2a00      	cmp	r2, #0
    647a:	d0f6      	beq.n	646a <_strtol_l.isra.0+0xde>
    647c:	9a03      	ldr	r2, [sp, #12]
    647e:	2b00      	cmp	r3, #0
    6480:	d000      	beq.n	6484 <_strtol_l.isra.0+0xf8>
    6482:	1e6a      	subs	r2, r5, #1
    6484:	9b02      	ldr	r3, [sp, #8]
    6486:	601a      	str	r2, [r3, #0]
    6488:	e7ef      	b.n	646a <_strtol_l.isra.0+0xde>
    648a:	2430      	movs	r4, #48	; 0x30
    648c:	2f00      	cmp	r7, #0
    648e:	d1ad      	bne.n	63ec <_strtol_l.isra.0+0x60>
    6490:	3708      	adds	r7, #8
    6492:	e7ab      	b.n	63ec <_strtol_l.isra.0+0x60>
    6494:	7fffffff 	.word	0x7fffffff

00006498 <strtol>:
    6498:	b537      	push	{r0, r1, r2, r4, r5, lr}
    649a:	0013      	movs	r3, r2
    649c:	4a06      	ldr	r2, [pc, #24]	; (64b8 <strtol+0x20>)
    649e:	0005      	movs	r5, r0
    64a0:	6810      	ldr	r0, [r2, #0]
    64a2:	6a04      	ldr	r4, [r0, #32]
    64a4:	2c00      	cmp	r4, #0
    64a6:	d100      	bne.n	64aa <strtol+0x12>
    64a8:	4c04      	ldr	r4, [pc, #16]	; (64bc <strtol+0x24>)
    64aa:	000a      	movs	r2, r1
    64ac:	9400      	str	r4, [sp, #0]
    64ae:	0029      	movs	r1, r5
    64b0:	f7ff ff6c 	bl	638c <_strtol_l.isra.0>
    64b4:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
    64b6:	46c0      	nop			; (mov r8, r8)
    64b8:	20000070 	.word	0x20000070
    64bc:	200000d4 	.word	0x200000d4

000064c0 <_vsniprintf_r>:
    64c0:	b530      	push	{r4, r5, lr}
    64c2:	0014      	movs	r4, r2
    64c4:	b09b      	sub	sp, #108	; 0x6c
    64c6:	0005      	movs	r5, r0
    64c8:	001a      	movs	r2, r3
    64ca:	2c00      	cmp	r4, #0
    64cc:	da05      	bge.n	64da <_vsniprintf_r+0x1a>
    64ce:	238b      	movs	r3, #139	; 0x8b
    64d0:	6003      	str	r3, [r0, #0]
    64d2:	2001      	movs	r0, #1
    64d4:	4240      	negs	r0, r0
    64d6:	b01b      	add	sp, #108	; 0x6c
    64d8:	bd30      	pop	{r4, r5, pc}
    64da:	2382      	movs	r3, #130	; 0x82
    64dc:	4668      	mov	r0, sp
    64de:	009b      	lsls	r3, r3, #2
    64e0:	8183      	strh	r3, [r0, #12]
    64e2:	2300      	movs	r3, #0
    64e4:	9100      	str	r1, [sp, #0]
    64e6:	9104      	str	r1, [sp, #16]
    64e8:	429c      	cmp	r4, r3
    64ea:	d000      	beq.n	64ee <_vsniprintf_r+0x2e>
    64ec:	1e63      	subs	r3, r4, #1
    64ee:	9302      	str	r3, [sp, #8]
    64f0:	9305      	str	r3, [sp, #20]
    64f2:	2301      	movs	r3, #1
    64f4:	4669      	mov	r1, sp
    64f6:	425b      	negs	r3, r3
    64f8:	81cb      	strh	r3, [r1, #14]
    64fa:	0028      	movs	r0, r5
    64fc:	9b1e      	ldr	r3, [sp, #120]	; 0x78
    64fe:	f000 f891 	bl	6624 <_svfiprintf_r>
    6502:	1c43      	adds	r3, r0, #1
    6504:	da01      	bge.n	650a <_vsniprintf_r+0x4a>
    6506:	238b      	movs	r3, #139	; 0x8b
    6508:	602b      	str	r3, [r5, #0]
    650a:	2c00      	cmp	r4, #0
    650c:	d0e3      	beq.n	64d6 <_vsniprintf_r+0x16>
    650e:	2300      	movs	r3, #0
    6510:	9a00      	ldr	r2, [sp, #0]
    6512:	7013      	strb	r3, [r2, #0]
    6514:	e7df      	b.n	64d6 <_vsniprintf_r+0x16>
	...

00006518 <vsniprintf>:
    6518:	b507      	push	{r0, r1, r2, lr}
    651a:	9300      	str	r3, [sp, #0]
    651c:	0013      	movs	r3, r2
    651e:	000a      	movs	r2, r1
    6520:	0001      	movs	r1, r0
    6522:	4802      	ldr	r0, [pc, #8]	; (652c <vsniprintf+0x14>)
    6524:	6800      	ldr	r0, [r0, #0]
    6526:	f7ff ffcb 	bl	64c0 <_vsniprintf_r>
    652a:	bd0e      	pop	{r1, r2, r3, pc}
    652c:	20000070 	.word	0x20000070

00006530 <__locale_ctype_ptr_l>:
    6530:	30ec      	adds	r0, #236	; 0xec
    6532:	6800      	ldr	r0, [r0, #0]
    6534:	4770      	bx	lr

00006536 <__ascii_mbtowc>:
    6536:	b082      	sub	sp, #8
    6538:	2900      	cmp	r1, #0
    653a:	d100      	bne.n	653e <__ascii_mbtowc+0x8>
    653c:	a901      	add	r1, sp, #4
    653e:	1e10      	subs	r0, r2, #0
    6540:	d006      	beq.n	6550 <__ascii_mbtowc+0x1a>
    6542:	2b00      	cmp	r3, #0
    6544:	d006      	beq.n	6554 <__ascii_mbtowc+0x1e>
    6546:	7813      	ldrb	r3, [r2, #0]
    6548:	600b      	str	r3, [r1, #0]
    654a:	7810      	ldrb	r0, [r2, #0]
    654c:	1e43      	subs	r3, r0, #1
    654e:	4198      	sbcs	r0, r3
    6550:	b002      	add	sp, #8
    6552:	4770      	bx	lr
    6554:	2002      	movs	r0, #2
    6556:	4240      	negs	r0, r0
    6558:	e7fa      	b.n	6550 <__ascii_mbtowc+0x1a>

0000655a <__malloc_lock>:
    655a:	4770      	bx	lr

0000655c <__malloc_unlock>:
    655c:	4770      	bx	lr
	...

00006560 <__ssputs_r>:
    6560:	b5f0      	push	{r4, r5, r6, r7, lr}
    6562:	688e      	ldr	r6, [r1, #8]
    6564:	b085      	sub	sp, #20
    6566:	0007      	movs	r7, r0
    6568:	000c      	movs	r4, r1
    656a:	9203      	str	r2, [sp, #12]
    656c:	9301      	str	r3, [sp, #4]
    656e:	429e      	cmp	r6, r3
    6570:	d839      	bhi.n	65e6 <__ssputs_r+0x86>
    6572:	2390      	movs	r3, #144	; 0x90
    6574:	898a      	ldrh	r2, [r1, #12]
    6576:	00db      	lsls	r3, r3, #3
    6578:	421a      	tst	r2, r3
    657a:	d034      	beq.n	65e6 <__ssputs_r+0x86>
    657c:	2503      	movs	r5, #3
    657e:	6909      	ldr	r1, [r1, #16]
    6580:	6823      	ldr	r3, [r4, #0]
    6582:	1a5b      	subs	r3, r3, r1
    6584:	9302      	str	r3, [sp, #8]
    6586:	6963      	ldr	r3, [r4, #20]
    6588:	9802      	ldr	r0, [sp, #8]
    658a:	435d      	muls	r5, r3
    658c:	0feb      	lsrs	r3, r5, #31
    658e:	195d      	adds	r5, r3, r5
    6590:	9b01      	ldr	r3, [sp, #4]
    6592:	106d      	asrs	r5, r5, #1
    6594:	3301      	adds	r3, #1
    6596:	181b      	adds	r3, r3, r0
    6598:	42ab      	cmp	r3, r5
    659a:	d900      	bls.n	659e <__ssputs_r+0x3e>
    659c:	001d      	movs	r5, r3
    659e:	0553      	lsls	r3, r2, #21
    65a0:	d532      	bpl.n	6608 <__ssputs_r+0xa8>
    65a2:	0029      	movs	r1, r5
    65a4:	0038      	movs	r0, r7
    65a6:	f7ff fe65 	bl	6274 <_malloc_r>
    65aa:	1e06      	subs	r6, r0, #0
    65ac:	d109      	bne.n	65c2 <__ssputs_r+0x62>
    65ae:	230c      	movs	r3, #12
    65b0:	603b      	str	r3, [r7, #0]
    65b2:	2340      	movs	r3, #64	; 0x40
    65b4:	2001      	movs	r0, #1
    65b6:	89a2      	ldrh	r2, [r4, #12]
    65b8:	4240      	negs	r0, r0
    65ba:	4313      	orrs	r3, r2
    65bc:	81a3      	strh	r3, [r4, #12]
    65be:	b005      	add	sp, #20
    65c0:	bdf0      	pop	{r4, r5, r6, r7, pc}
    65c2:	9a02      	ldr	r2, [sp, #8]
    65c4:	6921      	ldr	r1, [r4, #16]
    65c6:	f7ff fdeb 	bl	61a0 <memcpy>
    65ca:	89a3      	ldrh	r3, [r4, #12]
    65cc:	4a14      	ldr	r2, [pc, #80]	; (6620 <__ssputs_r+0xc0>)
    65ce:	401a      	ands	r2, r3
    65d0:	2380      	movs	r3, #128	; 0x80
    65d2:	4313      	orrs	r3, r2
    65d4:	81a3      	strh	r3, [r4, #12]
    65d6:	9b02      	ldr	r3, [sp, #8]
    65d8:	6126      	str	r6, [r4, #16]
    65da:	18f6      	adds	r6, r6, r3
    65dc:	6026      	str	r6, [r4, #0]
    65de:	6165      	str	r5, [r4, #20]
    65e0:	9e01      	ldr	r6, [sp, #4]
    65e2:	1aed      	subs	r5, r5, r3
    65e4:	60a5      	str	r5, [r4, #8]
    65e6:	9b01      	ldr	r3, [sp, #4]
    65e8:	42b3      	cmp	r3, r6
    65ea:	d200      	bcs.n	65ee <__ssputs_r+0x8e>
    65ec:	001e      	movs	r6, r3
    65ee:	0032      	movs	r2, r6
    65f0:	9903      	ldr	r1, [sp, #12]
    65f2:	6820      	ldr	r0, [r4, #0]
    65f4:	f000 fab9 	bl	6b6a <memmove>
    65f8:	68a3      	ldr	r3, [r4, #8]
    65fa:	2000      	movs	r0, #0
    65fc:	1b9b      	subs	r3, r3, r6
    65fe:	60a3      	str	r3, [r4, #8]
    6600:	6823      	ldr	r3, [r4, #0]
    6602:	199e      	adds	r6, r3, r6
    6604:	6026      	str	r6, [r4, #0]
    6606:	e7da      	b.n	65be <__ssputs_r+0x5e>
    6608:	002a      	movs	r2, r5
    660a:	0038      	movs	r0, r7
    660c:	f000 fabf 	bl	6b8e <_realloc_r>
    6610:	1e06      	subs	r6, r0, #0
    6612:	d1e0      	bne.n	65d6 <__ssputs_r+0x76>
    6614:	6921      	ldr	r1, [r4, #16]
    6616:	0038      	movs	r0, r7
    6618:	f7ff fde2 	bl	61e0 <_free_r>
    661c:	e7c7      	b.n	65ae <__ssputs_r+0x4e>
    661e:	46c0      	nop			; (mov r8, r8)
    6620:	fffffb7f 	.word	0xfffffb7f

00006624 <_svfiprintf_r>:
    6624:	b5f0      	push	{r4, r5, r6, r7, lr}
    6626:	b09f      	sub	sp, #124	; 0x7c
    6628:	9002      	str	r0, [sp, #8]
    662a:	9305      	str	r3, [sp, #20]
    662c:	898b      	ldrh	r3, [r1, #12]
    662e:	000f      	movs	r7, r1
    6630:	0016      	movs	r6, r2
    6632:	061b      	lsls	r3, r3, #24
    6634:	d511      	bpl.n	665a <_svfiprintf_r+0x36>
    6636:	690b      	ldr	r3, [r1, #16]
    6638:	2b00      	cmp	r3, #0
    663a:	d10e      	bne.n	665a <_svfiprintf_r+0x36>
    663c:	2140      	movs	r1, #64	; 0x40
    663e:	f7ff fe19 	bl	6274 <_malloc_r>
    6642:	6038      	str	r0, [r7, #0]
    6644:	6138      	str	r0, [r7, #16]
    6646:	2800      	cmp	r0, #0
    6648:	d105      	bne.n	6656 <_svfiprintf_r+0x32>
    664a:	230c      	movs	r3, #12
    664c:	9a02      	ldr	r2, [sp, #8]
    664e:	3801      	subs	r0, #1
    6650:	6013      	str	r3, [r2, #0]
    6652:	b01f      	add	sp, #124	; 0x7c
    6654:	bdf0      	pop	{r4, r5, r6, r7, pc}
    6656:	2340      	movs	r3, #64	; 0x40
    6658:	617b      	str	r3, [r7, #20]
    665a:	2300      	movs	r3, #0
    665c:	ad06      	add	r5, sp, #24
    665e:	616b      	str	r3, [r5, #20]
    6660:	3320      	adds	r3, #32
    6662:	766b      	strb	r3, [r5, #25]
    6664:	3310      	adds	r3, #16
    6666:	76ab      	strb	r3, [r5, #26]
    6668:	0034      	movs	r4, r6
    666a:	7823      	ldrb	r3, [r4, #0]
    666c:	2b00      	cmp	r3, #0
    666e:	d147      	bne.n	6700 <_svfiprintf_r+0xdc>
    6670:	1ba3      	subs	r3, r4, r6
    6672:	9304      	str	r3, [sp, #16]
    6674:	d00d      	beq.n	6692 <_svfiprintf_r+0x6e>
    6676:	1ba3      	subs	r3, r4, r6
    6678:	0032      	movs	r2, r6
    667a:	0039      	movs	r1, r7
    667c:	9802      	ldr	r0, [sp, #8]
    667e:	f7ff ff6f 	bl	6560 <__ssputs_r>
    6682:	1c43      	adds	r3, r0, #1
    6684:	d100      	bne.n	6688 <_svfiprintf_r+0x64>
    6686:	e0b5      	b.n	67f4 <_svfiprintf_r+0x1d0>
    6688:	696a      	ldr	r2, [r5, #20]
    668a:	9b04      	ldr	r3, [sp, #16]
    668c:	4694      	mov	ip, r2
    668e:	4463      	add	r3, ip
    6690:	616b      	str	r3, [r5, #20]
    6692:	7823      	ldrb	r3, [r4, #0]
    6694:	2b00      	cmp	r3, #0
    6696:	d100      	bne.n	669a <_svfiprintf_r+0x76>
    6698:	e0ac      	b.n	67f4 <_svfiprintf_r+0x1d0>
    669a:	2201      	movs	r2, #1
    669c:	2300      	movs	r3, #0
    669e:	4252      	negs	r2, r2
    66a0:	606a      	str	r2, [r5, #4]
    66a2:	a902      	add	r1, sp, #8
    66a4:	3254      	adds	r2, #84	; 0x54
    66a6:	1852      	adds	r2, r2, r1
    66a8:	3401      	adds	r4, #1
    66aa:	602b      	str	r3, [r5, #0]
    66ac:	60eb      	str	r3, [r5, #12]
    66ae:	60ab      	str	r3, [r5, #8]
    66b0:	7013      	strb	r3, [r2, #0]
    66b2:	65ab      	str	r3, [r5, #88]	; 0x58
    66b4:	4e58      	ldr	r6, [pc, #352]	; (6818 <_svfiprintf_r+0x1f4>)
    66b6:	2205      	movs	r2, #5
    66b8:	7821      	ldrb	r1, [r4, #0]
    66ba:	0030      	movs	r0, r6
    66bc:	f000 fa4a 	bl	6b54 <memchr>
    66c0:	1c62      	adds	r2, r4, #1
    66c2:	2800      	cmp	r0, #0
    66c4:	d120      	bne.n	6708 <_svfiprintf_r+0xe4>
    66c6:	6829      	ldr	r1, [r5, #0]
    66c8:	06cb      	lsls	r3, r1, #27
    66ca:	d504      	bpl.n	66d6 <_svfiprintf_r+0xb2>
    66cc:	2353      	movs	r3, #83	; 0x53
    66ce:	ae02      	add	r6, sp, #8
    66d0:	3020      	adds	r0, #32
    66d2:	199b      	adds	r3, r3, r6
    66d4:	7018      	strb	r0, [r3, #0]
    66d6:	070b      	lsls	r3, r1, #28
    66d8:	d504      	bpl.n	66e4 <_svfiprintf_r+0xc0>
    66da:	2353      	movs	r3, #83	; 0x53
    66dc:	202b      	movs	r0, #43	; 0x2b
    66de:	ae02      	add	r6, sp, #8
    66e0:	199b      	adds	r3, r3, r6
    66e2:	7018      	strb	r0, [r3, #0]
    66e4:	7823      	ldrb	r3, [r4, #0]
    66e6:	2b2a      	cmp	r3, #42	; 0x2a
    66e8:	d016      	beq.n	6718 <_svfiprintf_r+0xf4>
    66ea:	2000      	movs	r0, #0
    66ec:	210a      	movs	r1, #10
    66ee:	9b09      	ldr	r3, [sp, #36]	; 0x24
    66f0:	7822      	ldrb	r2, [r4, #0]
    66f2:	3a30      	subs	r2, #48	; 0x30
    66f4:	2a09      	cmp	r2, #9
    66f6:	d955      	bls.n	67a4 <_svfiprintf_r+0x180>
    66f8:	2800      	cmp	r0, #0
    66fa:	d015      	beq.n	6728 <_svfiprintf_r+0x104>
    66fc:	9309      	str	r3, [sp, #36]	; 0x24
    66fe:	e013      	b.n	6728 <_svfiprintf_r+0x104>
    6700:	2b25      	cmp	r3, #37	; 0x25
    6702:	d0b5      	beq.n	6670 <_svfiprintf_r+0x4c>
    6704:	3401      	adds	r4, #1
    6706:	e7b0      	b.n	666a <_svfiprintf_r+0x46>
    6708:	2301      	movs	r3, #1
    670a:	1b80      	subs	r0, r0, r6
    670c:	4083      	lsls	r3, r0
    670e:	6829      	ldr	r1, [r5, #0]
    6710:	0014      	movs	r4, r2
    6712:	430b      	orrs	r3, r1
    6714:	602b      	str	r3, [r5, #0]
    6716:	e7cd      	b.n	66b4 <_svfiprintf_r+0x90>
    6718:	9b05      	ldr	r3, [sp, #20]
    671a:	1d18      	adds	r0, r3, #4
    671c:	681b      	ldr	r3, [r3, #0]
    671e:	9005      	str	r0, [sp, #20]
    6720:	2b00      	cmp	r3, #0
    6722:	db39      	blt.n	6798 <_svfiprintf_r+0x174>
    6724:	9309      	str	r3, [sp, #36]	; 0x24
    6726:	0014      	movs	r4, r2
    6728:	7823      	ldrb	r3, [r4, #0]
    672a:	2b2e      	cmp	r3, #46	; 0x2e
    672c:	d10b      	bne.n	6746 <_svfiprintf_r+0x122>
    672e:	7863      	ldrb	r3, [r4, #1]
    6730:	1c62      	adds	r2, r4, #1
    6732:	2b2a      	cmp	r3, #42	; 0x2a
    6734:	d13e      	bne.n	67b4 <_svfiprintf_r+0x190>
    6736:	9b05      	ldr	r3, [sp, #20]
    6738:	3402      	adds	r4, #2
    673a:	1d1a      	adds	r2, r3, #4
    673c:	681b      	ldr	r3, [r3, #0]
    673e:	9205      	str	r2, [sp, #20]
    6740:	2b00      	cmp	r3, #0
    6742:	db34      	blt.n	67ae <_svfiprintf_r+0x18a>
    6744:	9307      	str	r3, [sp, #28]
    6746:	4e35      	ldr	r6, [pc, #212]	; (681c <_svfiprintf_r+0x1f8>)
    6748:	7821      	ldrb	r1, [r4, #0]
    674a:	2203      	movs	r2, #3
    674c:	0030      	movs	r0, r6
    674e:	f000 fa01 	bl	6b54 <memchr>
    6752:	2800      	cmp	r0, #0
    6754:	d006      	beq.n	6764 <_svfiprintf_r+0x140>
    6756:	2340      	movs	r3, #64	; 0x40
    6758:	1b80      	subs	r0, r0, r6
    675a:	4083      	lsls	r3, r0
    675c:	682a      	ldr	r2, [r5, #0]
    675e:	3401      	adds	r4, #1
    6760:	4313      	orrs	r3, r2
    6762:	602b      	str	r3, [r5, #0]
    6764:	7821      	ldrb	r1, [r4, #0]
    6766:	2206      	movs	r2, #6
    6768:	482d      	ldr	r0, [pc, #180]	; (6820 <_svfiprintf_r+0x1fc>)
    676a:	1c66      	adds	r6, r4, #1
    676c:	7629      	strb	r1, [r5, #24]
    676e:	f000 f9f1 	bl	6b54 <memchr>
    6772:	2800      	cmp	r0, #0
    6774:	d046      	beq.n	6804 <_svfiprintf_r+0x1e0>
    6776:	4b2b      	ldr	r3, [pc, #172]	; (6824 <_svfiprintf_r+0x200>)
    6778:	2b00      	cmp	r3, #0
    677a:	d12f      	bne.n	67dc <_svfiprintf_r+0x1b8>
    677c:	6829      	ldr	r1, [r5, #0]
    677e:	9b05      	ldr	r3, [sp, #20]
    6780:	2207      	movs	r2, #7
    6782:	05c9      	lsls	r1, r1, #23
    6784:	d528      	bpl.n	67d8 <_svfiprintf_r+0x1b4>
    6786:	189b      	adds	r3, r3, r2
    6788:	4393      	bics	r3, r2
    678a:	3308      	adds	r3, #8
    678c:	9305      	str	r3, [sp, #20]
    678e:	696b      	ldr	r3, [r5, #20]
    6790:	9a03      	ldr	r2, [sp, #12]
    6792:	189b      	adds	r3, r3, r2
    6794:	616b      	str	r3, [r5, #20]
    6796:	e767      	b.n	6668 <_svfiprintf_r+0x44>
    6798:	425b      	negs	r3, r3
    679a:	60eb      	str	r3, [r5, #12]
    679c:	2302      	movs	r3, #2
    679e:	430b      	orrs	r3, r1
    67a0:	602b      	str	r3, [r5, #0]
    67a2:	e7c0      	b.n	6726 <_svfiprintf_r+0x102>
    67a4:	434b      	muls	r3, r1
    67a6:	3401      	adds	r4, #1
    67a8:	189b      	adds	r3, r3, r2
    67aa:	2001      	movs	r0, #1
    67ac:	e7a0      	b.n	66f0 <_svfiprintf_r+0xcc>
    67ae:	2301      	movs	r3, #1
    67b0:	425b      	negs	r3, r3
    67b2:	e7c7      	b.n	6744 <_svfiprintf_r+0x120>
    67b4:	2300      	movs	r3, #0
    67b6:	0014      	movs	r4, r2
    67b8:	200a      	movs	r0, #10
    67ba:	001a      	movs	r2, r3
    67bc:	606b      	str	r3, [r5, #4]
    67be:	7821      	ldrb	r1, [r4, #0]
    67c0:	3930      	subs	r1, #48	; 0x30
    67c2:	2909      	cmp	r1, #9
    67c4:	d903      	bls.n	67ce <_svfiprintf_r+0x1aa>
    67c6:	2b00      	cmp	r3, #0
    67c8:	d0bd      	beq.n	6746 <_svfiprintf_r+0x122>
    67ca:	9207      	str	r2, [sp, #28]
    67cc:	e7bb      	b.n	6746 <_svfiprintf_r+0x122>
    67ce:	4342      	muls	r2, r0
    67d0:	3401      	adds	r4, #1
    67d2:	1852      	adds	r2, r2, r1
    67d4:	2301      	movs	r3, #1
    67d6:	e7f2      	b.n	67be <_svfiprintf_r+0x19a>
    67d8:	3307      	adds	r3, #7
    67da:	e7d5      	b.n	6788 <_svfiprintf_r+0x164>
    67dc:	ab05      	add	r3, sp, #20
    67de:	9300      	str	r3, [sp, #0]
    67e0:	003a      	movs	r2, r7
    67e2:	4b11      	ldr	r3, [pc, #68]	; (6828 <_svfiprintf_r+0x204>)
    67e4:	0029      	movs	r1, r5
    67e6:	9802      	ldr	r0, [sp, #8]
    67e8:	e000      	b.n	67ec <_svfiprintf_r+0x1c8>
    67ea:	bf00      	nop
    67ec:	9003      	str	r0, [sp, #12]
    67ee:	9b03      	ldr	r3, [sp, #12]
    67f0:	3301      	adds	r3, #1
    67f2:	d1cc      	bne.n	678e <_svfiprintf_r+0x16a>
    67f4:	89bb      	ldrh	r3, [r7, #12]
    67f6:	980b      	ldr	r0, [sp, #44]	; 0x2c
    67f8:	065b      	lsls	r3, r3, #25
    67fa:	d400      	bmi.n	67fe <_svfiprintf_r+0x1da>
    67fc:	e729      	b.n	6652 <_svfiprintf_r+0x2e>
    67fe:	2001      	movs	r0, #1
    6800:	4240      	negs	r0, r0
    6802:	e726      	b.n	6652 <_svfiprintf_r+0x2e>
    6804:	ab05      	add	r3, sp, #20
    6806:	9300      	str	r3, [sp, #0]
    6808:	003a      	movs	r2, r7
    680a:	4b07      	ldr	r3, [pc, #28]	; (6828 <_svfiprintf_r+0x204>)
    680c:	0029      	movs	r1, r5
    680e:	9802      	ldr	r0, [sp, #8]
    6810:	f000 f87a 	bl	6908 <_printf_i>
    6814:	e7ea      	b.n	67ec <_svfiprintf_r+0x1c8>
    6816:	46c0      	nop			; (mov r8, r8)
    6818:	00008476 	.word	0x00008476
    681c:	0000847c 	.word	0x0000847c
    6820:	00008480 	.word	0x00008480
    6824:	00000000 	.word	0x00000000
    6828:	00006561 	.word	0x00006561

0000682c <_printf_common>:
    682c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    682e:	0015      	movs	r5, r2
    6830:	9301      	str	r3, [sp, #4]
    6832:	688a      	ldr	r2, [r1, #8]
    6834:	690b      	ldr	r3, [r1, #16]
    6836:	9000      	str	r0, [sp, #0]
    6838:	000c      	movs	r4, r1
    683a:	4293      	cmp	r3, r2
    683c:	da00      	bge.n	6840 <_printf_common+0x14>
    683e:	0013      	movs	r3, r2
    6840:	0022      	movs	r2, r4
    6842:	602b      	str	r3, [r5, #0]
    6844:	3243      	adds	r2, #67	; 0x43
    6846:	7812      	ldrb	r2, [r2, #0]
    6848:	2a00      	cmp	r2, #0
    684a:	d001      	beq.n	6850 <_printf_common+0x24>
    684c:	3301      	adds	r3, #1
    684e:	602b      	str	r3, [r5, #0]
    6850:	6823      	ldr	r3, [r4, #0]
    6852:	069b      	lsls	r3, r3, #26
    6854:	d502      	bpl.n	685c <_printf_common+0x30>
    6856:	682b      	ldr	r3, [r5, #0]
    6858:	3302      	adds	r3, #2
    685a:	602b      	str	r3, [r5, #0]
    685c:	2706      	movs	r7, #6
    685e:	6823      	ldr	r3, [r4, #0]
    6860:	401f      	ands	r7, r3
    6862:	d027      	beq.n	68b4 <_printf_common+0x88>
    6864:	0023      	movs	r3, r4
    6866:	3343      	adds	r3, #67	; 0x43
    6868:	781b      	ldrb	r3, [r3, #0]
    686a:	1e5a      	subs	r2, r3, #1
    686c:	4193      	sbcs	r3, r2
    686e:	6822      	ldr	r2, [r4, #0]
    6870:	0692      	lsls	r2, r2, #26
    6872:	d430      	bmi.n	68d6 <_printf_common+0xaa>
    6874:	0022      	movs	r2, r4
    6876:	9901      	ldr	r1, [sp, #4]
    6878:	3243      	adds	r2, #67	; 0x43
    687a:	9800      	ldr	r0, [sp, #0]
    687c:	9e08      	ldr	r6, [sp, #32]
    687e:	47b0      	blx	r6
    6880:	1c43      	adds	r3, r0, #1
    6882:	d025      	beq.n	68d0 <_printf_common+0xa4>
    6884:	2306      	movs	r3, #6
    6886:	6820      	ldr	r0, [r4, #0]
    6888:	682a      	ldr	r2, [r5, #0]
    688a:	68e1      	ldr	r1, [r4, #12]
    688c:	4003      	ands	r3, r0
    688e:	2500      	movs	r5, #0
    6890:	2b04      	cmp	r3, #4
    6892:	d103      	bne.n	689c <_printf_common+0x70>
    6894:	1a8d      	subs	r5, r1, r2
    6896:	43eb      	mvns	r3, r5
    6898:	17db      	asrs	r3, r3, #31
    689a:	401d      	ands	r5, r3
    689c:	68a3      	ldr	r3, [r4, #8]
    689e:	6922      	ldr	r2, [r4, #16]
    68a0:	4293      	cmp	r3, r2
    68a2:	dd01      	ble.n	68a8 <_printf_common+0x7c>
    68a4:	1a9b      	subs	r3, r3, r2
    68a6:	18ed      	adds	r5, r5, r3
    68a8:	2700      	movs	r7, #0
    68aa:	42bd      	cmp	r5, r7
    68ac:	d120      	bne.n	68f0 <_printf_common+0xc4>
    68ae:	2000      	movs	r0, #0
    68b0:	e010      	b.n	68d4 <_printf_common+0xa8>
    68b2:	3701      	adds	r7, #1
    68b4:	68e3      	ldr	r3, [r4, #12]
    68b6:	682a      	ldr	r2, [r5, #0]
    68b8:	1a9b      	subs	r3, r3, r2
    68ba:	429f      	cmp	r7, r3
    68bc:	dad2      	bge.n	6864 <_printf_common+0x38>
    68be:	0022      	movs	r2, r4
    68c0:	2301      	movs	r3, #1
    68c2:	3219      	adds	r2, #25
    68c4:	9901      	ldr	r1, [sp, #4]
    68c6:	9800      	ldr	r0, [sp, #0]
    68c8:	9e08      	ldr	r6, [sp, #32]
    68ca:	47b0      	blx	r6
    68cc:	1c43      	adds	r3, r0, #1
    68ce:	d1f0      	bne.n	68b2 <_printf_common+0x86>
    68d0:	2001      	movs	r0, #1
    68d2:	4240      	negs	r0, r0
    68d4:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
    68d6:	2030      	movs	r0, #48	; 0x30
    68d8:	18e1      	adds	r1, r4, r3
    68da:	3143      	adds	r1, #67	; 0x43
    68dc:	7008      	strb	r0, [r1, #0]
    68de:	0021      	movs	r1, r4
    68e0:	1c5a      	adds	r2, r3, #1
    68e2:	3145      	adds	r1, #69	; 0x45
    68e4:	7809      	ldrb	r1, [r1, #0]
    68e6:	18a2      	adds	r2, r4, r2
    68e8:	3243      	adds	r2, #67	; 0x43
    68ea:	3302      	adds	r3, #2
    68ec:	7011      	strb	r1, [r2, #0]
    68ee:	e7c1      	b.n	6874 <_printf_common+0x48>
    68f0:	0022      	movs	r2, r4
    68f2:	2301      	movs	r3, #1
    68f4:	321a      	adds	r2, #26
    68f6:	9901      	ldr	r1, [sp, #4]
    68f8:	9800      	ldr	r0, [sp, #0]
    68fa:	9e08      	ldr	r6, [sp, #32]
    68fc:	47b0      	blx	r6
    68fe:	1c43      	adds	r3, r0, #1
    6900:	d0e6      	beq.n	68d0 <_printf_common+0xa4>
    6902:	3701      	adds	r7, #1
    6904:	e7d1      	b.n	68aa <_printf_common+0x7e>
	...

00006908 <_printf_i>:
    6908:	b5f0      	push	{r4, r5, r6, r7, lr}
    690a:	b08b      	sub	sp, #44	; 0x2c
    690c:	9206      	str	r2, [sp, #24]
    690e:	000a      	movs	r2, r1
    6910:	3243      	adds	r2, #67	; 0x43
    6912:	9307      	str	r3, [sp, #28]
    6914:	9005      	str	r0, [sp, #20]
    6916:	9204      	str	r2, [sp, #16]
    6918:	7e0a      	ldrb	r2, [r1, #24]
    691a:	000c      	movs	r4, r1
    691c:	9b10      	ldr	r3, [sp, #64]	; 0x40
    691e:	2a6e      	cmp	r2, #110	; 0x6e
    6920:	d100      	bne.n	6924 <_printf_i+0x1c>
    6922:	e08f      	b.n	6a44 <_printf_i+0x13c>
    6924:	d817      	bhi.n	6956 <_printf_i+0x4e>
    6926:	2a63      	cmp	r2, #99	; 0x63
    6928:	d02c      	beq.n	6984 <_printf_i+0x7c>
    692a:	d808      	bhi.n	693e <_printf_i+0x36>
    692c:	2a00      	cmp	r2, #0
    692e:	d100      	bne.n	6932 <_printf_i+0x2a>
    6930:	e099      	b.n	6a66 <_printf_i+0x15e>
    6932:	2a58      	cmp	r2, #88	; 0x58
    6934:	d054      	beq.n	69e0 <_printf_i+0xd8>
    6936:	0026      	movs	r6, r4
    6938:	3642      	adds	r6, #66	; 0x42
    693a:	7032      	strb	r2, [r6, #0]
    693c:	e029      	b.n	6992 <_printf_i+0x8a>
    693e:	2a64      	cmp	r2, #100	; 0x64
    6940:	d001      	beq.n	6946 <_printf_i+0x3e>
    6942:	2a69      	cmp	r2, #105	; 0x69
    6944:	d1f7      	bne.n	6936 <_printf_i+0x2e>
    6946:	6821      	ldr	r1, [r4, #0]
    6948:	681a      	ldr	r2, [r3, #0]
    694a:	0608      	lsls	r0, r1, #24
    694c:	d523      	bpl.n	6996 <_printf_i+0x8e>
    694e:	1d11      	adds	r1, r2, #4
    6950:	6019      	str	r1, [r3, #0]
    6952:	6815      	ldr	r5, [r2, #0]
    6954:	e025      	b.n	69a2 <_printf_i+0x9a>
    6956:	2a73      	cmp	r2, #115	; 0x73
    6958:	d100      	bne.n	695c <_printf_i+0x54>
    695a:	e088      	b.n	6a6e <_printf_i+0x166>
    695c:	d808      	bhi.n	6970 <_printf_i+0x68>
    695e:	2a6f      	cmp	r2, #111	; 0x6f
    6960:	d029      	beq.n	69b6 <_printf_i+0xae>
    6962:	2a70      	cmp	r2, #112	; 0x70
    6964:	d1e7      	bne.n	6936 <_printf_i+0x2e>
    6966:	2220      	movs	r2, #32
    6968:	6809      	ldr	r1, [r1, #0]
    696a:	430a      	orrs	r2, r1
    696c:	6022      	str	r2, [r4, #0]
    696e:	e003      	b.n	6978 <_printf_i+0x70>
    6970:	2a75      	cmp	r2, #117	; 0x75
    6972:	d020      	beq.n	69b6 <_printf_i+0xae>
    6974:	2a78      	cmp	r2, #120	; 0x78
    6976:	d1de      	bne.n	6936 <_printf_i+0x2e>
    6978:	0022      	movs	r2, r4
    697a:	2178      	movs	r1, #120	; 0x78
    697c:	3245      	adds	r2, #69	; 0x45
    697e:	7011      	strb	r1, [r2, #0]
    6980:	4a6c      	ldr	r2, [pc, #432]	; (6b34 <_printf_i+0x22c>)
    6982:	e030      	b.n	69e6 <_printf_i+0xde>
    6984:	000e      	movs	r6, r1
    6986:	681a      	ldr	r2, [r3, #0]
    6988:	3642      	adds	r6, #66	; 0x42
    698a:	1d11      	adds	r1, r2, #4
    698c:	6019      	str	r1, [r3, #0]
    698e:	6813      	ldr	r3, [r2, #0]
    6990:	7033      	strb	r3, [r6, #0]
    6992:	2301      	movs	r3, #1
    6994:	e079      	b.n	6a8a <_printf_i+0x182>
    6996:	0649      	lsls	r1, r1, #25
    6998:	d5d9      	bpl.n	694e <_printf_i+0x46>
    699a:	1d11      	adds	r1, r2, #4
    699c:	6019      	str	r1, [r3, #0]
    699e:	2300      	movs	r3, #0
    69a0:	5ed5      	ldrsh	r5, [r2, r3]
    69a2:	2d00      	cmp	r5, #0
    69a4:	da03      	bge.n	69ae <_printf_i+0xa6>
    69a6:	232d      	movs	r3, #45	; 0x2d
    69a8:	9a04      	ldr	r2, [sp, #16]
    69aa:	426d      	negs	r5, r5
    69ac:	7013      	strb	r3, [r2, #0]
    69ae:	4b62      	ldr	r3, [pc, #392]	; (6b38 <_printf_i+0x230>)
    69b0:	270a      	movs	r7, #10
    69b2:	9303      	str	r3, [sp, #12]
    69b4:	e02f      	b.n	6a16 <_printf_i+0x10e>
    69b6:	6820      	ldr	r0, [r4, #0]
    69b8:	6819      	ldr	r1, [r3, #0]
    69ba:	0605      	lsls	r5, r0, #24
    69bc:	d503      	bpl.n	69c6 <_printf_i+0xbe>
    69be:	1d08      	adds	r0, r1, #4
    69c0:	6018      	str	r0, [r3, #0]
    69c2:	680d      	ldr	r5, [r1, #0]
    69c4:	e005      	b.n	69d2 <_printf_i+0xca>
    69c6:	0640      	lsls	r0, r0, #25
    69c8:	d5f9      	bpl.n	69be <_printf_i+0xb6>
    69ca:	680d      	ldr	r5, [r1, #0]
    69cc:	1d08      	adds	r0, r1, #4
    69ce:	6018      	str	r0, [r3, #0]
    69d0:	b2ad      	uxth	r5, r5
    69d2:	4b59      	ldr	r3, [pc, #356]	; (6b38 <_printf_i+0x230>)
    69d4:	2708      	movs	r7, #8
    69d6:	9303      	str	r3, [sp, #12]
    69d8:	2a6f      	cmp	r2, #111	; 0x6f
    69da:	d018      	beq.n	6a0e <_printf_i+0x106>
    69dc:	270a      	movs	r7, #10
    69de:	e016      	b.n	6a0e <_printf_i+0x106>
    69e0:	3145      	adds	r1, #69	; 0x45
    69e2:	700a      	strb	r2, [r1, #0]
    69e4:	4a54      	ldr	r2, [pc, #336]	; (6b38 <_printf_i+0x230>)
    69e6:	9203      	str	r2, [sp, #12]
    69e8:	681a      	ldr	r2, [r3, #0]
    69ea:	6821      	ldr	r1, [r4, #0]
    69ec:	1d10      	adds	r0, r2, #4
    69ee:	6018      	str	r0, [r3, #0]
    69f0:	6815      	ldr	r5, [r2, #0]
    69f2:	0608      	lsls	r0, r1, #24
    69f4:	d522      	bpl.n	6a3c <_printf_i+0x134>
    69f6:	07cb      	lsls	r3, r1, #31
    69f8:	d502      	bpl.n	6a00 <_printf_i+0xf8>
    69fa:	2320      	movs	r3, #32
    69fc:	4319      	orrs	r1, r3
    69fe:	6021      	str	r1, [r4, #0]
    6a00:	2710      	movs	r7, #16
    6a02:	2d00      	cmp	r5, #0
    6a04:	d103      	bne.n	6a0e <_printf_i+0x106>
    6a06:	2320      	movs	r3, #32
    6a08:	6822      	ldr	r2, [r4, #0]
    6a0a:	439a      	bics	r2, r3
    6a0c:	6022      	str	r2, [r4, #0]
    6a0e:	0023      	movs	r3, r4
    6a10:	2200      	movs	r2, #0
    6a12:	3343      	adds	r3, #67	; 0x43
    6a14:	701a      	strb	r2, [r3, #0]
    6a16:	6863      	ldr	r3, [r4, #4]
    6a18:	60a3      	str	r3, [r4, #8]
    6a1a:	2b00      	cmp	r3, #0
    6a1c:	db5c      	blt.n	6ad8 <_printf_i+0x1d0>
    6a1e:	2204      	movs	r2, #4
    6a20:	6821      	ldr	r1, [r4, #0]
    6a22:	4391      	bics	r1, r2
    6a24:	6021      	str	r1, [r4, #0]
    6a26:	2d00      	cmp	r5, #0
    6a28:	d158      	bne.n	6adc <_printf_i+0x1d4>
    6a2a:	9e04      	ldr	r6, [sp, #16]
    6a2c:	2b00      	cmp	r3, #0
    6a2e:	d064      	beq.n	6afa <_printf_i+0x1f2>
    6a30:	0026      	movs	r6, r4
    6a32:	9b03      	ldr	r3, [sp, #12]
    6a34:	3642      	adds	r6, #66	; 0x42
    6a36:	781b      	ldrb	r3, [r3, #0]
    6a38:	7033      	strb	r3, [r6, #0]
    6a3a:	e05e      	b.n	6afa <_printf_i+0x1f2>
    6a3c:	0648      	lsls	r0, r1, #25
    6a3e:	d5da      	bpl.n	69f6 <_printf_i+0xee>
    6a40:	b2ad      	uxth	r5, r5
    6a42:	e7d8      	b.n	69f6 <_printf_i+0xee>
    6a44:	6809      	ldr	r1, [r1, #0]
    6a46:	681a      	ldr	r2, [r3, #0]
    6a48:	0608      	lsls	r0, r1, #24
    6a4a:	d505      	bpl.n	6a58 <_printf_i+0x150>
    6a4c:	1d11      	adds	r1, r2, #4
    6a4e:	6019      	str	r1, [r3, #0]
    6a50:	6813      	ldr	r3, [r2, #0]
    6a52:	6962      	ldr	r2, [r4, #20]
    6a54:	601a      	str	r2, [r3, #0]
    6a56:	e006      	b.n	6a66 <_printf_i+0x15e>
    6a58:	0649      	lsls	r1, r1, #25
    6a5a:	d5f7      	bpl.n	6a4c <_printf_i+0x144>
    6a5c:	1d11      	adds	r1, r2, #4
    6a5e:	6019      	str	r1, [r3, #0]
    6a60:	6813      	ldr	r3, [r2, #0]
    6a62:	8aa2      	ldrh	r2, [r4, #20]
    6a64:	801a      	strh	r2, [r3, #0]
    6a66:	2300      	movs	r3, #0
    6a68:	9e04      	ldr	r6, [sp, #16]
    6a6a:	6123      	str	r3, [r4, #16]
    6a6c:	e054      	b.n	6b18 <_printf_i+0x210>
    6a6e:	681a      	ldr	r2, [r3, #0]
    6a70:	1d11      	adds	r1, r2, #4
    6a72:	6019      	str	r1, [r3, #0]
    6a74:	6816      	ldr	r6, [r2, #0]
    6a76:	2100      	movs	r1, #0
    6a78:	6862      	ldr	r2, [r4, #4]
    6a7a:	0030      	movs	r0, r6
    6a7c:	f000 f86a 	bl	6b54 <memchr>
    6a80:	2800      	cmp	r0, #0
    6a82:	d001      	beq.n	6a88 <_printf_i+0x180>
    6a84:	1b80      	subs	r0, r0, r6
    6a86:	6060      	str	r0, [r4, #4]
    6a88:	6863      	ldr	r3, [r4, #4]
    6a8a:	6123      	str	r3, [r4, #16]
    6a8c:	2300      	movs	r3, #0
    6a8e:	9a04      	ldr	r2, [sp, #16]
    6a90:	7013      	strb	r3, [r2, #0]
    6a92:	e041      	b.n	6b18 <_printf_i+0x210>
    6a94:	6923      	ldr	r3, [r4, #16]
    6a96:	0032      	movs	r2, r6
    6a98:	9906      	ldr	r1, [sp, #24]
    6a9a:	9805      	ldr	r0, [sp, #20]
    6a9c:	9d07      	ldr	r5, [sp, #28]
    6a9e:	47a8      	blx	r5
    6aa0:	1c43      	adds	r3, r0, #1
    6aa2:	d043      	beq.n	6b2c <_printf_i+0x224>
    6aa4:	6823      	ldr	r3, [r4, #0]
    6aa6:	2500      	movs	r5, #0
    6aa8:	079b      	lsls	r3, r3, #30
    6aaa:	d40f      	bmi.n	6acc <_printf_i+0x1c4>
    6aac:	9b09      	ldr	r3, [sp, #36]	; 0x24
    6aae:	68e0      	ldr	r0, [r4, #12]
    6ab0:	4298      	cmp	r0, r3
    6ab2:	da3d      	bge.n	6b30 <_printf_i+0x228>
    6ab4:	0018      	movs	r0, r3
    6ab6:	e03b      	b.n	6b30 <_printf_i+0x228>
    6ab8:	0022      	movs	r2, r4
    6aba:	2301      	movs	r3, #1
    6abc:	3219      	adds	r2, #25
    6abe:	9906      	ldr	r1, [sp, #24]
    6ac0:	9805      	ldr	r0, [sp, #20]
    6ac2:	9e07      	ldr	r6, [sp, #28]
    6ac4:	47b0      	blx	r6
    6ac6:	1c43      	adds	r3, r0, #1
    6ac8:	d030      	beq.n	6b2c <_printf_i+0x224>
    6aca:	3501      	adds	r5, #1
    6acc:	68e3      	ldr	r3, [r4, #12]
    6ace:	9a09      	ldr	r2, [sp, #36]	; 0x24
    6ad0:	1a9b      	subs	r3, r3, r2
    6ad2:	429d      	cmp	r5, r3
    6ad4:	dbf0      	blt.n	6ab8 <_printf_i+0x1b0>
    6ad6:	e7e9      	b.n	6aac <_printf_i+0x1a4>
    6ad8:	2d00      	cmp	r5, #0
    6ada:	d0a9      	beq.n	6a30 <_printf_i+0x128>
    6adc:	9e04      	ldr	r6, [sp, #16]
    6ade:	0028      	movs	r0, r5
    6ae0:	0039      	movs	r1, r7
    6ae2:	f7fe f8ed 	bl	4cc0 <__aeabi_uidivmod>
    6ae6:	9b03      	ldr	r3, [sp, #12]
    6ae8:	3e01      	subs	r6, #1
    6aea:	5c5b      	ldrb	r3, [r3, r1]
    6aec:	0028      	movs	r0, r5
    6aee:	7033      	strb	r3, [r6, #0]
    6af0:	0039      	movs	r1, r7
    6af2:	f7fe f85f 	bl	4bb4 <__udivsi3>
    6af6:	1e05      	subs	r5, r0, #0
    6af8:	d1f1      	bne.n	6ade <_printf_i+0x1d6>
    6afa:	2f08      	cmp	r7, #8
    6afc:	d109      	bne.n	6b12 <_printf_i+0x20a>
    6afe:	6823      	ldr	r3, [r4, #0]
    6b00:	07db      	lsls	r3, r3, #31
    6b02:	d506      	bpl.n	6b12 <_printf_i+0x20a>
    6b04:	6863      	ldr	r3, [r4, #4]
    6b06:	6922      	ldr	r2, [r4, #16]
    6b08:	4293      	cmp	r3, r2
    6b0a:	dc02      	bgt.n	6b12 <_printf_i+0x20a>
    6b0c:	2330      	movs	r3, #48	; 0x30
    6b0e:	3e01      	subs	r6, #1
    6b10:	7033      	strb	r3, [r6, #0]
    6b12:	9b04      	ldr	r3, [sp, #16]
    6b14:	1b9b      	subs	r3, r3, r6
    6b16:	6123      	str	r3, [r4, #16]
    6b18:	9b07      	ldr	r3, [sp, #28]
    6b1a:	aa09      	add	r2, sp, #36	; 0x24
    6b1c:	9300      	str	r3, [sp, #0]
    6b1e:	0021      	movs	r1, r4
    6b20:	9b06      	ldr	r3, [sp, #24]
    6b22:	9805      	ldr	r0, [sp, #20]
    6b24:	f7ff fe82 	bl	682c <_printf_common>
    6b28:	1c43      	adds	r3, r0, #1
    6b2a:	d1b3      	bne.n	6a94 <_printf_i+0x18c>
    6b2c:	2001      	movs	r0, #1
    6b2e:	4240      	negs	r0, r0
    6b30:	b00b      	add	sp, #44	; 0x2c
    6b32:	bdf0      	pop	{r4, r5, r6, r7, pc}
    6b34:	00008498 	.word	0x00008498
    6b38:	00008487 	.word	0x00008487

00006b3c <__ascii_wctomb>:
    6b3c:	1e0b      	subs	r3, r1, #0
    6b3e:	d004      	beq.n	6b4a <__ascii_wctomb+0xe>
    6b40:	2aff      	cmp	r2, #255	; 0xff
    6b42:	d904      	bls.n	6b4e <__ascii_wctomb+0x12>
    6b44:	238a      	movs	r3, #138	; 0x8a
    6b46:	6003      	str	r3, [r0, #0]
    6b48:	3b8b      	subs	r3, #139	; 0x8b
    6b4a:	0018      	movs	r0, r3
    6b4c:	4770      	bx	lr
    6b4e:	700a      	strb	r2, [r1, #0]
    6b50:	2301      	movs	r3, #1
    6b52:	e7fa      	b.n	6b4a <__ascii_wctomb+0xe>

00006b54 <memchr>:
    6b54:	b2c9      	uxtb	r1, r1
    6b56:	1882      	adds	r2, r0, r2
    6b58:	4290      	cmp	r0, r2
    6b5a:	d101      	bne.n	6b60 <memchr+0xc>
    6b5c:	2000      	movs	r0, #0
    6b5e:	4770      	bx	lr
    6b60:	7803      	ldrb	r3, [r0, #0]
    6b62:	428b      	cmp	r3, r1
    6b64:	d0fb      	beq.n	6b5e <memchr+0xa>
    6b66:	3001      	adds	r0, #1
    6b68:	e7f6      	b.n	6b58 <memchr+0x4>

00006b6a <memmove>:
    6b6a:	b510      	push	{r4, lr}
    6b6c:	4288      	cmp	r0, r1
    6b6e:	d902      	bls.n	6b76 <memmove+0xc>
    6b70:	188b      	adds	r3, r1, r2
    6b72:	4298      	cmp	r0, r3
    6b74:	d308      	bcc.n	6b88 <memmove+0x1e>
    6b76:	2300      	movs	r3, #0
    6b78:	429a      	cmp	r2, r3
    6b7a:	d007      	beq.n	6b8c <memmove+0x22>
    6b7c:	5ccc      	ldrb	r4, [r1, r3]
    6b7e:	54c4      	strb	r4, [r0, r3]
    6b80:	3301      	adds	r3, #1
    6b82:	e7f9      	b.n	6b78 <memmove+0xe>
    6b84:	5c8b      	ldrb	r3, [r1, r2]
    6b86:	5483      	strb	r3, [r0, r2]
    6b88:	3a01      	subs	r2, #1
    6b8a:	d2fb      	bcs.n	6b84 <memmove+0x1a>
    6b8c:	bd10      	pop	{r4, pc}

00006b8e <_realloc_r>:
    6b8e:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    6b90:	0007      	movs	r7, r0
    6b92:	000d      	movs	r5, r1
    6b94:	0016      	movs	r6, r2
    6b96:	2900      	cmp	r1, #0
    6b98:	d105      	bne.n	6ba6 <_realloc_r+0x18>
    6b9a:	0011      	movs	r1, r2
    6b9c:	f7ff fb6a 	bl	6274 <_malloc_r>
    6ba0:	0004      	movs	r4, r0
    6ba2:	0020      	movs	r0, r4
    6ba4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    6ba6:	2a00      	cmp	r2, #0
    6ba8:	d103      	bne.n	6bb2 <_realloc_r+0x24>
    6baa:	f7ff fb19 	bl	61e0 <_free_r>
    6bae:	0034      	movs	r4, r6
    6bb0:	e7f7      	b.n	6ba2 <_realloc_r+0x14>
    6bb2:	f000 f812 	bl	6bda <_malloc_usable_size_r>
    6bb6:	002c      	movs	r4, r5
    6bb8:	4286      	cmp	r6, r0
    6bba:	d9f2      	bls.n	6ba2 <_realloc_r+0x14>
    6bbc:	0031      	movs	r1, r6
    6bbe:	0038      	movs	r0, r7
    6bc0:	f7ff fb58 	bl	6274 <_malloc_r>
    6bc4:	1e04      	subs	r4, r0, #0
    6bc6:	d0ec      	beq.n	6ba2 <_realloc_r+0x14>
    6bc8:	0029      	movs	r1, r5
    6bca:	0032      	movs	r2, r6
    6bcc:	f7ff fae8 	bl	61a0 <memcpy>
    6bd0:	0029      	movs	r1, r5
    6bd2:	0038      	movs	r0, r7
    6bd4:	f7ff fb04 	bl	61e0 <_free_r>
    6bd8:	e7e3      	b.n	6ba2 <_realloc_r+0x14>

00006bda <_malloc_usable_size_r>:
    6bda:	1f0b      	subs	r3, r1, #4
    6bdc:	681b      	ldr	r3, [r3, #0]
    6bde:	1f18      	subs	r0, r3, #4
    6be0:	2b00      	cmp	r3, #0
    6be2:	da01      	bge.n	6be8 <_malloc_usable_size_r+0xe>
    6be4:	580b      	ldr	r3, [r1, r0]
    6be6:	18c0      	adds	r0, r0, r3
    6be8:	4770      	bx	lr
    6bea:	0000      	movs	r0, r0
    6bec:	682f2e2e 	.word	0x682f2e2e
    6bf0:	732f6c61 	.word	0x732f6c61
    6bf4:	682f6372 	.word	0x682f6372
    6bf8:	695f6c61 	.word	0x695f6c61
    6bfc:	6d5f6332 	.word	0x6d5f6332
    6c00:	6e79735f 	.word	0x6e79735f
    6c04:	00632e63 	.word	0x00632e63
    6c08:	682f2e2e 	.word	0x682f2e2e
    6c0c:	732f6c61 	.word	0x732f6c61
    6c10:	682f6372 	.word	0x682f6372
    6c14:	695f6c61 	.word	0x695f6c61
    6c18:	00632e6f 	.word	0x00632e6f
    6c1c:	682f2e2e 	.word	0x682f2e2e
    6c20:	732f6c61 	.word	0x732f6c61
    6c24:	682f6372 	.word	0x682f6372
    6c28:	755f6c61 	.word	0x755f6c61
    6c2c:	74726173 	.word	0x74726173
    6c30:	6e79735f 	.word	0x6e79735f
    6c34:	00632e63 	.word	0x00632e63

00006c38 <_map>:
    6c38:	0000000c 00000018 682f2e2e 652f6c70     ........../hpl/e
    6c48:	682f6369 655f6c70 632e6369 00000000     ic/hpl_eic.c....

00006c58 <_usarts>:
    6c58:	00000005 40100004 00030000 0000f62b     .......@....+...
    6c68:	00000000                                ....

00006c6c <_i2cms>:
    6c6c:	00000001 00200014 00000100 0000e6e5     ...... .........
    6c7c:	00d70000 02dc8000                       ........

00006c84 <_i2css>:
	...

00006c94 <sercomspi_regs>:
	...
    6ca8:	682f2e2e 732f6c70 6f637265 70682f6d     ../hpl/sercom/hp
    6cb8:	65735f6c 6d6f6372 0000632e 74696e69     l_sercom.c..init
    6cc8:	696c6169 6620657a 656c6961 65202c64     ialize failed, e
    6cd8:	726f7272 646f6320 25203a65 00000d64     rror code: %d...
    6ce8:	70696843 6d616e20 093a2065 0d0a7325     Chip name :.%s..
    6cf8:	00000000 756e614d 74636166 72657275     ....Manufacturer
    6d08:	2509203a 000d0a73 65746e49 63616672     : .%s...Interfac
    6d18:	09203a65 0d0a7325 00000000 70707553     e: .%s......Supp
    6d28:	7620796c 61746c6f 6d206567 3a207861     ly voltage max :
    6d38:	30250920 5666322e 00000d0a 70707553      .%0.2fV....Supp
    6d48:	7620796c 61746c6f 6d206567 203a6e69     ly voltage min: 
    6d58:	2e302509 0a566632 0000000d 6978614d     .%0.2fV.....Maxi
    6d68:	206d756d 72727563 3a746e65 30250920     mum current: .%0
    6d78:	6d66312e 000d0a41 706d6554 74617265     .1fmA...Temperat
    6d88:	20657275 3a78614d 2e250920 0a436631     ure Max: .%.1fC.
    6d98:	0000000d 706d6554 74617265 20657275     ....Temperature 
    6da8:	3a6e694d 2e250920 0a436631 0000000d     Min: .%.1fC.....
    6db8:	76697244 76207265 69737265 203a6e6f     Driver version: 
    6dc8:	2e255609 252e6631 0a64322e 0000000d     .V%.1f.%.2d.....
    6dd8:	20657554 206e614a 31203332 31343a36     Tue Jan 23 16:41
    6de8:	2034333a 34323032 00000000 656d6954     :34 2024....Time
    6df8:	2e25203a 003a6432 64322e25 00000000     : %.2d:.%.2d....
    6e08:	61640a0d 203a6574 00007325 322e2520     ..date: %s.. %.2
    6e18:	00000064 00732520 20642520 00000d0a     d... %s. %d ....
    6e28:	72616c61 6974206d 203a656d 64322e25     alarm time: %.2d
    6e38:	0000003a 67616c66 0a642520 00000000     :...flag %d.....
    6e48:	20727770 6c696166 322e253a 00003a64     pwr fail:%.2d:..
    6e58:	64322e25 00202d20 64322e25 00000a0d     %.2d - .%.2d....
    6e68:	656d6974 74616420 25203a65 0a0d756c     time date: %lu..
    6e78:	00000000 72727563 20746e65 203a6d74     ....current tm: 
    6e88:	252d6425 64252d64 30252020 253a6432     %d-%d-%d  %02d:%
    6e98:	3a643230 64323025 7325202c 00000d0a     02d:%02d, %s....
    6ea8:	6c696166 74206465 6c61206f 61636f6c     failed to alloca
    6eb8:	6d206574 726f6d65 000d0a79 70322e25     te memory...%.2p
    6ec8:	00003a20 70322e25 00000020 6c696166      :..%.2p ...fail
    6ed8:	74206465 6c61206f 61636f6c 64206574     ed to allocate d
    6ee8:	6d616e79 6d206369 726f6d65 000d0a79     ynamic memory...
    6ef8:	636f7065 72772068 65747469 25203a6e     epoch written: %
    6f08:	0a70382e 0000000d 72706565 67206d6f     .8p.....eeprom g
    6f18:	203a7465 0a756c25 0000000d 4c4c554e     et: %lu.....NULL
    6f28:	00000000 756e614a 00797261 72626546     ....January.Febr
    6f38:	79726175 00000000 6372614d 00000068     uary....March...
    6f48:	69727041 0000006c 0079614d 656e754a     April...May.June
    6f58:	00000000 796c754a 00000000 75677541     ....July....Augu
    6f68:	00007473 74706553 65626d65 00000072     st..September...
    6f78:	6f74634f 00726562 65766f4e 7265626d     October.November
    6f88:	00000000 65636544 7265626d 00000000     ....December....
    6f98:	646e7553 00007961 646e6f4d 00007961     Sunday..Monday..
    6fa8:	73657554 00796164 6e646557 61647365     Tuesday.Wednesda
    6fb8:	00000079 72756854 79616473 00000000     y...Thursday....
    6fc8:	64697246 00007961 75746153 79616472     Friday..Saturday
    6fd8:	00000000                                ....

00006fdc <days_in_month>:
    6fdc:	1e1f1c1f 1f1f1e1f 1f1e1f1e 3770636d     ............mcp7
    6fec:	78783439 6166203a 64656c69 206f7420     94xx: failed to 
    6ffc:	0d2e7325 0000000a 3770636d 78783439     %s......mcp794xx
    700c:	3269203a 6e692063 61697469 657a696c     : i2c initialize
    701c:	20736920 6c6c756e 0000000a 3770636d      is null....mcp7
    702c:	78783439 3269203a 65645f63 20746e69     94xx: i2c_deint 
    703c:	6e207369 0a6c6c75 00000000 3770636d     is null.....mcp7
    704c:	78783439 3269203a 65725f63 69206461     94xx: i2c_read i
    705c:	756e2073 000a6c6c 3770636d 78783439     s null..mcp794xx
    706c:	3269203a 72775f63 20657469 6e207369     : i2c_write is n
    707c:	0a6c6c75 00000000 3770636d 78783439     ull.....mcp794xx
    708c:	6572203a 76696563 61635f65 61626c6c     : receive_callba
    709c:	000a6b63 3770636d 78783439 6564203a     ck..mcp794xx: de
    70ac:	5f79616c 000a736d 3770636d 78783439     lay_ms..mcp794xx
    70bc:	3269203a 6e692063 61697469 657a696c     : i2c initialize
    70cc:	69616620 0a64656c 00000000 692d6564      failed.....de-i
    70dc:	6974696e 7a696c61 32692065 00000063     nitialize i2c...
    70ec:	20746573 20633269 76616c73 64612065     set i2c slave ad
    70fc:	73657264 00000073 20746567 69726176     dress...get vari
    710c:	00746e61 20746567 75626564 72702067     ant.get debug pr
    711c:	20746e69 636e7566 6e6f6974 66756220     int function buf
    712c:	20726566 657a6973 00000000 64616572     fer size....read
    713c:	6d697420 6e612065 61642064 00006574      time and date..
    714c:	64616572 756f6820 6f662072 74616d72     read hour format
    715c:	66656220 2065726f 74697277 00000065      before write...
    716c:	20746573 72756f68 726f6620 2074616d     set hour format 
    717c:	00000000 20746567 72756f68 726f6620     ....get hour for
    718c:	0074616d 64616572 6d697420 6d612065     mat.read time am
    719c:	206d702f 69646e69 6f746163 65622072     /pm indicator be
    71ac:	65726f66 69727720 00006574 20746573     fore write..set 
    71bc:	656d6974 2f6d6120 69206d70 6369646e     time am/pm indic
    71cc:	726f7461 00000000 20746573 656d6974     ator....set time
    71dc:	6579202c 63207261 6e206e61 6220746f     , year can not b
    71ec:	656c2065 74207373 206e6168 726f2030     e less than 0 or
    71fc:	65726720 72657461 61687420 3939206e      greater than 99
    720c:	00000000 20746573 656d6974 6f6d202c     ....set time, mo
    721c:	2068746e 206e6163 20746f6e 6c206562     nth can not be l
    722c:	20737365 6e616874 6f203120 72672072     ess than 1 or gr
    723c:	65746165 68742072 31206e61 00000032     eater than 12...
    724c:	20746573 656d6974 6164202c 63206574     set time, date c
    725c:	6e206e61 6220746f 656c2065 74207373     an not be less t
    726c:	206e6168 726f2031 65726720 72657461     han 1 or greater
    727c:	61687420 3133206e 00000000 20746573      than 31....set 
    728c:	656d6974 6577202c 64206b65 63207961     time, week day c
    729c:	6e206e61 6220746f 656c2065 74207373     an not be less t
    72ac:	206e6168 726f2031 65726720 72657461     han 1 or greater
    72bc:	61687420 0037206e 20746573 656d6974      than 7.set time
    72cc:	696d202c 6574756e 6e616320 746f6e20     , minute can not
    72dc:	20656220 7373656c 61687420 2030206e      be less than 0 
    72ec:	6720726f 74616572 74207265 206e6168     or greater than 
    72fc:	00003935 20746573 656d6974 6573202c     59..set time, se
    730c:	646e6f63 61632073 6f6e206e 65622074     conds can not be
    731c:	73656c20 68742073 30206e61 20726f20      less than 0 or 
    732c:	61657267 20726574 6e616874 00393520     greater than 59.
    733c:	20746573 656d6974 6f68202c 63207275     set time, hour c
    734c:	6e206e61 6220746f 656c2065 74207373     an not be less t
    735c:	206e6168 726f2030 65726720 72657461     han 0 or greater
    736c:	61687420 3332206e 00000000 20746573      than 23....set 
    737c:	656d6974 6f68202c 63207275 6e206e61     time, hour can n
    738c:	6220746f 656c2065 74207373 206e6168     ot be less than 
    739c:	726f2031 65726720 72657461 61687420     1 or greater tha
    73ac:	3231206e 00000000 20746573 656d6974     n 12....set time
    73bc:	6e69202c 696c6176 69742064 6620656d     , invalid time f
    73cc:	616d726f 00000074 64616572 6d697420     ormat...read tim
    73dc:	65622065 65726f66 69727720 00006574     e before write..
    73ec:	77206f74 65746972 63657320 73646e6f     to write seconds
    73fc:	00000000 77206f74 65746972 6e696d20     ....to write min
    740c:	73657475 00000000 77206f74 65746972     utes....to write
    741c:	756f6820 00007372 77206f74 65746972      hours..to write
    742c:	65657720 6164206b 00000079 77206f74      week day...to w
    743c:	65746972 74616420 00000065 77206f74     rite date...to w
    744c:	65746972 6e6f6d20 00006874 77206f74     rite month..to w
    745c:	65746972 61657920 00000072 64616572     rite year...read
    746c:	6d697420 6d612065 206d702f 69646e69      time am/pm indi
    747c:	6f746163 00000072 64616572 63736f20     cator...read osc
    748c:	616c6c69 20726f74 74617473 62207375     illator status b
    749c:	726f6665 72772065 00657469 20746573     efore write.set 
    74ac:	6963736f 74616c6c 7320726f 75746174     oscillator statu
    74bc:	00000073 20746567 6963736f 74616c6c     s...get oscillat
    74cc:	7320726f 75746174 00000073 61656c63     or status...clea
    74dc:	77702072 61662072 73206c69 75746174     r pwr fail statu
    74ec:	6e202c73 7320746f 6f707075 64657472     s, not supported
    74fc:	726f6620 65687420 70636d20 30343937      for the mcp7940
    750c:	6176204d 6e616972 00000074 64616572     M variant...read
    751c:	61747320 20737574 00676572 61656c63      status reg.clea
    752c:	77702072 61662072 73206c69 75746174     r pwr fail statu
    753c:	00000073 20746567 20727770 6c696166     s...get pwr fail
    754c:	61747320 2c737574 746f6e20 70757320      status, not sup
    755c:	74726f70 66206465 7420726f 6d206568     ported for the m
    756c:	39377063 204d3034 69726176 00746e61     cp7940M variant.
    757c:	64616572 776f7020 752d7265 69742070     read power-up ti
    758c:	7320656d 706d6174 6f6e202c 75732074     me stamp, not su
    759c:	726f7070 20646574 20726f66 20656874     pported for the 
    75ac:	3770636d 4d303439 72617620 746e6169     mcp7940M variant
    75bc:	00000000 64616572 776f7020 642d7265     ....read power-d
    75cc:	206e776f 656d6974 61747320 0000706d     own time stamp..
    75dc:	64616572 776f7020 752d7265 69742070     read power-up ti
    75ec:	7320656d 706d6174 00000000 61766e69     me stamp....inva
    75fc:	2064696c 20727770 6c696166 646f6d20     lid pwr fail mod
    760c:	65732065 7463656c 00006465 20727770     e selected..pwr 
    761c:	6c696166 72617020 202c6d61 20746f6e     fail param, not 
    762c:	70707573 6574726f 6f662064 68742072     supported for th
    763c:	636d2065 34393770 76204d30 61697261     e mcp7940M varia
    764c:	0000746e 64616572 61656c20 65792070     nt..read leap ye
    765c:	72207261 73696765 00726574 64616572     ar register.read
    766c:	6e6f6320 6c6f7274 67657220 65747369      control registe
    767c:	00000072 74697277 6c612065 206d7261     r...write alarm 
    768c:	62616e65 7320656c 75746174 00000073     enable status...
    769c:	64616572 616c6120 65206d72 6c62616e     read alarm enabl
    76ac:	65722065 74736967 00007265 64616572     e register..read
    76bc:	616c6120 30206d72 6c6f7020 74697261      alarm 0 polarit
    76cc:	65722079 74736967 00007265 64616572     y register..read
    76dc:	616c6120 31206d72 6c6f7020 74697261      alarm 1 polarit
    76ec:	65722079 74736967 00007265 61766e69     y register..inva
    76fc:	2064696c 72616c61 6573206d 7463656c     lid alarm select
    770c:	00006465 20746573 72616c61 6974206d     ed..set alarm ti
    771c:	202c656d 746e6f6d 61632068 6f6e206e     me, month can no
    772c:	65622074 73656c20 68742073 30206e61     t be less than 0
    773c:	20726f20 61657267 20726574 6e616874      or greater than
    774c:	00323120 20746573 72616c61 6974206d      12.set alarm ti
    775c:	202c656d 65746164 6e616320 746f6e20     me, date can not
    776c:	20656220 7373656c 61687420 2030206e      be less than 0 
    777c:	6720726f 74616572 74207265 206e6168     or greater than 
    778c:	00003133 20746573 72616c61 6974206d     31..set alarm ti
    779c:	202c656d 6b656577 79616420 6e616320     me, week day can
    77ac:	746f6e20 20656220 7373656c 61687420      not be less tha
    77bc:	2031206e 6720726f 74616572 74207265     n 1 or greater t
    77cc:	206e6168 00000037 20746573 72616c61     han 7...set alar
    77dc:	6974206d 202c656d 72756f68 6e616320     m time, hour can
    77ec:	746f6e20 20656220 7373656c 61687420      not be less tha
    77fc:	2030206e 6720726f 74616572 74207265     n 0 or greater t
    780c:	206e6168 00003332 20746573 72616c61     han 23..set alar
    781c:	6974206d 202c656d 756e696d 63206574     m time, minute c
    782c:	6e206e61 6220746f 656c2065 74207373     an not be less t
    783c:	206e6168 726f2030 65726720 72657461     han 0 or greater
    784c:	61687420 3935206e 00000000 20746573      than 59....set 
    785c:	72616c61 6974206d 202c656d 6f636573     alarm time, seco
    786c:	2073646e 206e6163 20746f6e 6c206562     nds can not be l
    787c:	20737365 6e616874 6f203020 72672072     ess than 0 or gr
    788c:	65746165 68742072 35206e61 00000039     eater than 59...
    789c:	20746573 72616c61 6974206d 202c656d     set alarm time, 
    78ac:	72756f68 6e616320 746f6e20 20656220     hour can not be 
    78bc:	7373656c 61687420 2030206e 6720726f     less than 0 or g
    78cc:	74616572 74207265 206e6168 00003231     reater than 12..
    78dc:	20746573 72616c61 6974206d 202c656d     set alarm time, 
    78ec:	61766e69 2064696c 656d6974 726f6620     invalid time for
    78fc:	0074616d 77206f74 65746972 616c6120     mat.to write ala
    790c:	30206d72 63657320 73646e6f 00000000     rm 0 seconds....
    791c:	77206f74 65746972 616c6120 30206d72     to write alarm 0
    792c:	6e696d20 73657475 00000000 77206f74      minutes....to w
    793c:	65746972 616c6120 30206d72 756f6820     rite alarm 0 hou
    794c:	00007372 77206f74 65746972 616c6120     rs..to write ala
    795c:	30206d72 65657720 6164206b 00000079     rm 0 week day...
    796c:	77206f74 65746972 616c6120 30206d72     to write alarm 0
    797c:	74616420 00000065 77206f74 65746972      date...to write
    798c:	616c6120 30206d72 6e6f6d20 00006874      alarm 0 month..
    799c:	77206f74 65746972 616c6120 31206d72     to write alarm 1
    79ac:	63657320 73646e6f 00000000 77206f74      seconds....to w
    79bc:	65746972 616c6120 31206d72 6e696d20     rite alarm 1 min
    79cc:	73657475 00000000 77206f74 65746972     utes....to write
    79dc:	616c6120 31206d72 756f6820 00007372      alarm 1 hours..
    79ec:	77206f74 65746972 616c6120 31206d72     to write alarm 1
    79fc:	65657720 6164206b 00000079 77206f74      week day...to w
    7a0c:	65746972 616c6120 31206d72 74616420     rite alarm 1 dat
    7a1c:	00000065 77206f74 65746972 616c6120     e...to write ala
    7a2c:	31206d72 6e6f6d20 00006874 64616572     rm 1 month..read
    7a3c:	616c6120 30206d72 73616d20 6572206b      alarm 0 mask re
    7a4c:	74736967 00007265 6c696166 74206465     gister..failed t
    7a5c:	6573206f 6c612074 206d7261 00000030     o set alarm 0...
    7a6c:	64616572 616c6120 31206d72 73616d20     read alarm 1 mas
    7a7c:	6572206b 74736967 00007265 6c696166     k register..fail
    7a8c:	74206465 6573206f 6c612074 206d7261     ed to set alarm 
    7a9c:	00000031 64616572 616c6120 30206d72     1...read alarm 0
    7aac:	6d697420 6e612065 61642064 00006574      time and date..
    7abc:	64616572 616c6120 31206d72 6d697420     read alarm 1 tim
    7acc:	6e612065 61642064 00006574 6c696166     e and date..fail
    7adc:	74206465 6567206f 6c612074 206d7261     ed to get alarm 
    7aec:	656d6974 646e6120 74616420 00000065     time and date...
    7afc:	6c696166 72206465 20646165 72616c61     failed read alar
    7b0c:	616d206d 00006b73 6c696166 74206465     m mask..failed t
    7b1c:	6572206f 61206461 6d72616c 69203020     o read alarm 0 i
    7b2c:	7265746e 74707572 616c6620 00000067     nterrupt flag...
    7b3c:	6c696166 74206465 6572206f 61206461     failed to read a
    7b4c:	6d72616c 69203120 7265746e 74707572     larm 1 interrupt
    7b5c:	616c6620 00000067 64616572 616c6120      flag...read ala
    7b6c:	30206d72 746e6920 75727265 66207470     rm 0 interrupt f
    7b7c:	2067616c 69676572 72657473 00000000     lag register....
    7b8c:	61656c63 6c612072 206d7261 6e692030     clear alarm 0 in
    7b9c:	72726574 20747075 67616c66 74696220     terrupt flag bit
    7bac:	00000000 64616572 616c6120 31206d72     ....read alarm 1
    7bbc:	746e6920 75727265 66207470 2067616c      interrupt flag 
    7bcc:	69676572 72657473 00000000 61656c63     register....clea
    7bdc:	6c612072 206d7261 6e692031 72726574     r alarm 1 interr
    7bec:	20747075 67616c66 74696220 00000000     upt flag bit....
    7bfc:	64616572 72746320 6572206c 74736967     read ctrl regist
    7c0c:	00007265 74697277 74632065 72206c72     er..write ctrl r
    7c1c:	73696765 00726574 64616572 63736f20     egister.read osc
    7c2c:	616c6c69 20726f74 69676964 206c6174     illator digital 
    7c3c:	6d697274 67657220 65747369 00000072     trim register...
    7c4c:	74697277 736f2065 6c6c6963 726f7461     write oscillator
    7c5c:	67696420 6c617469 69727420 6572206d      digital trim re
    7c6c:	74736967 00007265 64616572 63736f20     gister..read osc
    7c7c:	616c6c69 20726f74 6e6e7572 20676e69     illator running 
    7c8c:	74617473 00007375 20746573 65747865     status..set exte
    7c9c:	6c616e72 74616220 79726574 6b636220     rnal battery bck
    7cac:	202c7075 20746f6e 70707573 6574726f     up, not supporte
    7cbc:	6f662064 68742072 636d2065 34393770     d for the mcp794
    7ccc:	76204d30 61697261 0000746e 20746573     0M variant..set 
    7cdc:	65747865 6c616e72 74616220 79726574     external battery
    7cec:	6b636220 00007075 20746573 65747865      bckup..set exte
    7cfc:	6c616e72 74616220 79726574 6b636220     rnal battery bck
    7d0c:	73207075 75746174 00000073 64616572     up status...read
    7d1c:	74786520 616e7265 6162206c 72657474      external batter
    7d2c:	63622079 2070756b 74617473 00007375     y bckup status..
    7d3c:	20746573 65747865 6c616e72 63736f20     set external osc
    7d4c:	616c6c69 00726f74 64616572 63736f20     illator.read osc
    7d5c:	616c6c69 20726f74 74617473 62207375     illator status b
    7d6c:	00007469 20746573 2063736f 72617473     it..set osc star
    7d7c:	69622074 00000074 64616572 63736f20     t bit...read osc
    7d8c:	616c6c69 20726f74 72617473 69622074     illator start bi
    7d9c:	00000074 20746573 6e756f63 776f6474     t...set countdow
    7dac:	6e69206e 72726574 2c747075 414c4120     n interrupt, ALA
    7dbc:	30204d52 746f6e20 73696420 656c6261     RM 0 not disable
    7dcc:	00000064 20746573 6e756f63 776f6474     d...set countdow
    7ddc:	6e69206e 72726574 00747075 6e756f63     n interrupt.coun
    7dec:	776f6474 6e69206e 72726574 2c747075     tdown interrupt,
    7dfc:	766e6920 64696c61 6d697420 6e752065      invalid time un
    7e0c:	00007469 64616572 72756320 746e6572     it..read current
    7e1c:	6d697420 6e612065 61642064 00006574      time and date..
    7e2c:	6c696166 74206465 6572206f 55206461     failed to read U
    7e3c:	202c4449 75736e75 726f7070 20646574     ID, unsupported 
    7e4c:	20646d63 20726f66 3770636d 30303439     cmd for mcp79400
    7e5c:	72617620 746e6169 00000000 6c696166      variant....fail
    7e6c:	74206465 6572206f 55206461 00004449     ed to read UID..
    7e7c:	6c696166 74206465 6572206f 55206461     failed to read U
    7e8c:	202c4449 75736e75 726f7070 20646574     ID, unsupported 
    7e9c:	20646d63 20726f66 3770636d 6d303439     cmd for mcp7940m
    7eac:	72617620 746e6169 00000000 6c696166      variant....fail
    7ebc:	74206465 6572206f 55206461 202c4449     ed to read UID, 
    7ecc:	75736e75 726f7070 20646574 20646d63     unsupported cmd 
    7edc:	20726f66 3770636d 6e303439 72617620     for mcp7940n var
    7eec:	746e6169 00000000 6c696166 74206465     iant....failed t
    7efc:	6572206f 55206461 202c4449 75736e75     o read UID, unsu
    7f0c:	726f7070 20646574 20646d63 20726f66     pported cmd for 
    7f1c:	3770636d 30313439 72617620 746e6169     mcp79410 variant
    7f2c:	00000000 74697277 72732065 202c6d61     ....write sram, 
    7f3c:	61766e69 2064696c 72646461 00737365     invalid address.
    7f4c:	74697277 72732065 202c6d61 72646461     write sram, addr
    7f5c:	20737365 276e6163 65622074 65726720     ess can't be gre
    7f6c:	72657461 61687420 7830206e 00004635     ater than 0x5F..
    7f7c:	74697277 72732065 202c6d61 72646461     write sram, addr
    7f8c:	20737365 2074756f 7220666f 65676e61     ess out of range
    7f9c:	00000000 74697277 6f742065 61727320     ....write to sra
    7fac:	0000006d 64616572 61727320 69202c6d     m...read sram, i
    7fbc:	6c61766e 61206469 65726464 00007373     nvalid address..
    7fcc:	64616572 61727320 61202c6d 65726464     read sram, addre
    7fdc:	63207373 74276e61 20656220 61657267     ss can't be grea
    7fec:	20726574 6e616874 35783020 00000046     ter than 0x5F...
    7ffc:	64616572 61727320 61202c6d 65726464     read sram, addre
    800c:	6f207373 6f207475 61722066 0065676e     ss out of range.
    801c:	64616572 61727320 0000006d 73617265     read sram...eras
    802c:	72732065 73206d61 6f746365 69202c72     e sram sector, i
    803c:	6c61766e 61206469 65726464 28207373     nvalid address (
    804c:	30327830 30202d20 29373578 00000000     0x20 - 0x57)....
    805c:	73617265 72732065 73206d61 6f746365     erase sram secto
    806c:	00000072 65706977 61727320 0000006d     r...wipe sram...
    807c:	72206f74 20646165 72706565 202c6d6f     to read eeprom, 
    808c:	61766e69 2064696c 72646461 00737365     invalid address.
    809c:	72206f74 20646165 72706565 202c6d6f     to read eeprom, 
    80ac:	72646461 20737365 2074756f 7220666f     address out of r
    80bc:	65676e61 00000000 61766e69 2064696c     ange....invalid 
    80cc:	69766564 76206563 61697261 202c746e     device variant, 
    80dc:	20656874 69766564 64206563 2073656f     the device does 
    80ec:	65766168 65206120 6f727065 7562206d     have a eeprom bu
    80fc:	2d746c69 00006e69 64616572 70656520     ilt-in..read eep
    810c:	006d6f72 74697277 65652065 6d6f7270     rom.write eeprom
    811c:	6f6c6220 70206b63 65746f72 20207463      block protect  
    812c:	00676572 64616572 70656520 206d6f72     reg.read eeprom 
    813c:	636f6c62 7270206b 6365746f 65722074     block protect re
    814c:	00000067 76206f74 66697265 656d2079     g...to verify me
    815c:	79726f6d 6f6c6220 70206b63 65746f72     mory block prote
    816c:	73207463 75746174 00000073 77206f74     ct status...to w
    817c:	65746972 70656520 2c6d6f72 766e6920     rite eeprom, inv
    818c:	64696c61 64646120 73736572 00000000     alid address....
    819c:	77206f74 65746972 70656520 2c6d6f72     to write eeprom,
    81ac:	64646120 73736572 74756f20 20666f20      address out of 
    81bc:	676e6172 00000065 74697277 65652065     range...write ee
    81cc:	6d6f7270 7461202c 706d6574 6f742074     prom, attempt to
    81dc:	69727720 61206574 6f6c6220 70206b63      write a block p
    81ec:	65746f72 64657463 67657220 006e6f69     rotected region.
    81fc:	74697277 65652065 6d6f7270 00000000     write eeprom....
    820c:	61647075 65206574 6f727065 72202c6d     update eeprom, r
    821c:	20646165 6c696166 00006465 61647075     ead failed..upda
    822c:	65206574 6f727065 77202c6d 65746972     te eeprom, write
    823c:	69616620 0064656c 73617265 65652065      failed.erase ee
    824c:	6d6f7270 63657320 00726f74 65706977     prom sector.wipe
    825c:	70656520 006d6f72 3770636d 78783439      eeprom.mcp794xx
    826c:	6170203a 25206567 73692064 65726720     : page %d is gre
    827c:	72657461 61687420 616d206e 61702078     ater than max pa
    828c:	6e206567 65626d75 64252072 00000a0d     ge number %d....
    829c:	65206f74 65736172 67617020 69202c65     to erase page, i
    82ac:	6c61766e 70206469 20656761 626d756e     nvalid page numb
    82bc:	00007265 65206f74 65736172 67617020     er..to erase pag
    82cc:	00000065 65206f74 75636578 202c6574     e...to execute, 
    82dc:	65747461 2074706d 77206f74 65746972     attempt to write
    82ec:	79656220 20646e6f 65676170 756f6220      beyond page bou
    82fc:	7261646e 00000079 3770636d 78783439     ndary...mcp794xx
    830c:	6170203a 25206567 74732064 20747261     : page %d start 
    831c:	72646461 3a737365 65206425 6120646e     address:%d end a
    832c:	65726464 253a7373 000a0d64 20747570     ddress:%d...put 
    833c:	65747962 00000073 20746567 65747962     bytes...get byte
    834c:	00000073 74697277 65722065 74736967     s...write regist
    835c:	00007265 64616572 67657220 65747369     er..read registe
    836c:	00000072 3750434d 78783439 00000000     r...MCP794xx....
    837c:	00433249 7263694d 6968636f 00000070     I2C.Microchip...
    838c:	74696e69 696c6169 0000657a 20633269     initialize..i2c 
    839c:	74697277 61662065 64656c69 6863202c     write failed, ch
    83ac:	206b6365 20656874 20633269 72646461     eck the i2c addr
    83bc:	20737365 7720726f 6e697269 00000a67     ess or wiring...
    83cc:	0000508c 00004fdc 00004fdc 00004fda     .P...O...O...O..
    83dc:	0000507e 0000507e 00005074 00004fda     ~P..~P..tP...O..
    83ec:	0000507e 00005074 0000507e 00004fda     ~P..tP..~P...O..
    83fc:	00005084 00005084 00005084 00005114     .P...P...P...Q..

0000840c <__sf_fake_stderr>:
	...

0000842c <__sf_fake_stdin>:
	...

0000844c <__sf_fake_stdout>:
	...
    846c:	4f500043 00584953 2d23002e 00202b30     C.POSIX...#-0+ .
    847c:	004c6c68 45676665 30004746 34333231     hlL.efgEFG.01234
    848c:	38373635 43424139 00464544 33323130     56789ABCDEF.0123
    849c:	37363534 62613938 66656463 20200000              456789abcdef.

000084a9 <_ctype_>:
    84a9:	20202000 20202020 28282020 20282828     .         ((((( 
    84b9:	20202020 20202020 20202020 20202020                     
    84c9:	10108820 10101010 10101010 10101010      ...............
    84d9:	04040410 04040404 10040404 10101010     ................
    84e9:	41411010 41414141 01010101 01010101     ..AAAAAA........
    84f9:	01010101 01010101 01010101 10101010     ................
    8509:	42421010 42424242 02020202 02020202     ..BBBBBB........
    8519:	02020202 02020202 02020202 10101010     ................
    8529:	00000020 00000000 00000000 00000000      ...............
	...

000085ac <_init>:
    85ac:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    85ae:	46c0      	nop			; (mov r8, r8)
    85b0:	bcf8      	pop	{r3, r4, r5, r6, r7}
    85b2:	bc08      	pop	{r3}
    85b4:	469e      	mov	lr, r3
    85b6:	4770      	bx	lr

000085b8 <__init_array_start>:
    85b8:	000000dd 	.word	0x000000dd

000085bc <_fini>:
    85bc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    85be:	46c0      	nop			; (mov r8, r8)
    85c0:	bcf8      	pop	{r3, r4, r5, r6, r7}
    85c2:	bc08      	pop	{r3}
    85c4:	469e      	mov	lr, r3
    85c6:	4770      	bx	lr

000085c8 <__fini_array_start>:
    85c8:	000000b5 	.word	0x000000b5
